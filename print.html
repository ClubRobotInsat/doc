<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Documentation Club Robot Insa Toulouse</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Documentation Club Robot Insa Toulouse</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="images/com/logo_Club_blanc.svg" alt="" title="Logo du Club Robot" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Ce site internet contient la documentation du Club Robot de l'INSA Toulouse pour les parties électronique et informatique du robot.</p>
<p>Ce livre est rédigé avec <a href="https://github.com/rust-lang-nursery/mdBook">md-book</a>.</p>
<p>Le but de ce livre est de te guider pour l'installation des différents outils permettant de programmer au Club Robot.</p>
<p>Ce livre ne documentera pas le code du club, mais peut documenter les différents fichiers d'un projet. Il est là pour servir de référence en cas de problème et de questions vis à vis d'un fichier.</p>
<p>Sa lecture est préliminaire à la formation organisée en début d'année, et son but est de nous faire gagner du temps en vous faisant installer à la maison les outils de dévellopement.</p>
<p>Enfin, son écriture a commencé après Chocobot à la coupe de france de 2018 (Robot Cities). Temporairement arrêté en 2020, remplacé par Notion, il est repris en 2023.</p>
<p>Si jamais tu trouves des fautes d'orthographes, des erreurs, des remarques ou toutes autres formes de contribution à faire n'hésite <strong>surtout pas</strong>. Les sources de ce livre sont sur <a href="https://github.com/ClubRobotInsat/doc">ce repertoire GitHub</a>, et il n'y a pas besoin de <code>git</code> pour y apporter des modifications simples : l'interface en ligne de github te permet de modifier les fichiers textes et de créer ton premier <em>commit</em> en quelques secondes! Il faut juste penser à demander aux membres du club d'ajouter ton compte dans la liste des utilisateurs autorisés.</p>
<p>Enfin, la phrase la plus importante en informatique à garder en tête durant toute ta formation :</p>
<blockquote>
<p>Le mieux est l'ennemi du bien, surtout au club robot.</p>
</blockquote>
<p><em>Un illustre anonyme</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outils-communs"><a class="header" href="#outils-communs">Outils communs</a></h1>
<p>Cette section répertorie les principaux outils utilisés au Club Robot.</p>
<p>Ce tableau t'aidera à savoir quelles pages t'intéressent en fonction de ton pôle de prédilection :</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><a href="outils_communs/outils_communs/git.html">git</a></th><th style="text-align: center"><a href="outils_communs/outils_communs/ide.html">IntelliJ</a></th><th style="text-align: center"><a href="outils_communs/outils_communs/kicad.html">Kicad</a></th><th style="text-align: center"><a href="outils_communs/outils_communs/creo.html">Creo</a></th></tr></thead><tbody>
<tr><td style="text-align: center">Informatique</td><td style="text-align: center">✔️</td><td style="text-align: center">✔️</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Electronique software</td><td style="text-align: center">✔️</td><td style="text-align: center">✔️</td><td style="text-align: center">✔️</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Electronique hardware</td><td style="text-align: center">✔️</td><td style="text-align: center"></td><td style="text-align: center">✔️</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Mécanique</td><td style="text-align: center">✔️</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">✔️</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<p><em>Cette page s'adresse à tous les membres du Club.</em></p>
<p>On utilise <code>git</code> pour gérer les versions de nos projets. C'est un outil très puissant, mais qui peut être un peu déroutant au début. Cette page a pour but de te guider dans l'utilisation de <code>git</code> au Club Robot.</p>
<p>Ce choix a de très nombreux avantages :</p>
<ul>
<li>L'évolution de tout le code est sauvegardée donc on peut rappeler une version antérieure d'un fichier à tout moment</li>
<li>Si on perd des fichiers ou que l'on se trompe, on peut facilement revenir à un état stable</li>
<li><code>git</code> permets de collaborer sur un même code, c'est à dire que plusieurs développeurs peuvent participer au code et le logiciel s'occupe de rassembler l'ensemble des modifications</li>
<li>On peut profiter de tous ces avantages avec très peu de travail supplémentaire</li>
</ul>
<p>On héberge nos projets sur <a href="https://github.com/ClubRobotInsat">GitHub</a>. C'est un site qui permet de gérer des projets <code>git</code> en ligne. Il est très pratique car il permet de visualiser les modifications, de gérer les différentes versions, de faire des <em>pull requests</em> pour proposer des modifications, etc.</p>
<p><strong>Si vous n'êtes pas à l'aise avec <code>git</code> en ligne de commande, vous pouvez utiliser la version en ligne de GitHub.</strong> Elle est très bien faite et permet de faire la plupart des choses que l'on fait en ligne de commande.</p>
<h2 id="installation-de-git"><a class="header" href="#installation-de-git">Installation de <code>git</code></a></h2>
<p>Afin de bénéficier de tous les avantages de <code>git</code>, il n'y a rien de plus simple : il suffit d'exécuter la commande suivante.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install git
</code></pre>
<p><em><strong>Astuce :</strong></em> pour vérifier que l'installation d'une application a bien marché, tu peux appeler la commande <code>which</code> qui te retourne le chemin vers l'exécutable, ou encore l'exécuter avec le flag <code>--version</code> :</p>
<pre><code class="language-bash">$ which git
/usr/bin/git

$ git version
git version 2.34.1
</code></pre>
<h2 id="apprendre-à-utiliser-git"><a class="header" href="#apprendre-à-utiliser-git">Apprendre à utiliser <code>git</code></a></h2>
<h3 id="apprendre-en-ligne"><a class="header" href="#apprendre-en-ligne">Apprendre en ligne</a></h3>
<p><code>git</code> est un logiciel extrêmement pratique une fois qu'on l'a pris en main. Cependant, il peut être un peu déroutant au début. Il existe de nombreux tutoriels en ligne pour apprendre à l'utiliser. En voici quelques uns :</p>
<ul>
<li><a href="https://learngitbranching.js.org/">apprendre visuellement git</a> : un site qui permet d'apprendre à utiliser <code>git</code> en ligne de commande en visualisant les modifications</li>
<li><a href="https://rogerdudler.github.io/git-guide/index.fr.html">git - petit guide</a> : un guide très simple pour apprendre les bases de <code>git</code></li>
</ul>
<p>Vu qu'il sait faire de très nombreuses choses, ce n'est bien sûr pas la peine d'apprendre toutes ses commandes par coeur. Voici des <em>Cheat Sheets</em> qui vont te faire gagner du temps :</p>
<ul>
<li><a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf">Cheat sheet de GitHub (en)</a></li>
<li><a href="https://services.github.com/on-demand/downloads/fr/github-git-cheat-sheet.pdf">Chear sheet de GitHub (fr)</a></li>
<li><a href="https://www.git-tower.com/blog/git-cheat-sheet/">Cheat sheet de Tower</a></li>
</ul>
<h3 id="ba-ba-des-commandes"><a class="header" href="#ba-ba-des-commandes">B.A.-BA des commandes</a></h3>
<p>Si tu as besoin d'aide pour utiliser <code>git</code>, les forums de <a href="http://stackoverflow.com/">StackOverflow</a> te permettent de répondre à tes questions les plus complexes.</p>
<p>Ensuite, voici une <a href="https://git-scm.com/docs">documentation d'API</a> des différentes fonctions.</p>
<p>En général cependant, tu vas devoir utiliser le même socle de commandes et le but de ce paragraphe est de te lister le <em><strong>template</strong></em> de commandes à utiliser ; je t'invite néanmoins à aller lire la documentation de chacune de ces commandes pour voir à quel point elles peuvent être puissantes.</p>
<ol>
<li>
<p>Avant de commencer à travailler, il faut récupérer le travail réaliser par les autres développeurs. Si tu as déjà des <code>commit</code>s en local, tu peux spécifier le flag <code>--rebase</code> pour avoir une architecture linéaire ; sinon <code>git</code> va <code>merge</code>r la branche locale et celle distante même pour des intégrations triviales.</p>
<ul>
<li><code>git pull [--rebase]</code></li>
</ul>
</li>
<li>
<p>À présent, à toi de faire des modifications pour contribuer au dépôt. Une fois que tu as fini et que tu veux créer un paquet qui contient ta nouveauté, il faut demander à <code>git</code> de rajouter toutes tes modifications intéressantes. Tu peux également connaître les modfications que tu as faites soit fichier par fichier, soit ligne par ligne. Bien sûr, tu peux restreindre la recherche à un document ou à des fichiers en particulier en les rajoutant à la fin.</p>
<ul>
<li><code>git status</code> te liste tous les fichiers qui ont été modifiés / supprimés / créés</li>
<li><code>git diff</code> te montre toutes les additions et délétions dans le code pour l'ensemble de ces fichiers</li>
</ul>
</li>
<li>
<p>Il est temps de choisir les modifications que tu veux sauvegarder dans l'arborescence de <code>git</code>. Il y a plusieurs moyens d'y arriver en utilisant <code>git add</code> et <code>git reset</code> :</p>
<ul>
<li><code>git add *</code> te permets d'ajouter TOUTES les modifications, il ne faut donc pas l'utiliser si tu travailles sur plusieurs projets en même temps</li>
<li><code>git add &lt;file 1&gt; [file 2] [...]</code> ajoute les modifications de chaque fichier / dossier dans leur ensemble. Si tu crées un nouveau fichier, il faut utiliser cette méthode pour l'ajouter et non pas la suivante.</li>
<li><code>git add -p</code> permets de mixer <code>add</code> et <code>diff</code> ; il s'agit d'une méthode particulièrement efficace si tu as besoin de sauvegarder seulement quelques lignes et non pas l'ensemble des modifications sur un fichier. Une interface s'ouvre et tu peux choisir d'accepter avec <code>y</code> ou de refuser les modifications avec <code>n</code> ; d'autres commandes sont possibles notamment <code>q</code> pour quitter.</li>
<li><code>git reset</code> te permets d'annuler l'insertion des modifications dans la sauvegarde de <code>git</code> (mais il ne reset pas les modifications du fichier, rassure-toi). Tu peux également lui donner l'argument <code>-p</code> pour accéder à l'interface intéractive.</li>
</ul>
</li>
<li>
<p>Tu peux vérifier que tu as ajouter les bonnes modifications en appelant de nouveau</p>
<ul>
<li><code>git status</code> pour voir les fichiers</li>
<li><code>git diff --staged</code> pour voir les modifications dans le code</li>
</ul>
</li>
<li>
<p>Il est enfin temps de créer le 'paquet' de modifications, appelé <code>commit</code>. Afin de pouvoir s'y retrouver plus facilement, les <code>commit</code>s ont chacun un numéro unique (appelé hash ; il a cette tête : <code>44bf09d0a2c36585aed1c34ba2e5d958a9379718</code> et est généré automatiquement) et également un message que tu dois choisir pour expliquer ce à quoi il sert. C'est très intéressant de créer un <code>commit</code> par fonctionnalité, et donc qui modifie éventuellement plusieurs fichiers, afin de pouvoir relire l'historique ensuite. Pense donc à en réaliser plusieurs au cours de ton travail, tu pourras facilement revenir à des versions précédentes ce qui est très bénéfique !</p>
<ul>
<li><code>git commit -m &lt;message&gt;</code></li>
<li><code>git commit --amend</code> te permets de juste rajouter des modifications au dernier commit pour ne faire qu'un seul paquet avec les anciennes et nouvelles modifs.</li>
</ul>
</li>
<li>
<p>Maintenant que tu as créé plusieurs <code>commit</code>s, tu peux vérifier que tout s'est bien passé en faisant appel à l'historique. Tu pourras y observer le numéro de chaque commit, leur auteur, leur date de création ainsi que leur message d'accompagnement.</p>
<ul>
<li><code>git log</code></li>
</ul>
</li>
<li>
<p>Enfin, les modifications que tu viens de faire ont pour but d'être partagées aux autres développeurs et donc envoyés sur le dépôt distant de <a href="https://github.com/orgs/ClubRobotInsat/">github.com</a>. Normalement, si tu as bien suivi les étapes de clonage présentées un peu plus bas, tout devrait être déjà configuré pour n'avoir qu'à taper ceci :</p>
<ul>
<li><code>git push -u origin &lt;branch&gt;</code> la première fois pour demander à envoyer les <code>commit</code>s sur le flux <code>origin</code>, c'est à dire github, correspondant à la branche actuelle (par exemple <code>master</code>)</li>
<li><code>git push</code> les fois suivantes ; tout va marcher ensuite à condition d'avoir une connexion internet :wink:</li>
</ul>
</li>
</ol>
<p>Je n'ai pas parlé d'un certain nombre de commandes car tu ne devrais pas les utiliser quotidiennement. Voici une liste de fonctione néanmoins intéressantes dont tu peux aller voir la documentation :</p>
<ul>
<li><code>git branch</code> - notion que je n'ai que très peu abordée, <code>git</code> travaille avec des branches pour faciliter le travail sur plusieurs projets en parallèle</li>
<li><code>git checkout</code> - permets de se ballader d'une branche à une autre branche ou à un commit en particulier</li>
<li><code>git reset</code> - idél pour enlever les modifs d'un <code>git add</code> et pour supprimer des <code>commit</code>s foireux présents localement</li>
<li><code>git revert</code> - applique les modifications complémentaires à un commit, idéal pour annuler un commit foireux déjà envoyé sur le serveur</li>
<li><code>git merge</code> - permets à deux branches de fusionner ; fonctionnalité sympa pour travailler indépendamment sur un projet puis l'intégrer dans la branche principale une fois qu'il est fonctionnel</li>
<li><code>git rebase</code> - permets de copier des commits pour avoir une arborescence plus linéaire</li>
<li><code>git rebase -i</code> - fenêtre intéractive pour réorganiser les commits comme tu veux</li>
<li><code>cherry-pick</code> - copie un ensemble de commits à l'endroit actuel, ce qui simplifie l'utilisation d'un <code>git rebase</code></li>
<li><code>git stash</code> - mémorise des modifications dans un endroit à part ; ça te permets de sauvegarder un travail qui ne compile pas par exemple. Options intéressantes : <code>drop</code>, <code>pop</code>, <code>list</code>, <code>show</code>, <code>save &lt;NAME&gt;</code>, <code>-p</code>.</li>
<li><code>git tag</code> - marque permannante sur un commit pour y accéder n'importe quand (à sa création, il faut appeler <code>git push --follow-tags</code> pour le partager avec tout le monde).</li>
<li><code>git fetch</code> - télécharge les infos sur le dépôt distant ; contrairement à <code>git pull</code>, aucun <code>merge</code> n'est réalisé entre le dépôt localement et celui à distance, donc cette commande est très peu utilisée</li>
</ul>
<h2 id="création-dun-compte-github"><a class="header" href="#création-dun-compte-github">Création d'un compte <a href="https://github.com">GitHub</a></a></h2>
<p>Afin de partager notre travail, on utilise les serveurs de GitHub. Il s'agit d'un service web qui offre une interface graphique à <code>git</code> tout en permettant de récupérer les projets du Club n'importe où.</p>
<p>Il faut donc que tu te crées un compte sur le site : <a href="https://github.com/">github.com</a>.</p>
<p>Une fois que c'est fait, demande à un membre du Club de t'ajouter dans l'organisation <a href="https://github.com/orgs/ClubRobotInsat/">ClubRobotINSAT</a>.</p>
<h2 id="configuration-de-git"><a class="header" href="#configuration-de-git">Configuration de <code>git</code></a></h2>
<p>Il faut configurer ton ordinateur pour qu'il te connaisse, voici comment :</p>
<ol>
<li>Ton nom associé aux <code>commit</code>
<ul>
<li><code>git config --global user.name "[ton nom]"</code></li>
</ul>
</li>
<li>Ton adresse mail associée aux <code>commit</code> (de préférence celle utilisée lors de la création de ton compte GitHub)
<ul>
<li><code>git config --global user.email "[ton adresse mail]"</code></li>
</ul>
</li>
<li>Colorisation des lignes (pas obligatoire mais pratique)
<ul>
<li><code>git config --global color.ui auto</code></li>
</ul>
</li>
</ol>
<h2 id="2-méthodes-pour-cloner-les-dépôts"><a class="header" href="#2-méthodes-pour-cloner-les-dépôts">2 méthodes pour <code>clone</code>r les dépôts</a></h2>
<h3 id="méthode-simple-avec-https-dépréciée"><a class="header" href="#méthode-simple-avec-https-dépréciée">Méthode simple avec HTTPS (dépréciée)</a></h3>
<p>Le clonage en HTTPS est le plus simple et le plus couramment utilisé. Il ne demande que le lien vers le dépôt pour le cloner, et lorsqu'une authentification est requise (clone d'un dépôt privé, push, ...) il faut entrer son identifiant du serveur git (dans notre cas, <a href="https://github.com">github.com</a>) ainsi que son mot de passe.</p>
<p>Voici comment récupérer le code de la partie <code>info</code> :</p>
<pre><code class="language-bash">git clone https://&lt;ton_login_github&gt;@github.com/ClubRobotInsat/info.git
cd info
</code></pre>
<h3 id="méthode-alternative-avec-ssh-recommandée"><a class="header" href="#méthode-alternative-avec-ssh-recommandée">Méthode alternative avec SSH (recommandée)</a></h3>
<p><a href="https://github.com">github.com</a> propose une autre fonctionnalité accéder au serveur par <a href="https://fr.wikipedia.org/wiki/Secure_Shell">SSH</a>. La mise en place de cette méthode est un peu plus longue que le simple protocole HTTPS, mais ça te permettra de t'affranchir de devoir entrer ton mot de passe et ton identifiant à chaque intéraction avec le serveur.</p>
<p>Je te laisse suivre les <a href="https://help.github.com/articles/connecting-to-github-with-ssh/">instructions détaillées</a> pour ajouter la clef SSH sur github.</p>
<p>Enfin, voici comment récupérer un dépôt :</p>
<pre><code class="language-bash">git clone git@github.com:ClubRobotInsat/info.git
cd info
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dual-boot"><a class="header" href="#dual-boot">Dual Boot</a></h1>
<p>Tu as probablement un ordinateur sous Windows. Cependant, développer sous ce système d'exploitation est parfois compliqué donc on utilise principalement des systèmes Linux au club.</p>
<p>Tu as différentes manières d'utiliser Linux :</p>
<ul>
<li>Utiliser <a href="https://docs.microsoft.com/fr-fr/windows/wsl/install-win10">WSL</a>, un sous-système Linux pour Windows (cependant, il n'est pas possible d'utiliser l'interface graphique)</li>
<li>Utiliser <a href="https://www.virtualbox.org/">VirtualBox</a>, une machine virtuelle pour exécuter Linux à l'intérieur de Windows (cependant, ton ordinateur va devoir exécuter deux systèmes d'exploitation en même temps donc il y aura des pertes de performance)</li>
<li>Installer un dual boot, c'est à dire qu'au démarrage de ton ordinateur, soit Windows soit Linux va être lancé, donc les performances de chaque OS vont être maximales mais ton disque dur aura une partie attribuée à Windows et une autre à Linux.</li>
</ul>
<h2 id="préliminaires-sous-windows"><a class="header" href="#préliminaires-sous-windows">Préliminaires sous Windows</a></h2>
<p>Avant tout, il faut faire quelques réglages sous Windows pour permettre l'installation d'un nouveau système d'expoitation (Windows n'aime pas trop partager un ordinateur). Pense aussi à sauvegarder toutes les données importantes ailleurs que sur ton PC. Je n'ai jamais eu de problème avec une installation de Linux, mais comme d'habitude, quand on joue avec les partitions de son disque dur, on prend des précautions (panne de courant/batterie pendant une étape critique par exemple).</p>
<ul>
<li><strong>Désactiver la mise en veille prolongée :</strong> par défaut, Windows ne s'éteint pas quand on le lui dit mais rentre en veille prolongée. Ceci est totalement inutile depuis qu'il y a des disques SSD, et ça empèche de démarrer sous un autre OS
<ul>
<li>ouvrir un terminal avec les droits administrateur (clic droit sur le logo windows, shell)</li>
<li>entrer la commande <code>powercfg -h off</code></li>
</ul>
</li>
<li><strong>Partitionner le disque dur :</strong> afin d'éviter tout problème de partionnement à cause de la fragmentation Windows, il vaut mieux utiliser directement les outils de Windows :
<ul>
<li>appuyer sur <code>Windows + R</code></li>
<li>saisir <code>diskmgmt.msc</code></li>
<li>clic droit sur le volume à partitionner (<em>Disque 0</em>) et sélectionner <code>Réduire le volume</code></li>
<li>choisir la taille de la partition désirée (Ubuntu demande 15Go minimum et recommande 25Go ; si tu as de la place tu peux faire une nouvelle partition à <code>40Go</code> pour être large)</li>
</ul>
</li>
</ul>
<p>Ton disque dur a maintenant un espace inutilisé, il est temps de l'utiliser !</p>
<h2 id="choix-du-système-linux"><a class="header" href="#choix-du-système-linux">Choix du système Linux</a></h2>
<p>Il te faut à présent choisir quel nouveau système d'exploitation utiliser. <strong>Linux</strong> est un <a href="https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg">univers très vaste</a>, que l'on peut sommairement classer :</p>
<ul>
<li>les systèmes basés sur les fichiers <code>.rpm</code>
<ul>
<li>CentOS</li>
<li>Fedora</li>
<li>openSUSE</li>
</ul>
</li>
<li>les systèmes dérivant de <code>Debian</code>
<ul>
<li><strong>Ubuntu</strong></li>
<li>Kali Linux</li>
</ul>
</li>
<li>les systèmes basés sur le <em>packet manager</em> <code>pacman</code>
<ul>
<li>Arch Linux</li>
<li><strong>Manjaro</strong></li>
</ul>
</li>
</ul>
<p>Tu peux demander des conseils aux membres si tu ne sais pas quel OS prendre, ils pourront même t'en faire essayer plusieurs !</p>
<h3 id="ubuntu-2204"><a class="header" href="#ubuntu-2204">Ubuntu 22.04</a></h3>
<p>Si tu n'as aucune idée de quel système choisir, je te conseille <a href="https://www.ubuntu.com/download/desktop">Ubuntu 22</a>, un système communautaire LTS (<em>Long Term Supported</em>) qui est très simple à prendre en main et pour laquelle les nombreux forums répondent à toutes tes questions.</p>
<p>Pour l'installer, il te suffit de <a href="https://www.ubuntu.com/download/desktop/thank-you?country=US&amp;version=22.04.1&amp;architecture=amd64">télécharger l'ISO</a> et la mettre sur une clef USB.</p>
<p><strong>! Attention !</strong>
Sauvegarde toutes les données sur ta clé USB avant de continuer ! Ta clef sera effacée par la suite (mais tu pourras la réinitialiser après avoir installé Linux, puis remettre tes données dessus ensuite).</p>
<p>Par "mettre sur une clef USB", on entend "flasher une image disque", mais c'est un terme barbare. Ici il ne te sera expliqué que comment faire.
Le moyen le plus simple est d'utiliser <a href="https://etcher.io/">Etcher</a>. C'est un logiciel open source et compatible sur Windows, Mac et Linux. Sa grande qualité est d'être <strong>tres</strong> simple à utiliser.</p>
<p>Une fois installé et lancé, il n'y a littéralement que quatre clics à faire :</p>
<ul>
<li>"Select Image" t'invite a choisir l'ISO que tu as déjà téléchargé.</li>
<li>"Select Drive" te demande de choisir le disque (clef USB dans notre cas) à flasher. C'est a dire qu'il sera <strong>formatté</strong> ( ! toutes les données dessus seront perdues !) puis que l'ISO y sera correctement installé. Cette étape requiert de savoir ce que l'on fait : il faut être <strong>absolument</strong> certain que le nom et la capacité du disque choisi correspondent à ta clef USB, et <strong>surtout pas à ton disque dur</strong>. Normalement Etcher est bien fait, et refuse de continuer si choisit un disque à ne pas toucher, mais il vaut mieux être trop prudent.</li>
<li>"Flash!" lance l'opération et raconte ce qu'il fait à ta clef au fur et à mesure.</li>
</ul>
<p>Si tout c'est bien passé, ta "Live-USB" est prête à l'emploi. La suite dépend de ton ordinateur et de la distribution que tu veux installer.</p>
<h2 id="installation-sur-ton-ordinateur-dun-dual-boot"><a class="header" href="#installation-sur-ton-ordinateur-dun-dual-boot">Installation sur ton ordinateur d'un dual boot</a></h2>
<p>À présent que tu es muni.e d'une clef bootable, tu peux la brancher sur ton ordinateur, appuyer sur la touche pour aller dans le BIOS (ça dépend du constructeur mais tu as de bonnes chances d'y parvenir en spammant <code>Échap</code>, <code>F2</code>, <code>F9</code> ou <code>F11</code>) puis modifier quelques paramètres :</p>
<ul>
<li>Désactive le <code>UEFI Secure Boot</code></li>
<li>Désactive le <code>Fast Start-Up</code></li>
<li>Change l'ordre de priorité pour booter afin de lancer ta clef USB en première</li>
</ul>
<p>Si tu as le moindre problème je te conseille d'aller voir un membre du club, mais si ton écran affiche des choses en relation avec Linux et non pas l'écran de démarrage de Windows c'est gagné !</p>
<p>Tu peux choisir de tester l'OS ou alors de l'installer directement. L'interface devrait être assez explicite ; il va juste te falloir réaliser une dernière manip sur la page des disques.</p>
<p>Pour être sûr.e que tout se passe bien, choisis <code>Something else</code> lorsqu'on te demande où installer le système Linux. Ensuite, dans l'espace libre, tu peux attribuer 2Go à une mémoire de type <code>swap</code> (ce qui permets de soulager la RAM si tu lances des applications qui consomment trop). Tu peux attribuer le reste de l'espace libre pour Linux avec <code>type: ext4</code> et <code>mount point: /</code> en formatant l'espace pour éviter tout problème ultérieur.</p>
<p>Finalise l'installation et redémarre ; si tu arrives sur une interface pour choisir entre Linux et Windows (c'est le <code>Grub 2</code>) tout marche comme il faut !!</p>
<h2 id="setup-de-linux"><a class="header" href="#setup-de-linux">Setup de Linux</a></h2>
<p>La première chose à faire est de mettre à jour ton système.</p>
<ul>
<li><strong>ArchLinux :</strong> <code>sudo pacman -Suy</code></li>
<li><strong>Debian :</strong> <code>sudo apt update &amp;&amp; sudo apt upgrade</code></li>
</ul>
<h3 id="installation-basique"><a class="header" href="#installation-basique">Installation basique</a></h3>
<p>Installons les paquets de base nécéssaire pour faire fonctionner les différents outils du club. Ouvre un terminal, et entres :</p>
<pre><code class="language-bash">sudo apt install git curl wget ntfs-3g python3 gcc gdb jetbrains-toolbox
</code></pre>
<p>Les paquets installés sont les suivants:</p>
<ul>
<li><code>git</code> : un gestionnaire de version, qui permet de gérer les différentes versions d'un projet</li>
<li><code>curl</code> : un outil pour télécharger des fichiers depuis un terminal</li>
<li><code>wget</code> : un outil pour télécharger des fichiers depuis un terminal</li>
<li><code>ntfs-3g</code> : un outil pour lire et écrire sur des partitions NTFS (celles de Windows)</li>
<li><code>python3</code> : un langage de programmation</li>
<li><code>gcc</code> : un compilateur pour le langage C</li>
<li><code>gdb</code> : un débugger pour le langage C</li>
<li><code>jetbrains-toolbox</code> : un outil pour installer les IDE de JetBrains</li>
</ul>
<p>Pour installer Rust:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide"><a class="header" href="#ide">IDE</a></h1>
<p><em>Cette page s'adresse à la fois aux infos et aux élecs soft.</em></p>
<p>Comme tu as pu le constater, on a beaucoup de code au club. Pour coder facilement, il existe des outils qui nous facilitent la vie : les <a href="https://fr.wikipedia.org/wiki/Environnement_de_d%C3%A9veloppement">environnements de dévelopement</a>, ou encore des IDE.</p>
<p>Dans ce guide, nous installerons deux IDE:</p>
<ul>
<li>IntelliJ</li>
<li>STM32CubeIDE</li>
</ul>
<p>Vous pouvez bien sûr utiliser un autre IDE si vous le souhaitez, mais nous ne pourrons peut-être pas vous aider si vous rencontrez des problèmes. On recommande donc d'utiliser les IDEs que nous utilisons au club. Sinon VSCode est un bon choix.</p>
<p>Notre choix se porte dans un premier temps sur IntelliJ IDEA qui est développé par JetBrains. Il s'agit d'un IDE à la fois flexible, simple d'utilisation, multiplateforme et qui permet d'utiliser tous les langages que l'on utilise au club.</p>
<p>Nous utilisons STM32CubeIDE pour la partie microcontroleur. Il s'agit d'un IDE développé par STMicroelectronics qui permet de programmer les microcontroleurs de la famille STM32. Il facilite les configurations des périphériques et permet de générer du code à partir de ces configurations.</p>
<p>Ces IDE sont normalement payants, mais une version d'éducation (licence valide 1 an, renouvelable tant que l'on est étudiant) est disponible.</p>
<h2 id="téléchargement-de-intellij-idea"><a class="header" href="#téléchargement-de-intellij-idea">Téléchargement de IntelliJ IDEA</a></h2>
<p>Pour commencer, il faut :</p>
<ol>
<li>Se rendre sur la page de la <a href="https://www.jetbrains.com/toolbox/app/?fromMenu"><strong>Toolbox App</strong></a> et télécharger la dernière version.</li>
<li>Pendant le téléchargement, aller sur la page de <a href="https://www.jetbrains.com/shop/eform/students">jetbrains.com</a> pour demander une licence éducation. L'adresse mail à fournir est celle de l'INSA (<em>&lt;nom&gt;@etud.insa-toulouse.fr</em>) pour que JetBrains accepte de délivrer la licence.</li>
<li>Va voir ta boîte mail, un message contenant un lien de confirmation est arrivé : confirme ton adresse mail</li>
<li>Tu reçois enfin un autre mail avec les infos de la licence, qu'il faudra saisir dans IntelliJ IDEA</li>
<li>Tu peux maintenant lancer la Toolbox App et installer IntelliJ IDEA</li>
</ol>
<h2 id="téléchargement-de-stm32cubeide"><a class="header" href="#téléchargement-de-stm32cubeide">Téléchargement de STM32CubeIDE</a></h2>
<p>Pour commencer, il faut :</p>
<ol>
<li>Se rendre sur la page de <a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE</a> et télécharger la dernière version.</li>
<li>Il est possible que tu doives créer un compte STMicroelectronics pour pouvoir télécharger le logiciel.</li>
</ol>
<p><em><strong>Pour les utilisateurs d'un Ubuntu standard :</strong></em> Lorsque CLion est en cours d'exécution, son icône est affiché dans la barre des tâches à gauche. Pour le lancer plus rapidement, il te suffit de faire un click droit sur l'icône -&gt; 'Lock to Launcher'</p>
<p>Si jamais l'IDE se lance, tu viens d'installer avec succès CLion ! Sinon je t'encourage à venir montrer le message d'erreur aux gens du club.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organisation"><a class="header" href="#organisation">Organisation</a></h1>
<p>Au club robot, on a beaucoup de choses à faire, et on est beaucoup à les faire. Pour que tout se passe bien, il faut une bonne organisation. Cette section est là pour t'aider à t'organiser au mieux.</p>
<h2 id="les-outils"><a class="header" href="#les-outils">Les outils</a></h2>
<h3 id="discord"><a class="header" href="#discord">Discord</a></h3>
<p>Discord est un logiciel de communication textuelle et vocale. Il est utilisé par le club pour communiquer entre nous. Il est possible de l'utiliser dans un navigateur web, mais il est recommandé de télécharger l'application.</p>
<p>Pour rejoindre le serveur du club, il faut cliquer sur ce lien : <a href="https://discord.gg/3t6WRAXk4G">https://discord.gg/3t6WRAXk4G</a>.</p>
<h3 id="notion-github--documentation-du-club"><a class="header" href="#notion-github--documentation-du-club"><del>Notion</del> GitHub / <a href="https://clubrobotinsat.github.io/">Documentation du club</a></a></h3>
<p>Pendant quelques années, nous avons utilisé Notion pour organiser le club. Cependant, nous avons décidé de passer à GitHub pour plusieurs raisons :</p>
<ul>
<li>Notion est payant pour les équipes de plus de 10 personnes. Cela nous coutait trop cher.</li>
<li>Notion est un outil de prise de note, pas un outil de gestion de projet.</li>
<li>On avait pas de bonne structure de données dans Notion, ce qui rendait la navigation difficile.</li>
<li>GitHub permet de gérer les projets directement avec les fichiers du projet.</li>
<li>La documentation est plus facile à maintenir sur GitHub et est hiérarchisée.</li>
</ul>
<h2 id="les-projets"><a class="header" href="#les-projets">Les projets</a></h2>
<p>Chaque année, le club robot participe à la coupe de France de robotique. Pour cela, il faut construire un robot. Pour construire un robot, il faut faire des projets. Les projets sont donc les différentes parties du robot.</p>
<p>Au club, vous pouvez retrouver d'autres projets, tels que :</p>
<ul>
<li>VEX Robotics</li>
<li>Robot serveur de boisson</li>
</ul>
<h3 id="la-coupe-de-france-de-robotique"><a class="header" href="#la-coupe-de-france-de-robotique">La coupe de France de robotique</a></h3>
<p>La coupe de France de robotique est une compétition de robotique qui a lieu chaque année à la fin du mois de mai. Elle se déroule à la Roche-sur-Yon, en Vendée. Elle est organisée par l'association Planète Sciences.</p>
<p>Chaque année, un nouveau thème est choisi. Le thème de cette année est "Farming Mars". Le but est de construire un robot qui puisse remplir les missions du thème.</p>
<p>Pour plus d'informations, vous pouvez aller sur le site de la coupe de France de robotique : <a href="https://www.coupederobotique.fr/">https://www.coupederobotique.fr/</a>.</p>
<h2 id="les-formations-du-club"><a class="header" href="#les-formations-du-club">Les formations du club</a></h2>
<p>Chaque année, le club organise des formations pour les nouveaux membres. Ces formations ont pour but de vous apprendre à utiliser les outils du club, et à vous apprendre les bases de la robotique.</p>
<p>Les différentes formations sont :</p>
<ul>
<li>La formation électronique: Kicad</li>
<li>La formation informatique: C, Git, Linux</li>
<li>La formation méca: Creo Parametric</li>
</ul>
<h2 id="les-règles-du-club"><a class="header" href="#les-règles-du-club">Les règles du club</a></h2>
<p>Au club, il y a quelques règles à respecter. Ces règles sont là pour que tout le monde puisse travailler dans de bonnes conditions.</p>
<h3 id="les-règles-de-rangement"><a class="header" href="#les-règles-de-rangement">Les règles de rangement</a></h3>
<p>Au club, il y a beaucoup de matériel. Pour que tout le monde puisse s'y retrouver, il faut que tout soit rangé à sa place. Il y a donc des règles de rangement à respecter.</p>
<p>La <strong>première règle est de ranger les choses à leur place</strong>. Si vous ne savez pas où ranger quelque chose, demandez à un membre du club.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gestion-de-projet"><a class="header" href="#gestion-de-projet">Gestion de projet</a></h1>
<p>Pour gérer un projet, il faut utiliser des outils de gestion de projet. Au club, nous utilisons <a href="https://github.com/">GitHub</a>. GitHub est un site web qui permet d'héberger des projets. Il permet de gérer les versions des fichiers, de gérer les tâches à faire, et de gérer les personnes qui travaillent sur le projet.</p>
<p>Avoir une quelqu'un qui s'occupe de la gestion de projet est très important.</p>
<h2 id="quelques-conseils"><a class="header" href="#quelques-conseils">Quelques conseils</a></h2>
<p>C'est bien de planifier l'année à la rentrée et de faire un rétroplanning. Cependant, il faut savoir que les choses ne se passent jamais comme prévu. Il faut donc être flexible et savoir s'adapter.</p>
<blockquote>
<p>On a toujours des problèmes d'électronique.</p>
</blockquote>
<blockquote>
<p>Un court-circuit est vite arrivé.</p>
</blockquote>
<h2 id="les-pôles"><a class="header" href="#les-pôles">Les pôles</a></h2>
<p>Afin de faciliter la gestion du projet, on a trois pôles: Info, Elec, Méca. Si possible avoir un responsable de chaque pôle. Cela permet de répartir la charge de travail.</p>
<h2 id="séparer-en-modules"><a class="header" href="#séparer-en-modules">Séparer en modules</a></h2>
<p>Il faut séparer le projet en modules. Cela permet de répartir la charge de travail, et de pouvoir travailler en parallèle.
On peut également réutiliser des modules d'une année sur l'autre.</p>
<h2 id="les-tâches"><a class="header" href="#les-tâches">Les tâches</a></h2>
<p>Pour gérer les tâches, on utilise des <a href="https://docs.github.com/en/github/managing-your-work-on-github/about-issues">issues</a>. Une issue est une tâche à faire. Elle peut être assignée à une personne, et peut être liée à d'autres issues. On peut également ajouter des labels pour catégoriser les issues.</p>
<p>Il faut faire attention à ne pas avoir trop d'issues ouvertes en même temps. Il faut donc bien prioriser les issues.</p>
<h2 id="les-milestones"><a class="header" href="#les-milestones">Les milestones</a></h2>
<p>Les <a href="https://docs.github.com/en/github/managing-your-work-on-github/about-milestones">milestones</a> permettent de regrouper des issues. On peut leur donner une date limite. Cela permet de planifier les tâches à faire.</p>
<p>En général cela correspond à des modules du robot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gestion-de-léquipe"><a class="header" href="#gestion-de-léquipe">Gestion de l'équipe</a></h1>
<p>Il est important de bien gérer l'équipe. Cela permet de gagner du temps, et de ne pas faire d'erreurs.</p>
<p>Il faut réguliérement demander aux membres de l'équipe comment ils vont, et s'ils ont besoin d'aide. Il faut également leur demander ce qu'ils ont fait, et ce qu'ils vont faire.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gestion-de-la-communication"><a class="header" href="#gestion-de-la-communication">Gestion de la communication</a></h1>
<p>On utilise <a href="https://discord.com/">Discord</a> pour communiquer. C'est un logiciel de communication par texte et par audio. Il permet de créer des salons de discussion, et de créer des groupes de discussion. Il permet également de partager des fichiers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gestion-de-la-documentation"><a class="header" href="#gestion-de-la-documentation">Gestion de la documentation</a></h1>
<p>Un des plus gros problèmes du club est la documentation. Il faut donc faire attention à bien documenter le projet. Cela permet de gagner du temps pour les années suivantes, et de pouvoir réutiliser des modules d'une année sur l'autre.</p>
<p>Actuellement, on ne sait pas exactement ce qu'on connait et ce qu'on ne connait pas. Il faut donc faire un inventaire de ce qu'on connait. On a énormement de documents, mais ils sont éparpillés un peu partout. Il faut donc les rassembler et les organiser.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="règles-coupe-de-france-2024"><a class="header" href="#règles-coupe-de-france-2024">Règles Coupe de France 2024</a></h1>
<h2 id="sommaire"><a class="header" href="#sommaire">Sommaire</a></h2>
<p>Lien vers les règles: <a href="https://www.coupederobotique.fr/edition-2024/le-concours/reglement-2024/">https://www.coupederobotique.fr/edition-2024/le-concours/reglement-2024/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-du-projet"><a class="header" href="#architecture-du-projet">Architecture du projet</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Ce document a pour but de décrire l'architecture du projet. Il est destiné aux personnes qui souhaitent comprendre comment le projet est organisé, et comment il fonctionne.</p>
<h2 id="conception-mécanique"><a class="header" href="#conception-mécanique">Conception mécanique</a></h2>
<h3 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h3>
<h3 id="base-roulante"><a class="header" href="#base-roulante">Base roulante</a></h3>
<h3 id="conception-modulaire"><a class="header" href="#conception-modulaire">Conception modulaire</a></h3>
<h3 id="bras-robotique"><a class="header" href="#bras-robotique">Bras robotique</a></h3>
<h2 id="conception-électronique"><a class="header" href="#conception-électronique">Conception électronique</a></h2>
<h3 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h3>
<h3 id="alimentation"><a class="header" href="#alimentation">Alimentation</a></h3>
<h3 id="carte-de-contrôle"><a class="header" href="#carte-de-contrôle">Carte de contrôle</a></h3>
<h3 id="capteurs"><a class="header" href="#capteurs">Capteurs</a></h3>
<h3 id="actionneurs"><a class="header" href="#actionneurs">Actionneurs</a></h3>
<h2 id="conception-informatique"><a class="header" href="#conception-informatique">Conception informatique</a></h2>
<h3 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h3>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<h3 id="communication"><a class="header" href="#communication">Communication</a></h3>
<h3 id="vision"><a class="header" href="#vision">Vision</a></h3>
<h3 id="stratégie"><a class="header" href="#stratégie">Stratégie</a></h3>
<h3 id="intelligence-artificielle"><a class="header" href="#intelligence-artificielle">Intelligence artificielle</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="informatique"><a class="header" href="#informatique">Informatique</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mise-en-place"><a class="header" href="#mise-en-place">Mise en place</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connexion-à-la-raspberry"><a class="header" href="#connexion-à-la-raspberry">Connexion à la Raspberry</a></h1>
<h1 id="raspberry-pi"><a class="header" href="#raspberry-pi">Raspberry Pi</a></h1>
<p>La Raspberry Pi a maintenant un serveur DHCP fonctionnel</p>
<h2 id="quoi-que-cest-le-dhcp"><a class="header" href="#quoi-que-cest-le-dhcp">Quoi que c'est le DHCP?</a></h2>
<p>C'est le truc qui vous permet d'avoir automatiquement une @IP sans jamais aller toucher aux paramètres de votre pc ou de la raspi, et donc d'avoir une connectivité qui marche sans rien faire, donc c'est cool</p>
<h2 id="comment-que-je-men-sers"><a class="header" href="#comment-que-je-men-sers">Comment que je m'en sers?</a></h2>
<p>Il suffit de brancher votre pc au port ethernet de la raspi. Si ladite raspi est allumée (branchée), vous aurez une adresse IP sur votre ordi (mais vous n'avez pas besoin de vous en soucier), et surtout, vous pourrez vous connecter en ssh à la raspi</p>
<h2 id="ok-comment-je-me-connecte-en-ssh"><a class="header" href="#ok-comment-je-me-connecte-en-ssh">OK, comment je me connecte en ssh?</a></h2>
<p><code>ssh pi@192.168.169.1</code></p>
<h2 id="aude-ça-marche-pas"><a class="header" href="#aude-ça-marche-pas">Aude, ça marche pas!</a></h2>
<ul>
<li>est-ce que les LEDs du port ethernet de la raspi et du PC sont allumées?</li>
<li>sinon, rebrancher le câble comme il faut, vérifier l'alim des deux dispositifs</li>
<li>est-ce que mon PC a bien reçu une adresse IP sur le réseau 192.168.169.0/24? <code>ifconfig</code></li>
<li>sinon, sur la raspi, vérifier le statut du serveur DHCP <code>systemctl status isc-dhcp-server</code></li>
</ul>
<h3 id="jarrive-à-ping-la-raspi-mais-pas-à-ssh"><a class="header" href="#jarrive-à-ping-la-raspi-mais-pas-à-ssh">J'arrive à ping la raspi, mais pas à SSH</a></h3>
<ul>
<li>probablement un problème de firewall, bonne chance jeune padawan (cherche comment utiliser le firewall ufw sur internet)</li>
</ul>
<h2 id="je-peux-te-contacter-si-ça-marche-pas"><a class="header" href="#je-peux-te-contacter-si-ça-marche-pas">Je peux te contacter si ça marche pas?</a></h2>
<p>Oui bien sûr ^^</p>
<h2 id="connexion-en-ssh"><a class="header" href="#connexion-en-ssh">Connexion en ssh</a></h2>
<blockquote>
<p>user : pi mdp : robotcdf</p>
</blockquote>
<p>pour se connecter en ssh à la raspi :</p>
<ul>
<li>en wifi : vérifier qu’on est sur le même réseau (ex : partage de connexion, réseau IoT si j’arrive à chopper le mdp)
<ul>
<li>ip_address généralement en 192.168.X.X ou 10.X.X.X (privée)</li>
</ul>
</li>
<li>en ethernet : connecter le pc et la raspi avec un câble ethernet (si besoin adaptateur usb)</li>
</ul>
<p>Si les led des ports ethernet ne s’allument pas, tout reboot</p>
<ol>
<li>
<p>vérifie qu’il y a une ipv6 (commençant pas fe80::) sur l’interface de la raspi et de ton pc (elles ont sûrement des noms bizarres commençant par en) : ça veut dire que la connexion est possible</p>
<ul>
<li>si pas d’ipv6, débranche et rebranche, vérifie toutes les interfaces</li>
</ul>
</li>
<li>
<p>essaie de ping la raspi depuis ton pc (facultatif : ping ton pc depuis la raspi, mais les windows ne répondront pas dans tous les cas)</p>
<ul>
<li>
<p>si ton pc a une ipv4  en 169.254.X.X (link-local)</p>
<ul>
<li>toutes les fois où j’ai testé la raspi avait la 169.254.217.11/16</li>
<li>celle avec le scotch a été mise en static à 169.254.0.1/16</li>
</ul>
<p>⇒ rentre la commande suivante sur ton pc</p>
<pre><code class="language-bash">ping ipv4_raspi # si le ping ne passe pas, vérifie la connectivité 
# et/ou essaie en ipv6 
# tu peux aussi entrer la commande 
route # pour vérifier la table de routage si tu es expérimenté 
</code></pre>
</li>
<li>
<p>si ton pc n’a pas d’ipv4 sur l’interface</p>
<p>⇒ ping la raspi en ipv6</p>
<pre><code class="language-bash">ping -6 ipv6_raspi%interface
</code></pre>
</li>
</ul>
</li>
<li>
<p>se connecter en ssh</p>
<ul>
<li>ipv4</li>
</ul>
<pre><code class="language-bash">ssh pi@ipv4_raspi
</code></pre>
<ul>
<li>ipv6</li>
</ul>
<pre><code class="language-bash">ssh pi@ipv6_raspi%interface
</code></pre>
</li>
</ol>
<p>Tu peux utiliser un connecteur sur ton ide (par exemple sur vscode) une fois que le ssh fonctionne</p>
<p>(PC Aude : Adaptador de Ethernet Ethernet: 169.254.239.119)</p>
<p><img src="informatique/mise_en_place/../../images/info/Raspberry.png" alt="Image de la Raspberry Pi" /></p>
<h2 id="install-opencv"><a class="header" href="#install-opencv">Install OpenCV</a></h2>
<p><a href="https://linuxize.com/post/how-to-install-opencv-on-raspberry-pi/">How to Install OpenCV on Raspberry Pi 3</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide-1"><a class="header" href="#ide-1">IDE</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="répertoire-de-travail"><a class="header" href="#répertoire-de-travail">Répertoire de travail</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-start-the-development-container-for--ros2-development"><a class="header" href="#how-to-start-the-development-container-for--ros2-development">How to start the development container for 🤖 ROS2 development</a></h1>
<ol>
<li>
<p>🛠 Install VSCode or a JetBrainsIDE(Clion or Pycharm recommended). For JetBrains you have free student licences.
I personally recommend a JetBrians IDE over VSCode.</p>
</li>
<li>
<p>🐳 Install <a href="https://docs.docker.com/engine/install/">docker engine</a>.
In linux don't forget to <a href="https://docs.docker.com/engine/install/linux-postinstall/">add yourself to the docker group</a>:</p>
<ol>
<li><code>sudo groupadd docker</code></li>
<li><code>sudo usermod -aG docker $USER</code></li>
<li><code>newgrp docker</code></li>
</ol>
</li>
<li>
<p>📚 git clone https://github.com/ClubRobotInsat/Info</p>
</li>
<li>
<p>If you're on windows you need to comment
the <code>"source=/tmp/.X11-unix,target=/tmp/.X11-unix,type=bind,consistency=cached"</code>
line in the <code>.devcontainer/devcontainer.json</code> file (comment is &lt;&lt; // &gt;&gt; as in C) at the end of the file.
This line allows you to use GUI apps from the container, which doesn't work on windows (no X11 on windows by default).</p>
</li>
<li>
<p>Follow the instruction based on your IDE</p>
</li>
</ol>
<h1 id="clion--pycharm--other-jetbrains"><a class="header" href="#clion--pycharm--other-jetbrains">CLion / Pycharm / Other JetBrains</a></h1>
<ol>
<li>Open the project folder</li>
<li>Open the <code>.devcontainer/devcontainer.json</code> file.</li>
<li>CLick on the blue cube to create a new dev container, the simplest option is to choose:
<code>Create Dev Container and mount sources</code> this will make the dev directory inside the container and the
"real" folder to be synced. This might have performance issues on windows, so if you know what you're doing
it might be worth to take a look at the clone option if you're on windows.
<img src="informatique/mise_en_place/../../images/info/Clion_dev_container.png" alt="Clion_dev_container.png" /></li>
</ol>
<p>Clion should build the container, it might take some time, good internet can help.
Once its finished press continue:
<img src="informatique/mise_en_place/../../images/info/Clion_build_dev-container.png" alt="continue" /></p>
<p>Again, it might take some time.</p>
<p>Once finished, your IDE should open, you're now in a virtual environment
with the right version of everything and ros2 installed!</p>
<p>When closing, chose close and stop to avoid performance and ressource
allocation(mostly ports) issues in your PC.</p>
<h1 id="vscode"><a class="header" href="#vscode">VSCode</a></h1>
<ol>
<li>Open the project folder</li>
<li>press ctr+shift+p</li>
<li>Run: <code>Dev Containers: Rebuild and Reopen in Container</code>. It might take some time, good internet can help</li>
</ol>
<h2 id="windows-docker-engine-install-details"><a class="header" href="#windows-docker-engine-install-details">Windows Docker engine install details</a></h2>
<p>Use the recommended settings, you can skip the login and the survey.</p>
<h1 id="why-and-how"><a class="header" href="#why-and-how">Why and how?</a></h1>
<p>For this tutorial you need to be familiar with the concept of docker container, container ports, and container volumes.
Look up a tutorial if you don't know what those are.</p>
<p>This process creates a container and makes your IDE connect to it as its "host" machine.
This enables people to work with the same exact environment independently of the underlying machine.
SO, basically we are creating a "light VM" so that everyone can work with ROS2 as the only officially
supported OS for ros2 humble (the latest LTS version when writing this doc) is ubuntu 22.04, which is already 2y old
and just getting older.
At the same time we are opening a port so that the IDE can connect though it (3000) and another one for ssh connexion
if needed (2222).
We also mout a volume from our repository into the dev container so that we can have all our files up to date all
the time.
This volume binding, goes through WSL on windows, which makes two "emulation" layers of the fyle system, docker and wls.
THis makes the fyle system really slow, so, cloning the repo inside the container might be wise if
performance is an issue on someone's PC.</p>
<p>The launch config for the container is specified int he <code>.devcontainer/devcontainer.json</code> file, replacing
the usual docker-compose.yml or the docker run command. So any container config should be modified here.</p>
<p>All the image config is in the Dockerfile as usual. IF the underlying image needs to be modified its here.</p>
<h1 id="debugging-the-dev-environment"><a class="header" href="#debugging-the-dev-environment">Debugging the dev-environment</a></h1>
<h3 id="port-already-in-use"><a class="header" href="#port-already-in-use">Port already in use</a></h3>
<ul>
<li><code>docker ps</code></li>
<li>This will show a list with all the running containers in your PC, you cant have two containers bind to
the same port, so if there is one already running it must be stopped. This happens when the IDE doesn't close
the dev-container when closed. It's mostly an issue with VSCode.</li>
<li>Take the "CONTAINER ID" and run <code>docker stop ${CONTAINER ID}</code></li>
<li>Try opening the dev container again, if it doesn't work there is another process using the port,
the simplest way to deal with it is rebooting the machine or changing the host port (the one on the left of the : )
in the <code>.devcontainer/devcontainer.json</code> file.</li>
</ul>
<h3 id="cant-bind-a-volume"><a class="header" href="#cant-bind-a-volume">Cant bind a volume</a></h3>
<p>The most usual cause is that the directory doest exist,
have you forgotten to comment the x11 line in the <code>.devcontainer/devcontainer.json</code> file?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-du-code"><a class="header" href="#architecture-du-code">Architecture du code</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communication-avec-le-hardware-can-bus"><a class="header" href="#communication-avec-le-hardware-can-bus">Communication avec le hardware: CAN Bus</a></h1>
<p>La communication avec le hardware est essentielle pour assurer le bon fonctionnement du robot. Cette section se concentre sur le bus CAN, un choix stratégique en raison de sa robustesse et de sa rapidité.</p>
<h2 id="quest-ce-que-le-bus-can-"><a class="header" href="#quest-ce-que-le-bus-can-">Qu'est ce que le Bus CAN ?</a></h2>
<p>Le bus CAN (Controller Area Network) est un bus de communication série largement utilisé dans l'industrie. Il offre une communication rapide et fiable avec plusieurs modules simultanément. Pour en savoir plus sur son fonctionnement, consultez ces documents:</p>
<ul>
<li><a href="https://www.ti.com/lit/an/sloa101b/sloa101b.pdf?ts=1633140726383&amp;ref_url=https%3A%2F%2Fwww.google.com%2F">Description générale du fonctionnement</a></li>
<li><a href="https://www.csselectronics.com/pages/can-bus-simple-intro-tutoria">tutoriel explicatif</a>.</li>
</ul>
<h2 id="matériel-utilisé-pour-le-bus-can"><a class="header" href="#matériel-utilisé-pour-le-bus-can">Matériel utilisé pour le bus CAN</a></h2>
<p>CAN Transceiver : Composant intermédiaire pour produire les signaux CANL et CANH et les transporter dans le réseau.</p>
<p>On utilise 2 modèles. On utilise le <strong>MCP2515</strong> et le <strong>MCP2551</strong>.</p>
<p>Datasheets:</p>
<ul>
<li><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/20001667G.pdf">Datasheet MCP2551</a></li>
<li><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/MCP2515-Stand-Alone-CAN-Controller-with-SPI-20001801J.pdf">Datasheet MCP2515</a></li>
</ul>
<h3 id="différence-entre-mcp2515-et-mcp2551"><a class="header" href="#différence-entre-mcp2515-et-mcp2551">Différence entre MCP2515 et MCP2551</a></h3>
<p>Le <strong>MCP2515</strong> est un contrôleur CAN qui permet de communiquer avec le bus CAN via SPI. Il est utilisé pour envoyer et recevoir des messages CAN. Il est connecté à la Raspberry Pi via SPI.</p>
<p>Le <strong>MCP2551</strong> est un transceiver CAN plus simple qui permet de convertir les signaux TX et RX en signaux CANH et CANL. Il est compris dans le MCP2515 mais on l'utilise aussi pour communiquer avec la STM32.</p>
<h2 id="utilisation-du-bus-can"><a class="header" href="#utilisation-du-bus-can">Utilisation du bus CAN</a></h2>
<h3 id="paramètres-dalimentation-du-bus"><a class="header" href="#paramètres-dalimentation-du-bus">Paramètres d'alimentation du bus</a></h3>
<ul>
<li>Alimentation : <strong>5V</strong></li>
<li>Courant : 100mA (en mémoire dans M3)</li>
<li>Ne pas oublier de mettre un bouchon d'impédance (50 OU 120 Ohm) en fin du cable CAN</li>
</ul>
<h3 id="connexion-du-mcp2551-pour-stm32"><a class="header" href="#connexion-du-mcp2551-pour-stm32">Connexion du MCP2551 (Pour STM32)</a></h3>
<p><img src="informatique/../images/info/CAN_BUS_MCP2551_Connexion.png" alt="Connexion MCP2551" /></p>
<p><strong>Réglage du slope-rate</strong> :</p>
<p>Pour changer le slope-rate on change la valeur de R connecter sur RS.</p>
<h3 id="connexion-du-mcp2515-spican---raspberry-pi"><a class="header" href="#connexion-du-mcp2515-spican---raspberry-pi">Connexion du MCP2515 (SPI+CAN -&gt; Raspberry Pi)</a></h3>
<p>Connecter les pins du transceiver SI, SO, SCK, INT et CS comme ci dessous.</p>
<p>:warning: Le VCC doit être sur du <strong>5V</strong> contrairement à ce schéma, ne pas oublier le ground.</p>
<p><img src="informatique/../images/info/CAN_Raspberry_Transreceiver_Connexion.png" alt="Connexion entre Raspberry et transreceiver" /></p>
<p><img src="informatique/../images/info/CAN_Transreceiver_Pinout.png" alt="CAN Transreceiver pinout" /></p>
<p>Fichier <code>/boot/config.txt</code> à mettre pour activer la connexion SPI avec le MCP au moment de boot dans la rpi:</p>
<pre><code># For more options and information see
# http://rptl.io/configtxt
# Some settings may impact device functionality. See link above for details

# Uncomment some or all of these to enable the optional hardware interfaces
#dtparam=i2c_arm=on
#dtparam=i2s=on

dtparam=spi=on

# Enable audio (loads snd_bcm2835)
dtparam=audio=on

# Additional overlays and parameters are documented
# /boot/firmware/overlays/README

# Automatically load overlays for detected cameras
camera_auto_detect=1

# Automatically load overlays for detected DSI displays
display_auto_detect=1

# Automatically load initramfs files, if found
auto_initramfs=1

# Enable DRM VC4 V3D driver
dtoverlay=vc4-kms-v3d
max_framebuffers=2

# Don't have the firmware create an initial video= setting in cmdline.txt.
# Use the kernel's default instead.
disable_fw_kms_setup=1

# Run in 64-bit mode
arm_64bit=1

# Disable compensation for displays with overscan
disable_overscan=1

# Run as fast as firmware / board allows
arm_boost=1

[cm4]
# Enable host mode on the 2711 built-in XHCI USB controller.
# This line should be removed if the legacy DWC2 controller is required
# (e.g. for USB device mode) or if USB support is not required.
otg_mode=1

[all]
dtoverlay=mcp2515-can0,oscillator=16000000,interrupt=25,spimaxfrequency=500000
dtoverlay=spi0-hw-cs

</code></pre>
<h3 id="exemple-de-connexion-entre-deux-stm32"><a class="header" href="#exemple-de-connexion-entre-deux-stm32">Exemple de connexion entre deux STM32</a></h3>
<p>⚠️
Regarder plus en détail la page dédiée à la communication entre STM32 pour plus d'informations.</p>
<p><img src="informatique/../images/info/CAN_BUS_STMs.jpg" alt="Connexion entre deux STM32" /></p>
<h2 id="tutoriel-pour-la-mise-en-place-du-bus-can-sur-la-raspberry-pi"><a class="header" href="#tutoriel-pour-la-mise-en-place-du-bus-can-sur-la-raspberry-pi">Tutoriel pour la mise en place du bus CAN sur la Raspberry Pi</a></h2>
<p><strong>Liste des étapes à suivre</strong>:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Faire le circuit de la figure ci-dessus entre deux STM32</li>
<li><input disabled="" type="checkbox"/>
S'assurer que le bus CAN marche entre les deux STM32</li>
<li><input disabled="" type="checkbox"/>
Connecter le MCP2515 à la Raspberry Pi comme sur la figure ci-dessus</li>
<li><input disabled="" type="checkbox"/>
Installer les paquets nécessaires sur la Raspberry Pi</li>
<li><input disabled="" type="checkbox"/>
Vérifier que l'interface can0 est bien présente au démarrage de la raspi avec <code>ifconfig</code></li>
<li><input disabled="" type="checkbox"/>
Vérifier que la Raspberry Pi reçoit bien les messages envoyés par les STM32 et vice-versa</li>
</ul>
<h3 id="liste-des-potentiels-problèmes"><a class="header" href="#liste-des-potentiels-problèmes">Liste des potentiels problèmes</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Vérifier que le bus CAN est bien alimenté (bouton on/off et branchements…)</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les fils sont bien branchés</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les résistances de terminaison sont bien présentes</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les ground sont bien connectés entre eux</li>
<li><input disabled="" type="checkbox"/>
Vérifier que le montage est correct</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les STM32 sont bien alimentés</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les STM32 sont bien programmés pour envoyer et recevoir des messages CAN</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les signaux TX et RX sont bien connectés aux pins RX et TX des STM32</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les signaux sont bien présents sur le BUS CAN (oscilloscope ou serial analyzer)</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les bonnes données sont envoyées et reçues par les STM32</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les signaux envoyés par les STM32 sont bien reçus par la Raspberry Pi</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les modules SPI et CAN sont bien activés sur la Raspberry Pi</li>
<li><input disabled="" type="checkbox"/>
Vérifier que les paquets nécessaires sont bien installés sur la Raspberry Pi</li>
<li><input disabled="" type="checkbox"/>
Vérifier que l'interface can0 est bien présente au démarrage de la raspi avec <code>ifconfig</code></li>
<li><input disabled="" type="checkbox"/>
Vérifier que la Raspberry Pi reçoit bien les messages envoyés par les STM32 et vice-versa</li>
</ul>
<h2 id="vérification-du-bon-fonctionnement-du-bus-can-sur-la-raspberry-pi"><a class="header" href="#vérification-du-bon-fonctionnement-du-bus-can-sur-la-raspberry-pi">Vérification du bon fonctionnement du bus CAN sur la Raspberry Pi</a></h2>
<h3 id="vérification-de-linterface-can0"><a class="header" href="#vérification-de-linterface-can0">Vérification de l'interface can0:</a></h3>
<ul>
<li>Vérifier que l’interface can0 est bien présente au démarrage de la raspi avec <code>ifconfig</code></li>
<li>On peut aussi vérifier dans les messages de démarrage du kernel que tout s’est bien passé avec <code>dmesg | grep can</code> et <code>dmesg | grep mcp</code></li>
<li>Sinon, redémarrer la raspi <code>sudo reboot</code></li>
</ul>
<h3 id="format-des-messages"><a class="header" href="#format-des-messages">Format des messages</a></h3>
<ul>
<li><code>candump any</code> pour recevoir (en boucle)</li>
<li><code>cansend can0 000#00.00.00.00.00.00.00.00</code> pour envoyer (attention, données en hexa).</li>
</ul>
<h2 id="protocole-de-test-de-liam"><a class="header" href="#protocole-de-test-de-liam">Protocole de test de Liam</a></h2>
<p>Le Bus CAN fonctionne, mais comment le tester?</p>
<p>Tout d'abord, il faut la raspberry pi avec ubuntu ou raspbian installé dessus (soit USB soit carte SD)
Un module qui fait office d'interface CAN est deja connecté à la raspberry pi</p>
<p>J'utilise une alim (celle de mon telephone, le chargeur) pour alimenter la raspberry. Ensuite j'utilise un cable micro HDMI pour afficher le terminal qu'il me faut pour mettre en place le bus CAN</p>
<p>Lorsque le terminal est activé, apres avoir renseigné le login et mdp (pi et robotcdf respectivement), il faut mettre en place l'interface CAN avec la commande suivante :
sudo ip link set can0 up type can bitrate 125000</p>
<p>Le bitrate depend de nous, si on le change il faut s'assurer que les STM32 ont le meme bitrate associé à leurs interfaces CAN.</p>
<p>Lorsque l'interface est UP , on peut brancher CANH et CANL de la raspi a un bus CAN composé de plusieurs STM32.
Nous avons pour l'instant deux cartes , une avec seulement une stm, une autre carte avec une stm et tout ce qu'il faut pour driver les moteurs a courant continu.</p>
<p>Si l'interface n'est pas UP, il faut verifier l'erreur en utilisant la commande dmesg . Dans mon cas, l'erreur etait due aux fils qui étaient de mauvaise qualité et n'interconnectaient pas bien la raspi et le module CAN.</p>
<p>Il est dorenavant possible d'interagir avec le bus CAN en utilisant l'utilitaire can-utils :</p>
<p>On peut lancer par exemple : candump can0 pour observer le traffic sur le Bus CAN.
cansend can0 013#01.01.01.01.01.01.01.01 par exemple pour envoyer des donnees sur le bus CAN
( Dans le cas du code que j'ai ecrit sur la stm32, ceci permet d'ordonner à la STM32 d'activer les moteurs )</p>
<p>Le code sur la STM32 utilise un filtre sur l'ID 013 et verifie le contenu du premier octet de la trame CAN.</p>
<p>En conclusion : Ne pas faire confiance aux breadboards, ni aux fils (jumper wires) qui ne garantissent pas des connexions fiables.
Il faut aussi faire attention quant a la configuration du filtre sur la stm32.
Attention egalement a l'oscillateur utilisé sur la stm32, il faut bien definir l'oscillation sur le bus CAN (Interface FDCAN)</p>
<h2 id="documentation-diverse"><a class="header" href="#documentation-diverse">Documentation diverse</a></h2>
<p>Explorez ces ressources pour une compréhension plus approfondie du bus CAN et de son utilisation.</p>
<ul>
<li>
<p><a href="https://forums.raspberrypi.com/viewtopic.php?t=141052">Guide rapide</a></p>
</li>
<li>
<p><a href="https://www.beyondlogic.org/adding-can-controller-area-network-to-the-raspberry-pi/">Adding CAN to the Raspberry PI</a></p>
</li>
<li>
<p><a href="https://projects-raspberry.com/how-to-connect-raspberry-pi-to-can-bus/">How to connect Raspberry Pi to CAN bus</a></p>
</li>
<li>
<p><a href="https://forums.raspberrypi.com/viewtopic.php?t=311606"> Not able to setup can0. - Raspberry Pi Forums</a></p>
</li>
<li>
<p><a href="https://github.com/raspberrypi/linux/issues/4183">MCP251x failes setup CAN-bus communication with error=110 · Issue #4183 · raspberrypi/linux</a></p>
</li>
</ul>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>Description générale du fonctionnement:  <a href="https://www.ti.com/lit/an/sloa101b/sloa101b.pdf?ts=1633140726383&amp;ref_url=https%253A%252F%252Fwww.google.com%252F">https://www.ti.com/lit/an/sloa101b/sloa101b.pdf?ts=1633140726383&amp;ref_url=https%3A%2F%2Fwww.google.com%2F</a></li>
</ul>
<p>si ça marche pas, vérifier qu’il y a bien deux dispositifs sur le bus</p>
<p><a href="https://www.csselectronics.com/pages/can-bus-simple-intro-tutorial">CAN Bus Explained - A Simple Intro [2022 | The #1 Tutorial]</a></p>
<p><a href="https://github.com/TVAROBOT/STM32">GitHub - TVAROBOT/STM32: CAN bus on STM32F103C8T6 "Blue pill" uVision and CubeMX</a></p>
<p><a href="informatique/../ToDo%20d9dc46c3b25c4135a14d9b95735317f5/Decide%20communication%20protocol%20d89cb22bfdd24c7198646a51b15ae670/CAN%20Bus%20b5e77c9cfda440c08deaae066f118232.html">CAN Bus</a></p>
<p>datasheet : <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/MCP2515-Stand-Alone-CAN-Controller-with-SPI-20001801J.pdf">https://ww1.microchip.com/downloads/en/DeviceDoc/MCP2515-Stand-Alone-CAN-Controller-with-SPI-20001801J.pdf</a></p>
<p><a href="https://forums.raspberrypi.com/viewtopic.php?t=141052">[quick-guide] CAN bus on raspberry pi with MCP2515 - Raspberry Pi Forums</a></p>
<p><a href="https://www.beyondlogic.org/adding-can-controller-area-network-to-the-raspberry-pi/">Adding CAN to the Raspberry PI</a></p>
<p><a href="https://projects-raspberry.com/how-to-connect-raspberry-pi-to-can-bus/"></a></p>
<p>apparemment c’est un problème de fils, j’ai les mêmes erreurs qu’ici :</p>
<p><a href="https://forums.raspberrypi.com/viewtopic.php?t=311606">[SOLVED] Not able to setup can0. - Raspberry Pi Forums</a></p>
<p><a href="https://github.com/raspberrypi/linux/issues/4183">MCP251x failes setup CAN-bus communication with error=110 · Issue #4183 · raspberrypi/linux</a></p>
<p>utilisation : cansend can0 <id>#{data}</p>
<p>id sur 3 nombres</p>
<p><a href="https://manpages.debian.org/testing/can-utils/candump.1.en.html">candump(1) - can-utils - Debian testing - Debian Manpages (apt install can-utils)</a></p>
<p>candump any reçoit en boucle</p>
<p>finalement on va laisser tomber spidev et utiliser bash directement</p>
<p>librairie python : spidev (jamais utilisé)</p>
<p><a href="https://pypi.org/project/spidev/">https://pypi.org/project/spidev/</a></p>
<p><a href="https://www.sigmdel.ca/michel/ha/rpi/dnld/draft_spidev_doc_fr.pdf">https://www.sigmdel.ca/michel/ha/rpi/dnld/draft_spidev_doc_fr.pdf</a></p>
<p><a href="https://raspberrypi-aa.github.io/session3/spi.html">https://raspberrypi-aa.github.io/session3/spi.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="détection-de-ladversaire--lidar"><a class="header" href="#détection-de-ladversaire--lidar">Détection de l'adversaire : LIDAR</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="création-dun-robot"><a class="header" href="#création-dun-robot">Création d'un robot</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-setuppy-deprecated"><a class="header" href="#python-setuppy-deprecated">Python setup.py deprecated:</a></h1>
<pre><code>Starting &gt;&gt;&gt; my_python_node
--- stderr: my_python_node                   
/usr/lib/python3/dist-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.
  warnings.warn(
---
Finished &lt;&lt;&lt; my_python_node [0.64s]

Summary: 1 package finished [1.19s]
  1 package had stderr output: my_python_node
</code></pre>
<p>Solution: <code>pip install setuptools==58.2.0</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="electronique-logicielle"><a class="header" href="#electronique-logicielle">Electronique Logicielle</a></h1>
<h2 id="how-to-start"><a class="header" href="#how-to-start">How to start</a></h2>
<ol>
<li>Read guides in <code>STM32CubeIDE</code> section to :</li>
</ol>
<ul>
<li>Install STM32CubeIDE</li>
<li>Create a new project</li>
</ul>
<ol start="2">
<li>
<p>Then clone the <code>stmlib</code> repository from the <a href="https://github.com/ClubRobotInsat/stmlib">Club Robot's GitHub</a>.</p>
</li>
<li>
<p>Read guides in stmlib section to :</p>
</li>
</ol>
<ul>
<li>Add the library to your project</li>
<li>Use the library</li>
</ul>
<p>Now, start with something simple like blinking the onboard LED then an external LED.</p>
<p>For that, read the <code>STM32CubeIDE</code> section to know how to configure the peripheral, build the project and more!</p>
<h2 id="understand-how-it-work"><a class="header" href="#understand-how-it-work">Understand how it work</a></h2>
<p>Documentation for each module is available in the <code>stm32</code> sections. It will be added progressively (promise!).</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p><a href="https://www.st.com/resource/en/reference_manual/rm0440-stm32g4-series-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32G4 reference manual</a> : The Bible for ElecSoft's members, contain all you need to know about the STM32G4 peripherals.</p>
<p><a href="https://www.st.com/resource/en/user_manual/um2397-stm32g4-nucleo32-board-mb1430-stmicroelectronics.pdf">STM32G4 user manual</a> : Contains all information about the board (electrical circuit, solder bridges, pinouts, etc)</p>
<p><a href="https://deepbluembedded.com">DeepBlueEmbedded</a> : Lesson and examples for STM32 programming, very well explained and covers all basic topics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="electronique-logicielle-1"><a class="header" href="#electronique-logicielle-1">Electronique Logicielle</a></h1>
<h2 id="how-to-start-1"><a class="header" href="#how-to-start-1">How to start</a></h2>
<ol>
<li>Read guides in <code>STM32CubeIDE</code> section to :</li>
</ol>
<ul>
<li>Install STM32CubeIDE</li>
<li>Create a new project</li>
</ul>
<ol start="2">
<li>
<p>Then clone the <code>stmlib</code> repository from the <a href="https://github.com/ClubRobotInsat/stmlib">Club Robot's GitHub</a>.</p>
</li>
<li>
<p>Read guides in stmlib section to :</p>
</li>
</ol>
<ul>
<li>Add the library to your project</li>
<li>Use the library</li>
</ul>
<p>Now, start with something simple like blinking the onboard LED then an external LED.</p>
<p>For that, read the <code>STM32CubeIDE</code> section to know how to configure the peripheral, build the project and more!</p>
<h2 id="understand-how-it-work-1"><a class="header" href="#understand-how-it-work-1">Understand how it work</a></h2>
<p>Documentation for each module is available in the <code>stm32</code> sections. It will be added progressively (promise!).</p>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<p><a href="https://www.st.com/resource/en/reference_manual/rm0440-stm32g4-series-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32G4 reference manual</a> : The Bible for ElecSoft's members, contain all you need to know about the STM32G4 peripherals.</p>
<p><a href="https://www.st.com/resource/en/user_manual/um2397-stm32g4-nucleo32-board-mb1430-stmicroelectronics.pdf">STM32G4 user manual</a> : Contains all information about the board (electrical circuit, solder bridges, pinouts, etc)</p>
<p><a href="https://deepbluembedded.com">DeepBlueEmbedded</a> : Lesson and examples for STM32 programming, very well explained and covers all basic topics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-dutilisation-c"><a class="header" href="#guide-dutilisation-c">Guide d'utilisation C</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comment-travaille-t-on-avec-un-stm32-"><a class="header" href="#comment-travaille-t-on-avec-un-stm32-">Comment travaille-t-on avec un STM32 ?</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-stm32cubeide"><a class="header" href="#how-to-use-stm32cubeide">How to use STM32CubeIDE</a></h1>
<p>STM32CubeIDE is a software development environment that enables developers to work with STM32 microcontrollers.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="elec_soft/stm32cubeide/installation.html">Installation</a></li>
<li><a href="elec_soft/stm32cubeide/new_project.html">Creating a new project</a></li>
<li><a href="elec_soft/stm32cubeide/peripheral_config.html">Configuring a STM32</a></li>
<li><a href="elec_soft/stm32cubeide/project_config.html">Configuring your project</a></li>
<li><a href="elec_soft/stm32cubeide/index.html#building-the-project">Building and flashing the project</a></li>
<li><a href="elec_soft/stm32cubeide/index.html#debugging-the-project">Debugging the project</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-dinstallation-de-stm32cubeide"><a class="header" href="#guide-dinstallation-de-stm32cubeide">Guide d'installation de STM32CubeIDE</a></h1>
<p>Lien de téléchargement : <a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE</a></p>
<h2 id="notes-1"><a class="header" href="#notes-1">Notes</a></h2>
<p>Vous aurez besoin d'un compte STMicroelectronics pour utiliser le logiciel.</p>
<h2 id="ensuites"><a class="header" href="#ensuites">Ensuites</a></h2>
<p>Voir <a href="elec_soft/stm32cubeide/new_project.html">Création d'un nouveau projet</a> pour créer un nouveau projet STM32CubeIDE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-de-création-dun-nouveau-projet-stm32cubeide"><a class="header" href="#guide-de-création-dun-nouveau-projet-stm32cubeide">Guide de création d'un nouveau projet STM32CubeIDE</a></h1>
<p>Un project STM32CubeIDE contient le code source, les fichiers de configuration et les fichiers de compilation pour un projet STM32. Ce guide vous montrera comment créer un nouveau projet STM32CubeIDE.</p>
<h2 id="step-1-créer-un-nouveau-workspace"><a class="header" href="#step-1-créer-un-nouveau-workspace">Step 1: Créer un nouveau workspace</a></h2>
<p>D'abord, lance STM32CubeIDE. Vous devriez voir une fenêtre qui ressemble à ceci:</p>
<p><img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/cubeide_ws.png" alt="Workspace Selection" /></p>
<p>Vous devez choisir un "workspace" pour stocker vos projets.</p>
<p>Un workspace est un dossier qui contient plusieurs projets et la configuration de l'IDE.</p>
<p>Cliquez sur "Browse" pour choisir un dossier pour votre workspace. Une fois que vous avez choisi un dossier, cliquez sur "Launch" pour ouvrir STM32CubeIDE.</p>
<h2 id="step-2-créer-un-nouveau-projet"><a class="header" href="#step-2-créer-un-nouveau-projet">Step 2: Créer un nouveau projet</a></h2>
<p>Vous arriverez sur la page d'accueil de STM32CubeIDE. Pour créer un nouveau projet, cliquez sur "Start new STM32 Project".</p>
<p><img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/cubeide_startpage.png" alt="Home Page" /></p>
<h3 id="choisir-le-microcontrôleur"><a class="header" href="#choisir-le-microcontrôleur">Choisir le microcontrôleur</a></h3>
<p><em>Microcontrôleur pour 2024 :</em></p>
<pre><code>STM32G431KBT6
</code></pre>
<p>Une fois cliqué sur "Start new STM32 project", vous devriez voir une fenêtre pour choisir le microcontrôleur que tu veux utiliser:</p>
<p><img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/cubeide_targetselect.png" alt="Microcontroller Selection" /></p>
<p>Entrez "STM32G431KBT6" dans la barre de recherche pour trouver le microcontrôleur que vous voulez utiliser. Cliquez sur "Next" pour continuer.</p>
<h3 id="nommer-le-project"><a class="header" href="#nommer-le-project">Nommer le project</a></h3>
<p>Choissisez un nom pour votre projet. Cliquer sur "Finish" pour créer le projet.</p>
<p>Vous arrivez en suite sur la page de configuration du microcontrôleur.</p>
<p><img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/cubeide_configpage.png" alt="Microcontroller Configuration" /></p>
<h2 id="ensuite"><a class="header" href="#ensuite">Ensuite</a></h2>
<p>Voir ensuite dans <a href="elec_soft/stm32cubeide/peripheral_config.html">Configuration d'un STM</a> pour configurer votre STM32.</p>
<p>Ou dans <a href="elec_soft/stm32cubeide/project_config.html">Configurer ton project</a> pour configurer ton project STM32CubeIDE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-pour-configurer-dun-stm32"><a class="header" href="#guide-pour-configurer-dun-stm32">Guide pour configurer d'un STM32</a></h1>
<p>Oula, ce sujet est très vaste. On essaie de couvrir le minimale pour avoir une idée, après ça dépend vraiment chaque périphérique.</p>
<p>D'ailleur, si tu ne comprends pas ce que c'est un périphérique, je te conseille de lire <a href="elec_soft/stm32cubeide/../stm32/index.html">ce document</a>.</p>
<p><strong>Notes</strong>:
L'outil de configuration de périphérique va auto-générer le code pour configurer les périphériques.
Après avoir configuré, clique sur ce bouton :
<img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/perif_generatecode.png" alt="Generate code" /></p>
<p><strong>Pour accéder à l'outil de configuration</strong> de périphérique, clique sur le fichier <code>.ioc</code>.</p>
<h2 id="table-des-matières"><a class="header" href="#table-des-matières">Table des matières</a></h2>
<ul>
<li><a href="elec_soft/stm32cubeide/peripheral_config.html#pin">Pin</a></li>
<li><a href="elec_soft/stm32cubeide/peripheral_config.html#gpio">GPIO</a></li>
<li><a href="elec_soft/stm32cubeide/peripheral_config.html#timer">Timer</a></li>
<li><a href="elec_soft/stm32cubeide/peripheral_config.html#clock">Clock</a></li>
<li><a href="elec_soft/stm32cubeide/peripheral_config.html#uart">UART</a></li>
</ul>
<h2 id="pin"><a class="header" href="#pin">Pin</a></h2>
<p>Un pin est une broche de sortie ou d'entrée. Il peut être relier à un "Entrée/Sortie Général" (GPIO), ou à un périphérique spécifique (Timer, UART, SPI, etc).</p>
<p><em><strong>Pour configurer un pin</strong></em>, cliquez sur le pin dans le schéma de votre microcontrôleur. Vous pouvez choisir entre plusieurs options.</p>
<p><img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/perif_pin.png" alt="Pin" /></p>
<p>Souvent, autre que le GPIO, le pin sera automatiquement assigné à une fonction quand tu configure une périphérique.</p>
<p><em><strong>Pour trouver un pin alternative qui peut assure la même fonction</strong></em>, gardez Ctrl puis cliquez sur le pin. Vous devez voir les pins alternatives clignotent. Cliquez sur un pin pour le choisir.</p>
<p><img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/perif_pin_alternative.png" alt="Pin alternative" /></p>
<h2 id="gpio"><a class="header" href="#gpio">GPIO</a></h2>
<p>Pour la théorie des GPIO, voir <a href="elec_soft/stm32cubeide/../stm32/gpio.html">ce document</a>.</p>
<p><em><strong>Pour commencer</strong></em></p>
<p>Choisissez le fenêtre de configuration de GPIO ici :
<img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/perif_gpio_1.png" alt="GPIO" /></p>
<p><strong>Quelques configurations indispensables pour un GPIO:</strong></p>
<ul>
<li>Mode: Output Push-Pull, Output Open-Drain, Input, Analog</li>
<li>Pull-up/Pull-down: seulement pour les modes Input</li>
<li>User Label: pour identifier le pin</li>
</ul>
<p><em><strong>Exemple</strong>:</em></p>
<p>Configurer un GPIO pour un sortie '0' et '1' "normal" :</p>
<ul>
<li>Mode: Output Push-Pull</li>
<li>User Label: <code>motor_dir</code></li>
</ul>
<p><img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/perif_gpio_2.png" alt="GPIO" /></p>
<p><strong>Notes:</strong>
Tu peux nommer les pins utilsés par un autre périphérique dans les onglets correspondants (voir image ci-dessus, en haut à gauche).</p>
<h2 id="timer"><a class="header" href="#timer">Timer</a></h2>
<p>Un Timer peut servir à plusieurs choses :</p>
<ul>
<li>Générer des interruptions à intervalles réguliers</li>
<li>Mesurer le temps (compter)</li>
<li>Générer des signaux PWM</li>
<li>Compter des événements externes</li>
</ul>
<p>Voir <a href="elec_soft/stm32cubeide/../stm32/timer.html">ce document</a> pour plus d'informations.</p>
<h3 id="pour-générer-un-pwm"><a class="header" href="#pour-générer-un-pwm">Pour générer un PWM</a></h3>
<p><img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/perif_timer.png" alt="Timer" /></p>
<ul>
<li>Choisir le Clock Source (normalement, c'est le clock interne du microcontrôleur)</li>
<li>Choisir un channel et asigner le mode PWM Generation CHx pour ce channel (un pin sera automatiquement assigné à ce channel)</li>
<li>Configurer la fréquence du signal PWM en changant la "Prescaler" et la "Counter Period"</li>
</ul>
<pre><code>pwm_frequency = clock_frequency / [(prescaler+1) * (counter_period+1)]
</code></pre>
<h2 id="clock"><a class="header" href="#clock">Clock</a></h2>
<h2 id="uart"><a class="header" href="#uart">UART</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comment-configurer-ton-project-stm32cubeide"><a class="header" href="#comment-configurer-ton-project-stm32cubeide">Comment configurer ton project STM32CubeIDE</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quelques-astuces-pour-écrire-du-code-dans-stm32cubeide"><a class="header" href="#quelques-astuces-pour-écrire-du-code-dans-stm32cubeide">Quelques astuces pour écrire du code dans STM32CubeIDE</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comment-builder-et-flasher-ton-code-sur-le-stm32"><a class="header" href="#comment-builder-et-flasher-ton-code-sur-le-stm32">Comment builder et flasher ton code sur le STM32</a></h1>
<p>En 2 lignes :</p>
<ul>
<li>Build : bouton "Hammer" ou (Ctrl+B)</li>
<li>Flash (télécharger ton code sur le STM32) : bouton "Play" ou (Ctrl+Shift+B)</li>
</ul>
<p><img src="elec_soft/stm32cubeide/../../images/elecsoft/stm32cubeide/build_and_flash.png" alt="Build and Flash" /></p>
<p><strong>Notes :</strong></p>
<ul>
<li>Le Flash fait aussi le Build si t'as pas encore buildé.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comment-debug-ton-stm32-avec-stm32cubeide"><a class="header" href="#comment-debug-ton-stm32-avec-stm32cubeide">Comment debug ton STM32 avec STM32CubeIDE</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-the-stmlib-library"><a class="header" href="#how-to-use-the-stmlib-library">How to use the stmlib library</a></h1>
<p>stmlib is a library for Club Robot INSA Toulouse to work on STM32-based projects.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="elec_soft/stmlib/index.html#components-supported-list">Components supported list</a></li>
<li><a href="elec_soft/stmlib/index.html#how-to-work-on-this-project">How to work on this project</a></li>
<li><a href="elec_soft/stmlib/index.html#how-to-use-this-library">How to use this library</a></li>
<li><a href="elec_soft/stmlib/index.html#components">Components</a></li>
<li><a href="elec_soft/stmlib/index.html#contributors">Contributors</a></li>
</ul>
<h2 id="components-supported-list"><a class="header" href="#components-supported-list">Components supported list</a></h2>
<ul>
<li>DC motor</li>
<li>Encoder</li>
<li>Servo</li>
<li>Herkulex Servo</li>
<li>CAN bus</li>
<li>[...]</li>
</ul>
<h2 id="how-to-contribute-to-this-project"><a class="header" href="#how-to-contribute-to-this-project">How to contribute to this project</a></h2>
<p>[To do]</p>
<h2 id="how-to-use-this-library"><a class="header" href="#how-to-use-this-library">How to use this library</a></h2>
<p><strong>0. Create your STM32 project</strong></p>
<p>First you need to create a STM32CubeIDE project. If you already have one, skip this step.</p>
<p><strong>Follow this guide to [Create a STM32 project](link to the guide).</strong></p>
<p>Next we will add this library as a submodule for your project.</p>
<p><strong>1. Add submodule</strong></p>
<p>From your project, add this library as a submodule with the following command :</p>
<p><code>git submodule add https://github.com/ClubRobotInsat/stmlib.git</code></p>
<p><strong>2. Initialize and update submodule</strong></p>
<p>Initialize and update your submodules to fetch the code :</p>
<p><code>git submodule init</code></p>
<p><code>git submodule update</code></p>
<p><strong>3. Update submodule to get the latest version from GitHub</strong></p>
<p><code>git submodule update</code></p>
<p><strong>4. Add the library to your project</strong></p>
<p>To add the library to your project :</p>
<ul>
<li>Open your project in STM32CubeIDE</li>
<li>Right-click on the project name, and select <code>New</code> -&gt; <code>Folder</code></li>
<li>Click on <code>Advanced</code> and select <code>Link to alternate location (Linked Folder)</code></li>
<li>If the <code>stmlib</code> folder is in the root directory of your project, type <code>PROJECT_LOC/stmlib</code> in the <code>Location</code> field. If it is in another directory, type the path to the <code>stmlib</code> folder.</li>
<li>Click on <code>Finish</code></li>
</ul>
<p>Now to include the library in the C include path :</p>
<ul>
<li>Click on the <code>Project</code> -&gt; <code>Properties</code> (upper bar)</li>
<li>In the <code>C/C++ General</code> section, click on <code>Paths and Symbols</code></li>
<li>In the <code>Includes</code> tab, click on <code>Add</code> and select <code>Workspace</code> then select the <code>stmlib</code> folder</li>
<li>In the <code>Source Location</code> field, click on <code>Add folder</code> and select the <code>stmlib</code> folder</li>
<li>Click on <code>Apply and Close</code></li>
</ul>
<pre><code class="language-markdown"># Attention :
If your haven't configured the STM32 board hardware proprely, you may not be able to compile the project.

Some elements in the library require the STM32 board hardware to be configured properly.

For example : dcmotor.h requires a timer to be configured so that stm32g4xx_hal_tim.h is included in the project.
</code></pre>
<p>That's it! You can now include the library in your code. Check the <a href="elec_soft/stmlib/index.html#components">components</a> section for more exemples.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>Please check the documentation in the stmlib repo for more details on each component.</p>
<h2 id="contributors"><a class="header" href="#contributors">Contributors</a></h2>
<ul>
<li>Triet NGUYEN (trietngh)</li>
<li>Huong Cam TANG (tanghuongcam)</li>
<li>Liam CHRISMENT (LiamKaist)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elecsoft-checklist-1o1-"><a class="header" href="#elecsoft-checklist-1o1-">Elecsoft Checklist 1o1 😢</a></h1>
<p>Liste des choses à vérifier si ton circuit ne fonctionne pas et/ou il fait des choses incompréhensibles:</p>
<ul>
<li>T’as une alim à coté de toi ?</li>
<li>Cette alim est branché au circuit ?</li>
<li>Ton microcontrôleur ou autres sont bien alimentées par la ligne d’alim ?</li>
<li>Toutes les masses sont reliées entre elles et communes dans tout le circuit ( oscilo inclus ) ?</li>
<li>Ton alim est au bon voltage?</li>
<li>Ton alim est allumée ( btn on ) et il y a du courant ( 0.0A veut dire que elle alimente rien )?</li>
<li>La multiprise à laquelle l’alim est branché est allumée?</li>
<li>Ton oscilo est en DC ?</li>
<li>TOUS les câbles de ton circuit sont connectées correctement ?</li>
<li>Si tu touches un câble sans le déconnecter ça fait qqch ? T’as un faux contact</li>
<li>Ton microcontrôleur est assez chaud pour l’utiliser comme poêle ?  Il est grille change-le</li>
<li>Teste ta breadboard, si'il ya beaucoup de résistance entre les deux extremités elle est pas bonne et ça peut-être la
cause de ton problèmme. Teste aussi si toutes les lignes de la breadboard sont bien connectés i.e que la breadboard fait son boulout.</li>
<li>Si t’est arrivée jusqu’à ici c’est peut-être pas ( on en est jamais sûrs ) un problème d’élec, tu peux soit revenir au début de cette liste soit passer à debug des problèmes de code mais commence à réfléchir que c’est peut-être toi le problème.</li>
<li>si ton can marche pas vérifie qu’il y a bien au moins 2 dispositfis sur le bus à l’écoute</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="electronique-matérielle"><a class="header" href="#electronique-matérielle">Electronique Matérielle</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="guide-dutilisation-kicad"><a class="header" href="#guide-dutilisation-kicad">Guide d'utilisation Kicad</a></h1>
<p>Voici un lien vers une courte vidéo survolant les étapes de la conception sur Kicad: https://youtu.be/TwVYxu7LeeI<br />
N'hésitez pas à rajouter vos propres commentaires pour que certains aspects soient rajoutés dans une nouvelle version de la vidéo.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="règles-de-jeu-en-elec-hard"><a class="header" href="#règles-de-jeu-en-elec-hard">Règles de jeu en elec-hard.</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="moteur-pas-à-pas-mpp"><a class="header" href="#moteur-pas-à-pas-mpp">Moteur pas à pas (MPP)</a></h1>
<p><strong>Que-ce que c'est un moteur pas à pas? Et pour quoi est-t-il utile?</strong></p>
<ul>
<li>
<p>Un MPP est un moteur électrique, sans balais et à courant continu, qui permet un contrôle précis en <a href="https://fr.wikipedia.org/wiki/Circuit_en_boucle_ouverte">boucle ouverte</a>. Au contraire des moteurs à courant continu, les MPP tournent de manière <em>discrète</em> (d'où le nom "pas à pas"), normalement à 200 pas par rotation, donc un rotation de 1.8 degrés par pas.</p>
</li>
<li>
<p>Le principale avantage d'un MPP est la précision</p>
</li>
</ul>
<p>Pour le robot de 2023, on a décidé d'utiliser des moteurs à courant continu pour la base roulante, parce que d'après nos essais, les MPP ne fournissent pas suffisamment de force.<br />
Néanmoins, les MPP peuvent être utiles dans des futurs applications, d'où le nécessité de ce doc.</p>
<h2 id="fonctionnement-générale-du-moteur-pas-à-pas"><a class="header" href="#fonctionnement-générale-du-moteur-pas-à-pas">Fonctionnement générale du moteur pas à pas.</a></h2>
<p><a href="https://www.tme.eu/fr/news/library-articles/page/41861/Moteur-pas-a-pas-types-et-exemples-dapplications-des-moteurs-pas-a-pas/">Vous trouvez ici</a> un explication détaillé de la fonctionnement d'un MPP.</p>
<h3 id="comment-contrôler-un-mpp"><a class="header" href="#comment-contrôler-un-mpp">Comment contrôler un MPP?</a></h3>
<p>On utilise des microcontrôleurs (STM32) pour contrôler les MPP. Les STM32 permettent d'envoyer un signal précis, mais pas à la puissance requise. Pour résoudre cette problème, un utilise un STM32 pour "gérer" la connexion entre les moteurs et un alimentation à puissance suffisante. Un manière pour faire cela est avec des transistors montées en <a href="https://www.a-m-c.com/fr/experience/technologies/power-devices/pont-en-h/#">pont H</a>.</p>
<p>Pour simplifier l'implémentation de la circuit de contrôle, on a acheté des cartes électroniques qui intègrent un montage en pont H, avec des protections et option de "microstepping".</p>
<p>Le carte que l'on a acheté est: <a href="https://www.pololu.com/product/2968">Pololu MP6500 Stepper Motor Driver Carrier, Digital Current Control</a>. Sur le site vous trouvez toute l'information dont vous avez besoin pour utiliser le driver, et un schéma électronique pour l'implémenter.</p>
<p>Au moment que l'on écrit cette doc (7/12/23), on a 5 cartes dans le club.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mécanique"><a class="header" href="#mécanique">Mécanique</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-fonctions-principales-à-connaitre-pour-lutilisation-de-creo-9"><a class="header" href="#les-fonctions-principales-à-connaitre-pour-lutilisation-de-creo-9">Les fonctions principales à connaitre pour l'utilisation de Creo 9</a></h1>
<h2 id="table-de-matières"><a class="header" href="#table-de-matières">Table de matières</a></h2>
<p><strong>Introduction</strong> <br/>
<strong>I) La Repertoire de travail</strong><br/>
<strong>II) Création d'une pièce et l'ouverture d'une existante</strong><br/>
<strong>III) L'Interface de Creo</strong><br/>
    1) L'Arbre de navigation<br/>
    2) Le Modèle<br/>
    3) L'Analyse<br/>
    4) La Simulation en Direct, l'Annotation, les Outils et la Modélisation Flexible<br/>
    5) L'Affichage<br/>
    6) Les Applications<br/>
<strong>IV) L'Utilisation de ces fonctions</strong><br/>
    1) Les Plans et Les Axes<br/>
    2) L'Esquisse<br/>
    3) L'Extrusion et La Révolution<br/>
    4) Les Arrondis et Les Chanfreins<br/>
    5) La Répétition et La Symétrie<br/>
    6) Mesurer<br/>
    7) Les Apparences et Les Sections<br/>
    8) Le Render Studio<br/>
    9) L'Assemblage<br/></p>
<h2 id="intorduction"><a class="header" href="#intorduction">Intorduction</a></h2>
<p>Creo Parametric est un logiciel de CAD (Computer-aided design) d'entrée de gamme, c'est-à-dire qu'il est moins intuitif que ses collègues (ex. SolidWorks et Catia), mais la licence de Creo coûte moins cher et, ce qui est important, est fournie par notre école, INSA Toulouse. C'est pourquoi au Club Robot, on utilise Creo. Pour savoir comment installer et configurer Creo 9 avec le compte INSA, voir le document : <a href="mecanique/installation-de-creo.html">Installation de Creo</a>.</p>
<h2 id="i-la-repertoire-de-travail"><a class="header" href="#i-la-repertoire-de-travail">I) La Repertoire de travail</a></h2>
<p>La première chose à faire chaque fois que vous lancez votre Creo, c'est le choix du répertoire de travail, c'est-à-dire, vous devez lui indiquer manuellement l'emplacement de votre projet sur votre ordinateur, sinon il ne pourra pas travailler avec les assemblages. C'est une fonction assez pratique car elle permet de ne pas mélanger vos projets et fichiers si vous travaillez sur plusieurs sujets en parallèle.
Pour cela un fois le Creo sera lancée, fermez le pub (oui c'est un popup automatique qui va sauter devant vous tout le temps) et cliquez sur le bouton "Sélectionner le répertoire de travail". Comme dans indiqué sur l'image :</p>
<p><br/><p align="center"><img alt="Sélectionner le répertoire de travail" src="mecanique/img/1.png"  width="80%"></p><br/></p>
<p>Petit conseil : ne mettez pas vos projets sur le bureau, car avec l'accumulation de fichiers, cela peut ralentir le démarrage de l'ordinateur. Rangez-les quelque part dans vos Documents, en traçant bien à quelle année scolaire cela correspond pour vous faciliter l'accès. Exemple :</p>
<p><br/><p align="center"><img src="mecanique/img/2.png" width="60%"></p><br/>
<br/><p align="center"><img src="mecanique/img/3.png" width="60%"></p><br/></p>
<h2 id="ii-création-dune-pièce-et-louverture-dune-existante"><a class="header" href="#ii-création-dune-pièce-et-louverture-dune-existante">II) Création d'une pièce et l'ouverture d'une existante</a></h2>
<p>Maintenant, quand Creo a compris où nous allons stocker nos fichiers, nous allons créer une pièce. Il faut appuyer sur "Nouveau" en haut à gauche, et vous allez voir la fenêtre suivante :</p>
  <p align="center"><img alt="Création de pièce" src="mecanique/img/4.png"  width="80%"></p> <br/>
On laisse les selections de "pièce", "solide" sans modifications et dans "Nom du ficher" on écrit le nom de notre prècieuse pièce.
<br/>
<br/>
<p><strong>ATTENTION !!!</strong> Quand vous allez nommer vos fichiers, il va falloir faire l'effort de les rendre intuitifs, et pas de "pièce123" ou des choses de ce genre. N'hésitez pas à donner des noms longs, séparés par des "_", qui seront utiles lors de la gestion de l'assemblage. Ex. "connecteur_moteur_makeblock", "support_bras", "profile_alu_90mm" etc.</p>
<br/>
<p>Une fois le fichier créé, il faut l'enregistrer. Il faut cliquer sur "fichier" en haut à gauche, puis sur "enregistrer" ou simplement faire "ctrl + s" (à favoriser car c'est simplement plus pratique). Normalement il va vous mettre automatiquement dans votre répertoire de travail.
Maintenant, pour ouvrir une autre ficher, dans la même destination : "fichier" on click "ouvrir" et on choisit le ficher dans la liste.</p>
<p>Comme montré dans l'image :
<br/><p align="center"><img alt="Ouvrir un fichier" src="mecanique/img/5.png"  width="80%"></p> <br/></p>
<h2 id="iii-linterface-de-creo"><a class="header" href="#iii-linterface-de-creo">III) L'Interface de Creo</a></h2>
<p>Ici, je vais donner la liste et l'emplacement dans Creo 9 des fonctions importantes à connaître et que l'on utilise le plus. Même si vous allez voir pas mal de critiques envers Creo dans ce guide, il faut quand même admettre que ce logiciel de CAO a beaucoup de fonctions et permet aux personnes qui le maîtrisent entièrement de réaliser de véritables chefs-d'œuvre. Mais pour être honnête, personne n'a envie de découvrir autant Creo (y compris moi). C'est pourquoi vous aurez les fonctions strictement nécessaires à notre niveau (c'est-à-dire pas d'étude de résistance et d'élasticité des matériaux, de propriétés aérodynamiques de nos pièces et encore moins des sculptures de type Blender, car ce n'est pas vraiment utile pour notre projet).</p>
<p>Pour naviguer, on :</p>
<ul>
<li>Roule la molette de la souris : pour zoomer et dézoomer à l'endroit du positionnement du pointeur de la souris.</li>
<li>Appuie sur la molette + bouge la souris : pour tourner l'angle de vision de la pièce ou de l'assemblage.</li>
<li>Appuie sur la touche Shift (Maj) + appuie sur la molette + bouge la souris : pour déplacer l'angle de vision de la pièce ou de l'assemblage.</li>
</ul>
<p><strong>À noter !</strong> La pièce elle-même ne bouge pas dans ce cas-là, mais l'angle sous lequel l'utilisateur voit la pièce.</p>
<h3 id="1-larbre-de-navigation"><a class="header" href="#1-larbre-de-navigation">1) L'Arbre de navigation</a></h3>
<p>L'Arbre de navigation se trouve à notre gauche, comme dans l'image :</p>
<p><br/><p align="center"><img alt="Arbre de navigation" src="mecanique/img/6.png"  width="80%"></p> <br/></p>
<p>Ici, on va retrouver les noms de toutes les opérations et fonctions appliquées sur la pièce, ou la liste de toutes les pièces dans les assemblages. L'Arbre de navigation est manipulable, c'est une sorte de trace de vos fonctions que vous pouvez manipuler et l'application va tout recalculer. Vous pouvez bouger la ligne verte afin de masquer les dernières modifications et de "revenir dans le temps". C'est utile quand vous voulez ajouter des modifications post factum sans tout refaire.
On va s'en servir également quand il faudra choisir un élément de la pièce ou de l'assemblage (ex. plans, axes, origines, sous-assemblages, etc.).
Dans une ficher vide, on a quand même notre origine et les plans de Right (vue de profile), Top (vue de dessus) et Front (vue de face) qui sont la base de notre pièce ou de l'assemblage.</p>
<h3 id="2-le-modèle"><a class="header" href="#2-le-modèle">2) Le Modèle</a></h3>
<p>Dans la partie modèle, on a nos fonctionnalités clés, qui sont entourées dans l'image :</p>
<p><br/><p align="center"><img alt="Modèle" src="mecanique/img/7.png"  width="80%"></p> <br/></p>
<p><strong>Surlignées en Vert :</strong></p>
<ul>
<li>Plans : permet de créer des plans quelconques, quand l'orientation ou l'emplacement des plans de base ne suffisent pas</li>
<li>Axe : permet de créer des axes, pour faire des rotations ou des alignements autour de ces axes</li>
<li>Esquisse : faire une esquisse sur un plan pour ensuite ajouter ou enlever de la matière suivant cette esquisse (la base de la base !)</li>
<li>Extrusion et Révolution : des fonctions jumelles qui rendent nos esquisses en 3D, où :
<ul>
<li>L'Extrusion fait cela en projection rectiligne</li>
<li>La Révolution le fait en tournant autour d'un axe</li>
</ul>
</li>
</ul>
<p><strong>Surlignées en Rouge :</strong></p>
<ul>
<li>Arrondi et Chanfrein : une autre paire de fonctions de même idée, qui ont pour but principal de rendre notre modèle plus solide, où :
<ul>
<li>Arrondi : comme son nom l'indique, arrondit les angles en y ajoutant (ou en enlevant) de la matière</li>
<li>Chanfrein : un peu la même idée que l'arrondi, mais au lieu de quelque chose de rond, on ajoute (ou enlève) un angle plat</li>
</ul>
</li>
</ul>
<p><strong>Surlignées en Bleu :</strong></p>
<ul>
<li>Répétition : sert à répliquer plusieurs fois les autres fonctions (on peut faire des répétitions de tout, même des répétitions de répétitions)</li>
<li>Symétrie : sert à simplement faire une réplique en miroir selon un plan (très utile pour les pièces symétriques)</li>
</ul>
<p><strong>Surlignées en Violet :</strong></p>
<ul>
<li>L'Ombrage : rend les pièces mieux visibles, quand vous lancez Creo, il suffit de choisir l'option 2 "L'ombrage avec des arêtes"</li>
<li>Affichage : permet de cacher les plans, les axes, les origines et les points ; il va falloir tout cacher pour les grands assemblages, sinon on ne voit rien</li>
</ul>
<p><strong>Cas particulier pour l'Assemblage :</strong>
Cette fenêtre est un peu modifiée pour les assemblages et on y retrouve une fonction cruciale :</p>
<ul>
<li>Assembler : permet d'ajouter, une par une, les pièces dans l'assemblage afin de voir la totalité du système ensemble
<br/><p align="center"><img alt="Assembler" src="mecanique/img/8.png"  width="80%"></p> <br/></li>
</ul>
<h3 id="3-lanalyse"><a class="header" href="#3-lanalyse">3) L'Analyse</a></h3>
<p>Drôlement, la seule fonction qu'on utilise ici c'est la "Mesurer", la règle magique qui permet de mesurer les distances, les angles, les rayons entre les plans, les axes et les points. Un outil indispensable lors de la modélisation ! L'Emplacement :</p>
<p><br/><p align="center"><img alt="Analyse" src="mecanique/img/9.png"  width="80%"></p> <br/></p>
<h3 id="4-la-simulation-en-direct-lannotation-les-outils-et-la-modélisation-flexible"><a class="header" href="#4-la-simulation-en-direct-lannotation-les-outils-et-la-modélisation-flexible">4) La Simulation en Direct, l'Annotation, les Outils et la Modélisation Flexible</a></h3>
<p>Ces quatres sont à découvrir pour les plus curieux, on n'en a pas besoin pour l'instant.</p>
<h3 id="5-laffichage"><a class="header" href="#5-laffichage">5) L'Affichage</a></h3>
<p>Ici, on a deux fonctions qui nous aident à mieux visualiser nos modèles :</p>
<ul>
<li>Apparences : permet de choisir le matériau et la couleur de la surface de la pièce. Il y a une bibliothèque de matériaux (à chercher en anglais !)</li>
<li>Section : permet de découper notre pièce ou l'assemblage pour voir son contenu, sans le détruire (sans modifier l'arbre de navigation)</li>
</ul>
<p><br/><p align="center"><img alt="Affichage" src="mecanique/img/10.png"  width="80%"></p> <br/></p>
<h3 id="6-les-applications"><a class="header" href="#6-les-applications">6) Les Applications</a></h3>
<p>Dans cette partie, on a l'artillerie lourde que j'ai l'ambition de mettre en place au club un jour, mais c'est un peu overkill pour notre niveau. Donc la seule fonction qu'on utilise ici c'est :</p>
<ul>
<li>Render Studio : permet d'immortaliser nos jolis modèles en haute qualité pour partager entre nous ou pour poster sur les réseaux sociaux
<br/><p align="center"><img alt="Render studio" src="mecanique/img/11.png"  width="80%"></p> <br/>
<strong>Cas particulier pour l'Assemblage :</strong>
Dans les assemblages, on retrouve dans cette fenêtre une fonction expérimentale (même l'auteur de ce guide ne la maîtrise pas comme il faut) :</li>
<li>Câblage : permet de modéliser les câbles beaucoup plus agilement
<br/><p align="center"><img alt="Câblage" src="mecanique/img/12.png"  width="80%"></p> <br/></li>
</ul>
<h2 id="iv-lutilisation-de-ces-fonctions"><a class="header" href="#iv-lutilisation-de-ces-fonctions">IV) L'Utilisation de ces fonctions</a></h2>
<h3 id="1-les-plans-et-les-axes"><a class="header" href="#1-les-plans-et-les-axes">1) Les Plans et Les Axes</a></h3>
<p>Dans Creo, pour créer une nouvelle fonction, il faut la baser sur celles existantes. Autrement dit, c'est une chaîne de fonctions basées les unes sur les autres. Ce n'est pas différent pour les plans et les axes. Donc pour les créer, il faut :</p>
<ol>
<li>Appuyer sur la fonction</li>
<li>Choisir le plan ou les plans (en gardant appuyé le Ctrl) par rapport auxquels on veut positionner notre nouveau plan ou nouvel axe</li>
<li>Donner les paramètres (ex. Décaler de 20 mm)</li>
<li>Appuyer sur OK</li>
<li>Visualiser votre nouveau plan ou nouvel axe dans l'arbre de navigation</li>
<li>Se dire bravo</li>
</ol>
<p>Et c'est aussi simple que ça. Voir le GIF :</p>
<p><br/><p align="center"><img alt="Plans ett Axes" src="mecanique/img/13_1.gif"  width="80%"></p> <br/></p>
<h3 id="2-lesquisse"><a class="header" href="#2-lesquisse">2) L'Esquisse</a></h3>
<h4 id="a-comment-la-créer"><a class="header" href="#a-comment-la-créer">a) Comment la créer</a></h4>
<p>Comme dit précédemment, l'esquisse est la fonction qui permet de faire le schéma en 2D pour le rendre 3D plus tard. Donc, pour le faire, il faut simplement choisir soit un plan, soit une face pour commencer à travailler.
<strong>À noter !</strong> Creo va essayer de "capturer" votre souris avec des références ; il ne faut pas avoir peur de les utiliser, car ce sont des liens automatiques proposés qui facilitent votre tâche quand vous allez coter (voir plus bas).
Pour entrer dans la rédaction de l'esquisse, il faut faire comme avec les plans :</p>
<ol>
<li>Appuyer sur "Esquisse"</li>
<li>Choisir le plan ou la face où poser l'esquisse
Voilà un GIF qui montre comment le faire :</li>
</ol>
<p><br/><p align="center"><img alt="Esquisse" src="mecanique/img/14.gif"  width="80%"></p> <br/>
Pour modifier l'esquisse une fois que vous l'avez fermée, il faut appuyer sur cela dans l'arbre de navigation et choisir "Modifier la définition" (le deuxième icône).</p>
<h4 id="b-les-rectangles-divers"><a class="header" href="#b-les-rectangles-divers">b) Les Rectangles divers</a></h4>
<p>On a trois types de rectangles qu'on utilise :</p>
<ul>
<li>Rectangle de coin : défini par ses 2 extrémités sur la diagonale</li>
<li>Rectangle incliné : défini par son côté et la direction de propagation</li>
<li>Rectangle central : défini par son centre et la longueur de ses côtés
Voilà le GIF correspondant :</li>
</ul>
<p><br/><p align="center"><img alt="Rectangles" src="mecanique/img/15.gif"  width="80%"></p> <br/></p>
<h4 id="c-les-circles"><a class="header" href="#c-les-circles">c) Les Circles</a></h4>
<p>L'utilisation du cercle est très intuitive, il est défini par son centre et son rayon.
<strong>À noter !</strong> Les cercles créent des axes par défaut que l'on peut utiliser pour d'autres fonctions (cela sera abordé plus tard).<br/>
Voilà un exemple :</p>
<p><br/><p align="center"><img alt="Circles" src="mecanique/img/16.gif"  width="80%"></p> <br/></p>
<h4 id="d-les-lignes"><a class="header" href="#d-les-lignes">d) Les Lignes</a></h4>
<p>Les lignes sont utilisées pour faire des formes quelconques. Quand la forme est finie, il faut juste appuyer sur Échap (ESC) pour arrêter la ligne.<br />
Exemple dans le GIF précédent.</p>
<h4 id="e-les-arcs"><a class="header" href="#e-les-arcs">e) Les Arcs</a></h4>
<p>Une combinaison intuitive entre les cercles et les lignes afin de faire des demi-cercles. Voici l'exemple :</p>
<p><br/><p align="center"><img alt="Arcs" src="mecanique/img/17.gif"  width="80%"></p> <br/></p>
<h4 id="f-supprimer-les-segments"><a class="header" href="#f-supprimer-les-segments">f) Supprimer les segments</a></h4>
<p>Un outil qui permet d'enlever des segments afin de créer des formes exotiques tout en gardant les références automatiques qui rends la modélisation plus facile à modifier. Voice le GIF :
<br/><p align="center"><img alt="Arcs" src="mecanique/img/18.gif"  width="80%"></p> <br/></p>
<h4 id="g-les-palletes"><a class="header" href="#g-les-palletes">g) Les Palletes</a></h4>
<p>Pour les formes un peu plus complexes mais toujours symétriques, nous avons une bibliothèque de formes cachée dans la fonction "Palette". C'est très utile car nos robots sont de base carrés (2022-2023), octogonaux (2023-2024) ou hexagonaux (2024-2025). <br/>
Pour les utiliser, il faut simplement ouvrir la liste, attraper la forme et la tirer vers l'endroit où l'on veut la placer. Ensuite, il suffit juste de donner la taille du paramètre et c'est tout. Voici l'exemple :</p>
<p><br/><p align="center"><img alt="Palletes" src="mecanique/img/19.gif"  width="80%"></p> <br/></p>
<h4 id="h-les-cotes-et-les-annotations"><a class="header" href="#h-les-cotes-et-les-annotations">h) Les Cotes et Les Annotations</a></h4>
<p>And last but not least, les cotes. <strong>C'est l'outil le plus important des esquisses !</strong>
<br/>
Cette fonction sert à donner la taille de toutes les formes vues précédemment. <strong>À noter !</strong>
Creo ne tolère pas d'avoir deux fois la même cote, c'est-à-dire que si vous avez déjà donné suffisamment d'informations pour calculer la taille de votre mesure, il va manifester, car cela peut causer des problèmes. La situation est identique si vous essayez de donner des mesures qui sont en conflit ; dans ce cas-là, Creo va vous proposer de changer votre mesure ou de supprimer vos anciennes mesures pour éliminer le conflit.</p>
<p>Pour l'utiliser, il faut :</p>
<ul>
<li>Appuyer sur "Cote"</li>
<li>Choisir la première référence</li>
<li>En gardant appuié le Ctrl, choisir la deuxième référence</li>
<li>Et en rélachant le Ctrl, appuyer sur la molette (le bouton central de la souris) entre les deux références
<strong>Attention !</strong> Le type de cote (distance, décalage d'angle, rayon) dépend de l'endroit sur l'esquisse où vous appuyez sur la molette. C'est assez intuitif et vous allez vite comprendre vous-même. Voilà l'exemple :
<br/><p align="center"><img alt="Cotes" src="mecanique/img/20.gif"  width="80%"></p> <br/></li>
</ul>
<h3 id="3-lextrusion-et-la-révolution"><a class="header" href="#3-lextrusion-et-la-révolution">3) L'Extrusion et La Révolution</a></h3>
<p>Une fois votre esquisse prête, vous aurez accès à une nouvelle paire de fonctions : extrusion et révolution. Les deux servent à ajouter ou à enlever de la matière, ni plus ni moins.</p>
<h4 id="a-lextrusion"><a class="header" href="#a-lextrusion">a) L'Extrusion</a></h4>
<ul>
<li>Pour ajouter de la matière, il faut :
<ol>
<li>Choisir l'esquisse correspondante</li>
<li>Appuyer sur la fonction "Extrusion"</li>
<li>Choisir la profondeur et la direction
Voici un exemple :</li>
</ol>
</li>
</ul>
<p><br/><p align="center"><img alt="Extrusion1" src="mecanique/img/21.gif"  width="80%"></p> <br/></p>
<ul>
<li>Pour enlever de la matière, il faut :
<ol>
<li>Choisir l'esquisse correspondante</li>
<li>Appuyer sur la fonction "Extrusion"</li>
<li>Appuyer sur l'option "Enlever de la matière"</li>
<li>Chager la direction</li>
<li>Choisir le mode :</li>
</ol>
<ul>
<li>Donner la profondeur</li>
<li>Changer la référence et indiquer jusqu'où cela doit aller</li>
<li>Choisir "à travers tout" pour traverser l'ensemble.</li>
</ul>
</li>
</ul>
<p>Voici un exemple de trou fait par la profondeur :</p>
<p><br/><p align="center"><img alt="Extrusion2" src="mecanique/img/22.gif"  width="80%"></p> <br/></p>
<p>Un autre exemple de trou fait par la référence :</p>
<p><br/><p align="center"><img alt="Extrusion3" src="mecanique/img/23.gif"  width="80%"></p> <br/></p>
<p>Et un troisième fait par "A travers tout" :</p>
<p><br/><p align="center"><img alt="Extrusion4" src="mecanique/img/24.gif"  width="80%"></p> <br/></p>
<h4 id="b-la-révolution"><a class="header" href="#b-la-révolution">b) La Révolution</a></h4>
<p>La révolution est presque identique à la fonction précédente, avec une différence : elle nécessite d'avoir un axe autour duquel la rotation sera faite.
Donc, pour faire une révolution (sans faire sauter des têtes de rois), il faut :</p>
<ol>
<li>Choisir l'esquisse correspondante</li>
<li>Appuyer sur la fonction "Révolution"</li>
<li>Choisir l'axe de révolution</li>
</ol>
<p>Et s'il faut faire un trou, comme pour l'extrusion, il suffit simplement d'appuyer sur "Enlever de la matière".
Voici un exemple :</p>
<p><br/><p align="center"><img alt="Revolution" src="mecanique/img/25.gif"  width="80%"></p><br/></p>
<h3 id="4-les-arrondis-et-les-chanfreins"><a class="header" href="#4-les-arrondis-et-les-chanfreins">4) Les Arrondis et Les Chanfreins</a></h3>
<p>Ces deux fonctions, malgré leur importance, sont parfois oubliées, et c'est dommage, car si elles sont bien appliquées, elles peuvent :</p>
<ul>
<li>Rendre la pièce plus solide</li>
<li>La rendre plus jolie et ergonomique</li>
<li>Améliorer la qualité d'impression avec l'imprimante 3D</li>
</ul>
<p><strong>Donc à favoriser leurs utilisation !</strong>
Mais que font-elles si elles sont aussi importantes ? Pas grand-chose, en fait, juste :</p>
<ul>
<li>Les arrondis : rendent les arêtes rondes.</li>
<li>Les chanfreins : rendent les arêtes plates.</li>
</ul>
<p>Très souvent, quand on les applique, on enlève de la matière dans les endroits où elle est trop inutile et on en rajoute là où il en manque.</p>
<p><strong>Attention !</strong> Pour savoir dans quels cas les utiliser, lire absolument : <a href="mecanique/tips-de-meca.html">Tips de Meca</a>)</p>
<p>Alors, comment les appliquer ? C'est très simple :</p>
<ul>
<li>Appuyer sur "Arrondi" (ou "Chanfrein" si vous avez besoin de cela).</li>
<li>En gardant appuyé le Ctrl, appuyer sur les arêtes qui vous intéressent.</li>
<li>Ajouter le rayon d’arrondi désiré (idem pour le "Chanfrein", mais au lieu du rayon, il faut modifier une longueur).</li>
</ul>
<p>Si vous faites cela, vous verrez que Creo a créé un groupe nommé "Jeu 1". Si vous relâchez Ctrl et appuyez sur une nouvelle arête, puis refaites toutes les opérations décrites précédemment, il créera un nouveau groupe : "Jeu 2". L'intérêt de ces groupes est d'avoir plusieurs arrondis/chanfreins qui sont faciles à modifier en modifiant le groupe, sans avoir à les modifier un par un.</p>
<p>Voici à quoi cela doit ressembler :</p>
<p><br/><p align="center"><img alt="Arrondi" src="mecanique/img/38.gif"  width="80%"></p><br/></p>
<h3 id="5-la-répétition-et-la-symétrie"><a class="header" href="#5-la-répétition-et-la-symétrie">5) La Répétition et La Symétrie</a></h3>
<p>Puisque vous êtes en train de lire ce guide, j'ose supposer que vous faites partie de Club Robot. D'où, une autre supposition courageuse : vous n'aimez pas trop les actions répétitives. Si c'est le cas, je vous félicite, car Creo nous permet d'éviter de faire plusieurs fois la même action avec ces deux fonctions : "Répétition" et "Symétrie".</p>
<h4 id="a-la-répétition"><a class="header" href="#a-la-répétition">a) La Répétition</a></h4>
<p>Il y a plusieurs options de "Répétition", mais nous allons nous concentrer sur deux d'entre elles :</p>
<ul>
<li>Répétition de direction : très pratique pour couvrir une surface. Pour le faire, il faut :</li>
</ul>
<ol>
<li>Choisir la fonction à répéter (l'extrusion, la révolution, les arrondis, les symétries, et même les autres répétitions).</li>
<li>Appuyer sur "Répétition".</li>
<li>En haut à gauche, choisir le type : Direction.</li>
<li>Choisir la direction 1.</li>
<li>Choisir la direction 2 s'il y en a une (c'est pour couvrir toute la surface).</li>
<li>Donner le nombre de membres dans la direction 1 (c'est-à-dire combien de fois répéter la fonction dans cette direction, y compris la fonction initiale).</li>
<li>Idem pour la direction 2 s'il y en a une.</li>
<li>Donner l'espacement entre les membres (la distance entre chaque membre de la répétition).</li>
<li>Idem pour la direction 2 s'il y en a une.</li>
<li>Apprécier le résultat (ne pas abuser si vous avez de la trypophobie).</li>
</ol>
<p>Voici un exemple :</p>
<p><br/><p align="center"><img alt="Repetition1" src="mecanique/img/26.gif"  width="80%"></p><br/></p>
<ul>
<li>
<p>Répetition d'axe : propagation autours d'une axe, très pratique pour les trous de vis. Pour le faire, il faut :</p>
<ol>
<li>Choisir la fonction à répéter (l'extrusion, la révolution, les arrondis, les symétries, et même les autres répétitions).</li>
<li>Appuyer sur "Répétition"</li>
<li>En haut à gauche, choisir le type : Axe.</li>
<li>Choisir l'axe de Répétion</li>
<li>Choisir le nombre de membres de répétition</li>
<li>Choisir l'angle qui separe ces membres</li>
<li>Apprècier le résultat de votre travail</li>
</ol>
</li>
</ul>
<p><strong>Important !</strong> Ne pas faire plus de membres qu'il ne faut. Par exemple, si vous avez 120° d'angle entre les membres, ça ne sert à rien d'en mettre plus que 360°/120 = 3, car cela entraîne des superpositions de trous et des erreurs plus tard (pas fou-fou).</p>
<p>Voici un exemple :</p>
<p><br/><p align="center"><img alt="Repetition2" src="mecanique/img/27.gif"  width="80%"></p><br/></p>
<h4 id="b-la-symétrie"><a class="header" href="#b-la-symétrie">b) La Symétrie</a></h4>
<p>La fonction "Symétrie" est très proche de la "Répétition", sauf qu'elle reproduit la réflexion par rapport à un plan (comme un miroir en fait).</p>
<p>Pour l'utiliser il faut :</p>
<ol>
<li>Choisir la fonction à répéter (l'extrusion, la révolution, les arrondis, les répétitions, et même les autres symétries).</li>
<li>Appuyer sur "Symétrie"</li>
<li>Choisir le plan de symétrie</li>
<li>Apprècier le résultat</li>
</ol>
<p>Voici un exemple :</p>
<p><br/><p align="center"><img alt="Symetrie" src="mecanique/img/28.gif"  width="80%"></p><br/></p>
<h3 id="6-mesurer"><a class="header" href="#6-mesurer">6) Mesurer</a></h3>
<p>Quand vous aurez besoin de mesurer quelque chose, par exemple une distance, un rayon, un angle ou une surface, vous allez utiliser notre règle magique.</p>
<p>Pour l'utiliser :</p>
<ul>
<li>Pour mesurer une longueur, un rayon ou tout autre paramètre unique, il faut :</li>
</ul>
<ol>
<li>Appuyer sur "Mesurer".</li>
<li>Appuyer sur l'objet à mesurer.</li>
<li>Se dire, "WoW, tellement bien fait !".</li>
</ol>
<ul>
<li>Pour mesurer une distance, un décalage d'angle ou tout autre paramètre lié à deux entités :</li>
</ul>
<ol>
<li>Appuyer sur "Mesurer".</li>
<li>Appuyer sur la référence 1 de la mesure.</li>
<li>En gardant le Ctrl appuyé, appuyer sur la référence 2 de la mesure.</li>
<li>Tadaaah</li>
</ol>
<p>Voici un exemple:
<br/><p align="center"><img alt="Mesurer" src="mecanique/img/29.gif"  width="80%"></p><br/></p>
<h3 id="7-les-apparences-et-les-sections"><a class="header" href="#7-les-apparences-et-les-sections">7) Les Apparences et Les Sections</a></h3>
<p>Ces deux fonctions ne sont pas indispensables, mais elles aident à mieux visualiser nos pièces.</p>
<ul>
<li>Les Apparences : sont comme la peinture sur les surfaces choisies (cela peut être des couleurs ou des matériaux). Pour les utiliser, il faut :
<ol>
<li>Choisir les surfaces à peindre.</li>
<li>Appuyer sur la fonction "Apparences" (pas l'icône de boule, mais bien le mot "Apparences" avec la flèche).</li>
<li>Taper la couleur/le matériau dans la barre de recherche (en anglais !) ou choisir parmi ceux proposés.</li>
<li>Apprécier la beauté de l'art que vous venez de créer.</li>
</ol>
</li>
</ul>
<p>Voici un exemple avec du fer (j'ai tapé "Iron" dans la barre de recherche) :</p>
<p><br/><p align="center"><img alt="Apparence" src="mecanique/img/30.gif"  width="80%"></p><br/></p>
<ul>
<li>
<p>Les sections : servent à découper la pièce pour voir son intérieur sans la modifier. Pour les utiliser, il faut :</p>
<ol>
<li>Appuyer sur la fonction "Section".</li>
<li>Choisir le plan auquel la section doit être parallèle.</li>
<li>Bouger la souris ou taper manuellement en haut pour choisir la profondeur de la section.</li>
<li>Masquer la section si vous n'en avez plus besoin et souhaitez continuer votre modélisation.</li>
</ol>
</li>
</ul>
<p>Voici un exemple :</p>
<p><br/><p align="center"><img alt="Section" src="mecanique/img/31.gif"  width="80%"></p><br/></p>
<h3 id="8-le-render-studio"><a class="header" href="#8-le-render-studio">8) Le Render Studio</a></h3>
<p>Ça y est, vous avez fini votre magnifique pièce ou assemblage ? Vous avez envie de la partager avec vos collègues pour leur demander leur avis ? Bonne idée ! Mais il faut le faire proprement.</p>
<br/>
<p>Après avoir appliqué vos apparences, vous allez lancer le "Render Studio".</p>
<p>L'utilisation est simple :</p>
<p>Appuyer sur "Render Studio" dans Applications.</p>
<ul>
<li>Ensuite, appuyer sur "Rendu".</li>
<li>Choisir l'emplacement et le nom du fichier.</li>
<li>Choisir le format :
<ul>
<li>JPEG : si vous voulez garder l'arrière-plan.</li>
<li>PNG : si vous voulez un arrière-plan transparent (il faudra également appuyer sur "Inclure Alpha" pour cela).</li>
</ul>
</li>
<li>Ensuite, choisir l'un des deux :
<ul>
<li>Le nombre d'échantillons (plus il y en a, meilleure sera la qualité de l'image ; à partir de 500, la qualité est suffisante).</li>
<li>La durée de rendu (environ 30 secondes suffisent).</li>
</ul>
</li>
<li>Envoyer à votre secrétaire de club pour qu'il fasse de jolis posts sur les réseaux sociaux.</li>
</ul>
<p>Voici un exemple :</p>
<p><br/><p align="center"><img alt="Render" src="mecanique/img/32.gif"  width="80%"></p><br/></p>
<p>Et pour comparer le résultat : à gauche on n'a que 6 echantillons alors qu'à droite on en a 500.</p>
<p><br/><p align="center"><img alt="Render2" src="mecanique/img/40.png"  width="80%"></p><br/></p>
<h3 id="9-lassemblage"><a class="header" href="#9-lassemblage">9) L'Assemblage</a></h3>
<p>Pour finir, le coup de grâce : le moment où toutes vos pièces vont se rassembler pour former une entité, un monstre de Frankenstein, une amalgamation d'imaginations humaines... autrement dit, le robot ! <br/>
La création de l'assemblage est identique à celle d'une pièce, avec la seule différence qu'il faut choisir "Assemblage" au lieu de "Pièce" dans la fenêtre de sélection.</p>
<br/>
<p>Commençons par le commencement : la première pièce.
<br />
La première pièce est la base de votre assemblage et elle est censée être fixe, donc c'est à vous de fixer cette pièce en premier.</p>
<p>Pour cela, il faut :</p>
<ol>
<li>Appuyer sur "Assemblage".</li>
<li>Choisir la pièce dans la liste.</li>
<li>Choisir l'origine de l'assemblage dans l'arbre de navigation.</li>
<li>Choisir l'origine de la pièce dans l'arbre de navigation.</li>
<li>Vérifier que la pièce a bien changé de couleur, car si la pièce est :
- Violette : elle n'est pas fixe (il y a des contraintes à ajouter).
- Orange : elle est fixe (il n'y a pas besoin de contraintes supplémentaires, mais vous pouvez la réorienter avec une dernière contrainte).</li>
<li>Appuyer sur OK.
<strong>À noter !</strong> Pour que l'assemblage reste fonctionnel même après le redémarrage de Creo, il faut que toutes les pièces se retrouvent dans le même dossier que l'assemblage (<strong>et pas dans des sous-dossiers !</strong> Sinon Creo va perdre les pièces). De plus, on peut faire des assemblages avec d'autres assemblages (pour l'assemblage maître, l'assemblage importé est considéré comme une pièce).</li>
</ol>
<p>Voici la démonstration :</p>
<p><br/><p align="center"><img alt="Assemblage1" src="mecanique/img/35.gif"  width="80%"></p><br/></p>
<p>Quand la pièce de base sera fixée, nous allons ajouter les autres, et c'est là que nous parlerons des "Restrictions" (Contraintes). Ce sont les liaisons entre deux pièces ou deux références (ex. les faces, les arêtes, les axes, etc.) qui permettent de construire l'assemblage.</p>
<p>Il y en a 10 au total, mais les plus utilisées sont :</p>
<ul>
<li>Coincident : lorsque les deux références sont collées</li>
<li>Distance : similaire à coincident, mais avec une distance spécifiée
<strong>Attention !</strong> Cela ne signifie pas que toutes les directions sont bloquées, la restriction s'applique uniquement aux références choisies.
Par exemple, si vous bloquez deux faces, cela revient à mettre en contact deux plans infinis. Il faut donc ajouter d'autres contraintes (coincident ou
distance) pour fixer la pièce</li>
<li>Orienté : lorsque deux cylindres ou axes sont imposés d'être coaxiaux</li>
<li>Parallèle : lorsque l'on ne veut pas fixer l'objet mais plutôt encadrer ses déplacements</li>
<li>Décalage d'angle : comme son nom l'indique, cela permet d'imposer un décalage d'angle entre deux références
Normalement, ces 5 contraintes suffisent largement pour effectuer toutes les opérations nécessaires
<br/>
Très souvent, vous n'aurez même pas besoin de choisir le type de restriction, car Creo comprend rapidement ce que vous voulez faire. Et s'il interprète mal vos besoins, vous pouvez choisir dans la liste et corriger.</li>
</ul>
<p>Pour ajouter de nouvelles pièces à la base et appliquer les restrictions, il faut :</p>
<ol>
<li>Appuyer sur "Assemblage".</li>
<li>Choisir la pièce dans la liste.</li>
<li>Choisir la référence à fixer sur la pièce.</li>
<li>Choisir la référence à fixer sur la base.</li>
<li>Appuyer sur "Nouvelle restriction" (si vous avez besoin de continuer).</li>
<li>Refaire les étapes 3 et 4.</li>
<li>Répéter jusqu'à ce que la pièce devienne orange (couleur d'une pièce fixe).</li>
</ol>
<p>Voici un exemple :</p>
<p><br/><p align="center"><img alt="Assemblage2" src="mecanique/img/36.gif"  width="80%"></p><br/></p>
<p><strong>Cas particulier :</strong> si vous souhaitez rendre vos assemblages mobiles pour voir les éléments du robot en mouvement, il faut laisser la pièce violette lors de l'application des restrictions et laisser libre la référence que vous voulez bouger. Dans l'exemple suivant, j'oriente deux trous, mais je ne fixe pas la distance entre les plans, ce qui me permet, en utilisant la fonction "Faire glisser les composents", de faire ceci :</p>
<p><br/><p align="center"><img alt="Assemblage3" src="mecanique/img/37.gif"  width="80%"></p><br/></p>
<p>Après, quand vous aurez plus d'expérience et que vous aurez compris la logique des "Restrictions" (vous allez vite comprendre après avoir travaillé avec, je ne vois pas l'intérêt de tout détailler ici, c'est très intuitif), vous serez capable de faire des choses de ce genre :</p>
<p><br/><p align="center"><img alt="Assemblage4" src="mecanique/img/39.gif"  width="80%"></p><br/></p>
<p>Ce n'est pas un chef-d'œuvre, mais c'est quelque chose de pratique qui permet de bouger le mécanisme pour mieux voir les choses à corriger.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-de-linstallation-et-de-configuration-de-creo-9"><a class="header" href="#guide-de-linstallation-et-de-configuration-de-creo-9">Guide de l'installation et de configuration de Creo 9</a></h1>
<h2 id="etape-1--téléchargement"><a class="header" href="#etape-1--téléchargement">Etape 1 : Téléchargement</a></h2>
<p>On travaille avec <strong>Creo Parametric 9</strong>, pour le télécharger, il faut suivre le lien : <a href="https://www.ptc.com/en/products/education/free-software/creo-college-download">Installer Creo</a>.
Il faut s'inscrire avec <strong>votre mail INSA</strong> et suivre les étapes qui sont démontrées dans la vidéo.: <a href="https://www.youtube.com/watch?v=LYNOAizD2eE">How to download creo 7.0 student version for free</a>. Mais bien évidemment, au lieu de Creo 7, dans toutes les instances, il faut choisir le <strong>Creo 9</strong>. Si la vidéo n'est pas disponible, adressez-vous à votre responsable de pôle Mécanique.</p>
<h2 id="etape-2--configuration"><a class="header" href="#etape-2--configuration">Etape 2 : Configuration</a></h2>
<p>Il faut télécharger le ficher <a href="https://github.com/ClubRobotInsat/doc/blob/master/src/mecanique/config.pro">config.pro</a> et le remplacer sur votre ordinateur dans la destination suivante : "C:\Program Files\PTC\Creo 9.0.0.0\Common Files\text". Si vous l'avez installé ailleurs, il faut trouver où se trouvent vos Program Files et suivre le reste comme dans le lien. Cette configuration a pour but de faire deux choses :</p>
<ol>
<li>Utilisation d'unités métriques par défaut (sinon c'est en pouces et pas cohérent avec la logique parce que les unités impériales ne servent à rien)</li>
<li>Faire en sorte que Creo ne garde pas les anciennes versions de vos fichiers pour ne pas créer des erreurs sur GitHub (voir le tutoriel de Git pour les mécas)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>Modifications à venir</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retour-dexpériences"><a class="header" href="#retour-dexpériences">Retour d'expériences</a></h1>
<p>Ce chapitre contient les retours d'expériences des années précédentes.</p>
<p>Le but est de garder une trace de ce qui a été fait, des erreurs commises et des solutions trouvées. Cela permettra de ne pas refaire les mêmes erreurs et de gagner du temps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retour-expérience-2023-2024"><a class="header" href="#retour-expérience-2023-2024">Retour expérience 2023-2024</a></h1>
<h2 id="introduction-5"><a class="header" href="#introduction-5">Introduction</a></h2>
<p>Ce document est un retour d'expérience sur l'année 2023-2024.</p>
<h2 id="État-du-club-en-début-dannée"><a class="header" href="#État-du-club-en-début-dannée">État du club en début d'année</a></h2>
<p>D'un point de vue administratif, le club est en bonne santé, mais il y a peu de membres.</p>
<p>Cela fait 2 ans que le club a été relancé, mais toujours pas de robot fonctionnel pour la Coupe de France.</p>
<p>Les membres sont motivés, mais il y a peu de nouveaux membres.</p>
<p>Les formations ont été trop longues les années précédentes =&gt; les nouveaux membres ont abandonné et pas assez de temps pour faire un robot.</p>
<p>Changement de STM32 car elles ne sont plus disponibles =&gt; la bibliothèque Rust n'est plus compatible.</p>
<p>Une frustation s'est installée chez les membres car ils n'arrivent pas à faire un robot.</p>
<p>Problèmes avec la compétition VEX U =&gt; prendre une décision sur la participation à la compétition.</p>
<h2 id="définir-les-objectifs"><a class="header" href="#définir-les-objectifs">Définir les objectifs</a></h2>
<p>Les objectifs de l'année ont été définis en début d'année.</p>
<p><strong>Premières décisions:</strong></p>
<ul>
<li>Ne pas participer à la compétition VEX U</li>
<li>Participer à la Coupe de France 2024 et faire un robot qui se déplace</li>
</ul>
<p><strong>Objectifs de l'année:</strong></p>
<ul>
<li>Participer à la Coupe de France 2024</li>
<li>Faire un robot qui se déplace</li>
<li>Créer des modules réutilisables pour les années suivantes</li>
<li>Attirer de nouveaux membres</li>
<li>Faire des formations plus courtes et plus efficaces</li>
<li>Augmenter la communication entre les pôles</li>
<li>Augmenter la cohésion de l'équipe</li>
<li>Augmenter la communication externe</li>
</ul>
<h2 id="décisions-prises-pour-atteindre-les-objectifs"><a class="header" href="#décisions-prises-pour-atteindre-les-objectifs">Décisions prises pour atteindre les objectifs</a></h2>
<h3 id="organisation-de-léquipe"><a class="header" href="#organisation-de-léquipe">Organisation de l'équipe</a></h3>
<p>Comme on arrête la compétition VEX U, on a moins besoin de responsables.</p>
<p>Retour à une structure plus simple:</p>
<ul>
<li>Bureau : 3 personnes
<ul>
<li>Un président: <a href="https://github.com/BloodFutur">Ronan BONNET</a></li>
<li>Un trésorier: Matteo GEST</li>
<li>Un secrétaire: Triet</li>
</ul>
</li>
<li>Un responsable Coupe de France: Artur
<ul>
<li>Responsable électronique</li>
<li>Responsable informatique</li>
<li>Responsable mécanique</li>
</ul>
</li>
</ul>
<p>Les années précédentes, les responsables de pôles ne pouvaient pas être dans le bureau. Cette année, on a décidé de changer cela pour 2 raisons, simplifier la structure, et avoir des responsables de pôles plus impliqués dans le club et par manque de membres.</p>
<h3 id="gestion-de-la-communication-1"><a class="header" href="#gestion-de-la-communication-1">Gestion de la communication</a></h3>
<p>La communication continue de se faire principalement sur Discord. Nous avons invités les nouveaux membres.</p>
<p><strong>Ajouts</strong>:</p>
<ul>
<li>Réunion plus régulière avec l'ensemble des membres pour faire un point sur l'avancement du projet et avoir un retour des membres</li>
</ul>
<h3 id="gestion-des-connaisances"><a class="header" href="#gestion-des-connaisances">Gestion des connaisances</a></h3>
<ul>
<li>Continuer les formations mais plus courtes et plus efficaces, avec des exercices pratiques</li>
</ul>
<p><strong>Ajouts</strong>:</p>
<ul>
<li>Remettre en place une documentation pour garder une trace de ce qui a été fait, des erreurs commises et des solutions trouvées. Cela permettra de ne pas refaire les mêmes erreurs et de gagner du temps.</li>
<li>Demander aux membres de faire des retours d'expériences sur ce qu'ils ont fait</li>
</ul>
<h3 id="définir-larchitecture-du-projet"><a class="header" href="#définir-larchitecture-du-projet">Définir l'architecture du projet</a></h3>
<ul>
<li>Garder la même architecture que l'année précédente</li>
<li>Tester une base roulante avec des moteurs pas à pas</li>
</ul>
<h3 id="gestion-de-projet-1"><a class="header" href="#gestion-de-projet-1">Gestion de projet</a></h3>
<p>Difficultés rencontrées les années précédentes:</p>
<ul>
<li>Plein de mini-projets dans tous les sens</li>
<li>Pas d'intégration des modules entre eux</li>
<li>Pas de robot fonctionnel</li>
<li>Pas de priorisation des tâches</li>
<li>Manque de motivation des membres</li>
</ul>
<h3 id="stratégie-décidée"><a class="header" href="#stratégie-décidée">Stratégie décidée</a></h3>
<p>Tout d'abord on a décidé de faire une hiérarchisation des fonctionnalités du robot.</p>
<p><strong>Priorisation des fonctionnalités:</strong></p>
<ol>
<li>Se déplacer</li>
<li>Communiquer avec l'info et les autres modules</li>
<li>Se repérer sur le terrain</li>
<li>Stratégie basique hardcodée</li>
<li>Vision</li>
<li>Stratégie avancée</li>
</ol>
<p>On se focalise sur les tâches 1 avant d'attaquer les tâches 2, etc.</p>
<p>Une fois les tâches 1 terminées, on s'assure de l'intégration des modules entre eux. On les teste ensemble. On écrit de la documentation pour les modules. Puis on passe aux tâches 2, etc.</p>
<p>De cette manière, les membres sont plus motivés car ils voient le robot avancer. Ils peuvent aussi se concentrer sur un module à la fois.</p>
<h3 id="gestion-de-la-documentation-1"><a class="header" href="#gestion-de-la-documentation-1">Gestion de la documentation</a></h3>
<ul>
<li>Récupérer la documentation des années précédentes</li>
<li>Mettre à jour la documentation sur le site web</li>
<li>Mettre à jour la documentation au fur et à mesure de l'année</li>
</ul>
<h3 id="gestion-de-la-communication-externe"><a class="header" href="#gestion-de-la-communication-externe">Gestion de la communication externe</a></h3>
<ul>
<li>Mettre à jour le site web</li>
<li>Mettre à jour les réseaux sociaux</li>
<li>Faire des posts sur les réseaux sociaux pour montrer l'avancement du projet</li>
<li>Faire des posts sur les réseaux sociaux pour montrer les membres du club</li>
<li>Faire des événements pour montrer le club</li>
<li>Faire des événements avec le club info</li>
</ul>
<h2 id="problèmes-rencontrés"><a class="header" href="#problèmes-rencontrés">Problèmes rencontrés</a></h2>
<h3 id="problèmes-administratifs"><a class="header" href="#problèmes-administratifs">Problèmes administratifs</a></h3>
<ul>
<li>Changement du système de l'Amicale comparé aux années précédentes =&gt; perte de environ 3800€ de budget sur la stratégie de financement</li>
<li>Difficulté de communication avec l'Amicale</li>
<li>Pertes de temps pour les démarches administratives</li>
</ul>
<h3 id="problèmes-techniques"><a class="header" href="#problèmes-techniques">Problèmes techniques</a></h3>
<h4 id="base-roulante-avec-moteurs-pas-à-pas"><a class="header" href="#base-roulante-avec-moteurs-pas-à-pas">Base roulante avec moteurs pas à pas</a></h4>
<p>⚠️ TODO: mettre les problèmes rencontrés</p>
<h4 id="changement-de-stm32f103-vers-stm32g431"><a class="header" href="#changement-de-stm32f103-vers-stm32g431">Changement de STM32F103 vers STM32G431</a></h4>
<p><strong>Inconvenients:</strong></p>
<ul>
<li>La bibliothèque Rust n'est plus compatible</li>
<li>Les librairies développées les années précédentes ne sont plus compatibles</li>
<li>Les membres ne connaissent pas les STM32G431 et pas trop le C</li>
<li>Le C peut apporter plien de problèmes de mémoire, de pointeurs, etc.</li>
</ul>
<p><strong>Avantages:</strong></p>
<ul>
<li>Plus simple à programmer</li>
<li>Plus de ressources sur internet</li>
</ul>
<h4 id="problèmes-de-communication-entre-stm32-et-raspberry-pi"><a class="header" href="#problèmes-de-communication-entre-stm32-et-raspberry-pi">Problèmes de communication entre STM32 et Raspberry Pi</a></h4>
<p><strong>Problème:</strong></p>
<ul>
<li>La communication entre les STM32 et la Raspberry Pi ne fonctionne pas</li>
<li>La documentation sur les BUS CAN du club ne permet pas de faire fonctionner le bus CAN</li>
<li></li>
</ul>
<p><strong>Solution:</strong>
Refaire circuit pour faire communiquer les STM32 entre elles.
Voir <a href="retour_dexperiences/retour_dexperiences/../../informatique/communication.html#exemple-de-connexion-entre-deux-stm32">circuit</a>. Perte de temps énorme (environ 3 mois).</p>
<h2 id="résultats-et-productions"><a class="header" href="#résultats-et-productions">Résultats et productions</a></h2>
<h3 id="base-roulante-avec-moteurs-pas-à-pas-1"><a class="header" href="#base-roulante-avec-moteurs-pas-à-pas-1">Base roulante avec moteurs pas à pas</a></h3>
<p>⚠️ TODO: Mettre les résultats, ce qui a été fait, ce qui n'a pas été fait</p>
<h3 id="base-roulante-avec-moteurs-dc"><a class="header" href="#base-roulante-avec-moteurs-dc">Base roulante avec moteurs DC</a></h3>
<p>⚠️ TODO: Mettre les résultats, ce qui a été fait, ce qui n'a pas été fait, liens vers les pages de la doc</p>
<h3 id="bus-can-fonctionnel-entre-stm32g431"><a class="header" href="#bus-can-fonctionnel-entre-stm32g431">Bus CAN fonctionnel entre STM32G431</a></h3>
<p>⚠️ TODO: Mettre les résultats, ce qui a été fait, ce qui n'a pas été fait, liens vers les pages de la doc</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retour-dexpérience-année-2022-2023"><a class="header" href="#retour-dexpérience-année-2022-2023">Retour d'expérience année 2022-2023</a></h1>
<p>⚠️ TODO: à compléter</p>
<h2 id="introduction-6"><a class="header" href="#introduction-6">Introduction</a></h2>
<h2 id="gestion-de-projet-2"><a class="header" href="#gestion-de-projet-2">Gestion de projet</a></h2>
<h2 id="technique"><a class="header" href="#technique">Technique</a></h2>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retour-expérience-2021-2022"><a class="header" href="#retour-expérience-2021-2022">Retour expérience 2021-2022</a></h1>
<h2 id="introduction-7"><a class="header" href="#introduction-7">Introduction</a></h2>
<p>Ce document est un retour d'expérience sur la Coupe de France 2022 et la compétition VEX U.</p>
<p>Le club a été relancé cette année pour participer à la Coupe de France 2022. Nous avons donc dû repartir de zéro pour tout ce qui est électronique, informatique et mécanique.</p>
<p>Afin de relancer le club, nous avons également participé à la compétition VEX U.</p>
<h2 id="gestion-de-projet-3"><a class="header" href="#gestion-de-projet-3">Gestion de projet</a></h2>
<h3 id="organisation-de-léquipe-1"><a class="header" href="#organisation-de-léquipe-1">Organisation de l'équipe</a></h3>
<p>Cette année-là, nous étions environ une vingtaine de membres. Le club était structuré de la manière suivante :</p>
<ul>
<li>Bureau : 3 personnes
<ul>
<li>Un président (Max)</li>
<li>Un trésorier (Andrea)</li>
<li>Un secrétaire (Ronan)</li>
</ul>
</li>
<li>Responsables de pôle : 7 personnes
<ul>
<li>Responsable Coupe de France
<ul>
<li>Responsable électronique</li>
<li>Responsable informatique</li>
<li>Responsable mécanique</li>
</ul>
</li>
<li>Responsable VEX U
<ul>
<li>Responsable informatique</li>
<li>Responsable mécanique</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>La répartition des rôles a été faite en fonction des affinités de chacun.</p>
<p><strong>Résultat :</strong></p>
<p>Cette organisation a plus ou moins bien fonctionné. Les responsables de pôle ont pu se concentrer sur leur pôle et ont pu faire avancer les choses. Cependant, il y a eu un manque de communication entre les pôles. Tout le monde n'était pas au courant de ce que faisait les autres.</p>
<p>Trop de responsables pour peu de membres a également été un problème.</p>
<h3 id="gestion-de-la-communication-2"><a class="header" href="#gestion-de-la-communication-2">Gestion de la communication</a></h3>
<p>La communication s'est faite principalement sur Discord. Nous avons créé un serveur Discord pour le club. Les membres ont été invités à rejoindre le serveur mais ils ne l'ont pas tous fait.</p>
<h3 id="définir-les-objectifs-1"><a class="header" href="#définir-les-objectifs-1">Définir les objectifs</a></h3>
<p>Les objectifs de l'année ont été définis en début d'année. Nous avons décidé de participer à la Coupe de France 2022 et à la compétition VEX U.</p>
<p>Pour la Coupe de France, les objectifs étaient les suivants :</p>
<ul>
<li>Participer à la Coupe de France 2022</li>
<li>Faire un robot qui se déplace</li>
<li>Créer des modules réutilisables pour les années suivantes</li>
</ul>
<p>Pour la compétition VEX U, les objectifs étaient les suivants :</p>
<ul>
<li>Participer à la compétition VEX U</li>
<li>Attirer de nouveaux membres</li>
</ul>
<p><strong>Résultat :</strong></p>
<p>Nous avons participé à la Coupe de France 2022 et à la compétition VEX U.</p>
<p>Pour VEX U, nous avons réussi à attirer de nouveaux membres et la compétition s'est bien passée.</p>
<p>Pour la Coupe de France, nous avons pas réussi à avoir un robot qui se déplace pour la compétition. Repartir de zéro a été plus long que prévu. Nous avons cependant réussi à créer des modules réutilisables pour les années suivantes.</p>
<h2 id="technique-1"><a class="header" href="#technique-1">Technique</a></h2>
<h3 id="définir-larchitecture-du-projet-1"><a class="header" href="#définir-larchitecture-du-projet-1">Définir l'architecture du projet</a></h3>
<p>L'architecture du projet a été définie en début d'année. Nous avons décidé de faire un robot modulaire. Le robot est composé de plusieurs modules qui peuvent être assemblés pour former le robot final.</p>
<p><strong>Choix techniques:</strong></p>
<ul>
<li>STM32 pour la partie électronique</li>
<li>Raspberry Pi pour la partie informatique</li>
<li>Une base roulante simple</li>
<li>Un bras robotique</li>
<li>Un système de pompe à vide</li>
<li>Communication entre les modules via le bus CAN</li>
<li>Détection de l'adversaire via un LIDAR</li>
</ul>
<p><strong>Résultat :</strong></p>
<p>L'architecture du projet a bien été définie car il est utilisé encore aujourd'hui. Cette architecture se retrouve également dans de nombreux projets industriels et dans le projet GEI-car.</p>
<h3 id="Électronique"><a class="header" href="#Électronique">Électronique</a></h3>
<ul>
<li>Difficulté à trouver des composants</li>
<li>Difficulté à flasher les STM32</li>
<li>Difficulté à communiquer avec les STM32</li>
<li>Difficulté à utiliser le bus CAN</li>
<li>Difficulté à faire des cartes électroniques sans court-circuit</li>
</ul>
<p><strong>Résultat :</strong></p>
<ul>
<li>Quelques cartes électroniques ont été faites mais comportaient des erreurs. Elles n'ont pas pu être utilisées.</li>
<li>Code pour flasher les STM32 fonctionnel</li>
<li>Code pour base roulante avec PID fonctionnel</li>
<li>Code pour utiliser les Herkulex fonctionnel</li>
<li>Can fonctionnel entre STM32</li>
<li>Trop de court-circuit sur les cartes électroniques</li>
</ul>
<h3 id="informatique-1"><a class="header" href="#informatique-1">Informatique</a></h3>
<p>Peu de choses ont été faites car difficultés en électronique et mécanique.</p>
<h3 id="mécanique-1"><a class="header" href="#mécanique-1">Mécanique</a></h3>
<ul>
<li>Difficulté à trouver des membres faisant de la mécanique</li>
<li>Oublié de vérifier les règles de la Coupe de France</li>
</ul>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<h3 id="points-positifs"><a class="header" href="#points-positifs">Points positifs</a></h3>
<ul>
<li>Participation à la Coupe de France 2022</li>
<li>Participation à la compétition VEX U</li>
<li>Relance du club</li>
<li>Création d'une architecture modulaire</li>
<li>Création d'une base roulante</li>
<li>Création d'un bras robotique</li>
</ul>
<h3 id="points-négatifs"><a class="header" href="#points-négatifs">Points négatifs</a></h3>
<ul>
<li>Manque de communication entre les pôles</li>
<li>Manque de temps</li>
<li>Pas de robot fonctionnel pour la Coupe de France</li>
<li>Formation trop longue</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cette-section-garde-toutes-les-archives-de-doc-faite-auparavant"><a class="header" href="#cette-section-garde-toutes-les-archives-de-doc-faite-auparavant">Cette section garde toutes les archives de doc faite auparavant.</a></h2>
<div style="break-before: page; page-break-before: always;"></div><p><img src="pre_2021/images/com/logo18.png" alt="" title="Logo du Club Robot" /></p>
<h1 id="introduction-8"><a class="header" href="#introduction-8">Introduction</a></h1>
<p>Ce site internet contient la documentation du Club Robot de l'INSA Toulouse pour les parties électronique et informatique du robot.</p>
<p>Ce livre est rédigé avec <a href="https://github.com/rust-lang-nursery/mdBook">md-book</a>.</p>
<p>Le but de ce livre est de te guider pour l'installation des différents outils permettant de programmer au Club Robot.</p>
<p>Ce livre ne documentera pas le code du club, mais peut documenter les différents fichiers d'un projet. Il est là pour servir de référence en cas de problème et de questions vis à vis d'un fichier.</p>
<p>Sa lecture est préliminaire à la formation organisée en début d'année, et son but est de nous faire gagner du temps en vous faisant installer à la maison les outils de dévellopement.</p>
<p>Enfin, son écriture a commencé après Chocobot à la coupe de france de 2018 (Robot Cities).</p>
<p>Pour la suite du "livre", si on s'est occupé de t'installer linux sur ton ordinateur ou si tu as une version de Ubuntu récente (&gt;16.04) tu peux te considérer comme un utilisateur "standard" et tu n'as pas besoin de suivre les sections pour les <em>power user</em>.</p>
<p>Si jamais tu trouves des fautes d'orthographes, des erreurs, des remarques ou toutes autres formes de contribution à faire n'hésite <strong>surtout pas</strong>. Les sources de ce livre sont sur <a href="https://github.com/ClubRobotInsat/doc-elec">ce repertoire github</a>, et il n'y a pas besoin de <code>git</code> pour y apporter des modifications simples : l'interface en ligne de github te permet de modifier les fichiers textes et de créer ton premier <em>commit</em> en quelques secondes! Il faut juste penser à demander aux membres du club d'ajouter ton compte dans la liste des utilisateurs autorisés.</p>
<p>Enfin, la phrase la plus importante en informatique à garder en tête durant toute ta formation :</p>
<blockquote>
<p>Le mieux est l'ennemi du bien, surtout au club robot.</p>
</blockquote>
<p><em>Un illustre anonyme</em></p>
<p><img src="pre_2021/images/com/tester_doute.jpeg" alt="Tester c&#39;est douter" title="Tester c&#39;est douter" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outils-communs-1"><a class="header" href="#outils-communs-1">Outils Communs</a></h1>
<p>Cette section répertorie les principaux outils utilisés au Club Robot.</p>
<p>Ce tableau t'aidera à savoir quelles pages t'intéressent en fonction de ton pôle de prédilection :</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><a href="pre_2021/outils_communs/outils_communs/git.html">git</a></th><th style="text-align: center"><a href="pre_2021/outils_communs/outils_communs/ide.html">CLion</a></th><th style="text-align: center"><a href="pre_2021/outils_communs/info/outils/cmake.html">CMake</a></th><th style="text-align: center"><a href="pre_2021/outils_communs/elec_mat/tools.html">Kicad</a></th></tr></thead><tbody>
<tr><td style="text-align: center">Informatique</td><td style="text-align: center">✔️</td><td style="text-align: center">✔️</td><td style="text-align: center">✔️</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Electronique software</td><td style="text-align: center">✔️</td><td style="text-align: center">✔️</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Electronique hardware</td><td style="text-align: center">✔️</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">✔️</td></tr>
<tr><td style="text-align: center">Mécanique</td><td style="text-align: center">✔️</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="dual-boot-avec-linux"><a class="header" href="#dual-boot-avec-linux">Dual Boot avec Linux</a></h1>
<p>Tu as probablement un ordinateur sous Windows. Cependant, développer sous ce système d'exploitation est compliqué donc on utilise des systèmes Linux au club.</p>
<p>Tu as différentes manières d'utiliser Linux :</p>
<ul>
<li>Utiliser <a href="https://www.virtualbox.org/">VirtualBox</a>, une machine virtuelle pour exécuter Linux à l'intérieur de Windows (cependant, ton ordinateur va devoir exécuter deux systèmes d'exploitation en même temps donc il y aura des pertes de performance)</li>
<li>Installer un dual boot, c'est à dire qu'au démarrage de ton ordinateur, soit Windows soit Linux va être lancé, donc les performances de chaque OS vont être maximales mais ton disque dur aura une partie attribuée à Windows et une autre à Linux.</li>
</ul>
<p>Ce tuto est là pour t'expliquer comment installer un environnement sympa sous Linux.</p>
<h2 id="préliminaires-sous-windows-1"><a class="header" href="#préliminaires-sous-windows-1">Préliminaires sous Windows</a></h2>
<p>Avant tout, il faut faire quelques réglages sous Windows pour permettre l'installation d'un nouveau système d'expoitation (Windows n'aime pas trop partager un ordinateur). Pense aussi à sauvegarder toutes les données importantes ailleurs que sur ton PC. Je n'ai jamais eu de problème avec une installation de Linux, mais comme d'habitude, quand on joue avec les partitions de son disque dur, on prend des précautions (panne de courant/batterie pendant une étape critique par exemple).</p>
<ul>
<li><strong>Désactiver la mise en veille prolongée :</strong> par défaut, Windows ne s'éteint pas quand on le lui dit mais rentre en veille prolongée. Ceci est totalement inutile depuis qu'il y a des disques SSD, et ça empèche de démarrer sous un autre OS
<ul>
<li>ouvrir un terminal avec les droits administrateur (clic droit sur le logo windows, shell)</li>
<li>entrer la commande <code>powercfg -h off</code></li>
</ul>
</li>
<li><strong>Partitionner le disque dur :</strong> afin d'éviter tout problème de partionnement à cause de la fragmentation Windows, il vaut mieux utiliser directement les outils de Windows :
<ul>
<li>appuyer sur <code>Windows + R</code></li>
<li>saisir <code>diskmgmt.msc</code></li>
<li>clic droit sur le volume à partitionner (<em>Disque 0</em>) et sélectionner <code>Réduire le volume</code></li>
<li>choisir la taille de la partition désirée (Ubuntu demande 15Go minimum et recommande 25Go ; si tu as de la place tu peux faire une nouvelle partition à <code>40Go</code> pour être large)</li>
</ul>
</li>
</ul>
<p>Ton disque dur a maintenant un espace inutilisé, il est temps de l'utiliser !</p>
<h2 id="choix-du-système-linux-1"><a class="header" href="#choix-du-système-linux-1">Choix du système Linux</a></h2>
<p>Il te faut à présent choisir quel nouveau système d'exploitation utiliser. <strong>Linux</strong> est un <a href="https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg">univers très vaste</a>, que l'on peut sommairement classer :</p>
<ul>
<li>les systèmes basés sur les fichiers <code>.rpm</code>
<ul>
<li>CentOS</li>
<li>Fedora</li>
<li>openSUSE</li>
</ul>
</li>
<li>les systèmes dérivant de <code>Debian</code>
<ul>
<li><strong>Ubuntu</strong></li>
<li>Kali Linux</li>
</ul>
</li>
<li>les systèmes basés sur le <em>packet manager</em> <code>pacman</code>
<ul>
<li>Arch Linux</li>
<li><strong>Manjaro</strong></li>
</ul>
</li>
</ul>
<p>Tu peux demander des conseils aux membres si tu ne sais pas quel OS prendre, ils pourront même t'en faire essayer plusieurs !</p>
<h3 id="ubuntu-1804"><a class="header" href="#ubuntu-1804">Ubuntu 18.04</a></h3>
<p>Si tu n'as aucune idée de quel système choisir, je te conseille <a href="https://www.ubuntu.com/download/desktop">Ubuntu 18</a>, un système communautaire LTS (<em>Long Term Supported</em>) qui est très simple à prendre en main et pour laquelle les nombreux forums répondent à toutes tes questions.</p>
<p>Pour l'installer, il te suffit de <a href="https://www.ubuntu.com/download/desktop/thank-you?country=US&amp;version=18.04.1&amp;architecture=amd64">télécharger l'ISO</a> et la mettre sur une clef USB.</p>
<p><strong>! Attention !</strong>
Sauvegarde toutes les données sur ta clé USB avant de continuer ! Ta clef sera effacée par la suite (mais tu pourras la réinitialiser après avoir installé Linux, puis remettre tes données dessus ensuite).</p>
<p>Par "mettre sur une clef USB", on entend "flasher une image disque", mais c'est un terme barbare. Ici il ne te sera expliqué que comment faire.
Le moyen le plus simple est d'utiliser <a href="https://etcher.io/">Etcher</a>. C'est un logiciel open source et compatible sur Windows, Mac et Linux. Sa grande qualité est d'être <strong>tres</strong> simple à utiliser.</p>
<p>Une fois installé et lancé, il n'y a littéralement que quatre clics à faire :</p>
<ul>
<li>"Select Image" t'invite a choisir l'ISO que tu as déjà téléchargé.</li>
<li>"Select Drive" te demande de choisir le disque (clef USB dans notre cas) à flasher. C'est a dire qu'il sera <strong>formatté</strong> ( ! toutes les données dessus seront perdues !) puis que l'ISO y sera correctement installé. Cette étape requiert de savoir ce que l'on fait : il faut être <strong>absolument</strong> certain que le nom et la capacité du disque choisi correspondent à ta clef USB, et <strong>surtout pas à ton disque dur</strong>. Normalement Etcher est bien fait, et refuse de continuer si choisit un disque à ne pas toucher, mais il vaut mieux être trop prudent.</li>
<li>"Flash!" lance l'opération et raconte ce qu'il fait à ta clef au fur et à mesure.</li>
</ul>
<p>Si tout c'est bien passé, ta "Live-USB" est prête à l'emploi. La suite dépend de ton ordinateur et de la distribution que tu veux installer.</p>
<h3 id="manjaro-linux"><a class="header" href="#manjaro-linux">Manjaro Linux</a></h3>
<p>Pour les utilisateurs un peu plus confirmés, je peux aussi conseiller <a href="https://manjaro.org/get-manjaro/">Manjaro</a>, qui se base sur Arch Linux. La configuration de ce système est totalement personnalisable et il existe de nombreuses variantes graphiques, en fonction de si tu préfères des systèmes avec un bureau ou la gestion de fenêtres comme <a href="https://forum.manjaro.org/t/manjaro-i3-17-1-11-17-1-12/51238">Manjaro i3</a>.</p>
<p>Là encore, tu peux télécharger l'ISO qui te convient puis le mettre sur une clef USB.</p>
<h2 id="installation-sur-ton-ordinateur-dun-dual-boot-1"><a class="header" href="#installation-sur-ton-ordinateur-dun-dual-boot-1">Installation sur ton ordinateur d'un dual boot</a></h2>
<p>À présent que tu es muni.e d'une clef bootable, tu peux la brancher sur ton ordinateur, appuyer sur la touche pour aller dans le BIOS (ça dépend du constructeur mais tu as de bonnes chances d'y parvenir en spammant <code>Échap</code>, <code>F2</code>, <code>F9</code> ou <code>F11</code>) puis modifier quelques paramètres :</p>
<ul>
<li>Désactive le <code>UEFI Secure Boot</code></li>
<li>Désactive le <code>Fast Start-Up</code></li>
<li>Change l'ordre de priorité pour booter afin de lancer ta clef USB en première</li>
</ul>
<p>Si tu as le moindre problème je te conseille d'aller voir un membre du club, mais si ton écran affiche des choses en relation avec Linux et non pas l'écran de démarrage de Windows c'est gagné !</p>
<p>Tu peux choisir de tester l'OS ou alors de l'installer directement. L'interface devrait être assez explicite ; il va juste te falloir réaliser une dernière manip sur la page des disques.</p>
<p>Pour être sûr.e que tout se passe bien, choisis <code>Something else</code> lorsqu'on te demande où installer le système Linux. Ensuite, dans l'espace libre, tu peux attribuer 2Go à une mémoire de type <code>swap</code> (ce qui permets de soulager la RAM si tu lances des applications qui consomment trop). Tu peux attribuer le reste de l'espace libre pour Linux avec <code>type: ext4</code> et <code>mount point: /</code> en formatant l'espace pour éviter tout problème ultérieur.</p>
<p>Finalise l'installation et redémarre ; si tu arrives sur une interface pour choisir entre Linux et Windows (c'est le <code>Grub 2</code>) tout marche comme il faut !!</p>
<h2 id="setup-de-linux-1"><a class="header" href="#setup-de-linux-1">Setup de Linux</a></h2>
<p>La première chose à faire est de mettre à jour ton système.</p>
<ul>
<li><strong>ArchLinux :</strong> <code>sudo pacman -Suy</code></li>
<li><strong>Debian :</strong> <code>sudo apt update &amp;&amp; sudo apt upgrade</code></li>
</ul>
<h3 id="installation-basique-1"><a class="header" href="#installation-basique-1">Installation basique</a></h3>
<p>Installons les paquets de base nécéssaire pour faire fonctionner les différents outils du club. Ouvre un terminal, et entres :</p>
<pre><code class="language-bash">sudo apt install git curl wget ntfs-3g python3 gcc gdb vim nano cmake
</code></pre>
<p>Les paquets installés sont les suivants :</p>
<ul>
<li>git	--&gt; un gestinnaire de version et de code</li>
<li>curl	--&gt; pour télécharger des objets en ligne de commandes</li>
<li>wget	--&gt; en gros, idem que curl</li>
<li>python3	--&gt; pour executer les scripts python3</li>
<li>gcc	--&gt; pour compiler du C/C++, toujours utile</li>
<li>gdb	--&gt; pour debugger du C/C++, toujours très utile</li>
<li>vim	--&gt; un éditeur de texte en ligne de commande, un peu compliqué mais complet (pour quitter: ESC &gt; :q! &gt; ENTER)</li>
<li>nano	--&gt; un éditeur de texte plus simple</li>
</ul>
<h2 id="installation-avancée"><a class="header" href="#installation-avancée">Installation avancée</a></h2>
<p><em>Note : Cette partie est falcultative et non recommandée si c'est votre première installation de linux.</em></p>
<p>Ensuite, tu peux installer différents paquets sympatiques :</p>
<ul>
<li><strong>Archlinux</strong></li>
</ul>
<pre><code class="language-bash">sudo pacman -S ntfs-3g wget curl zsh thunderbird firefox rofi numlockx python-pip

sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"

cd /tmp
git clone https://github.com/meskarune/i3lock-fancy.git
cd i3lock-fancy
sudo make install

sudo wget https://cht.sh/:cht.sh -O /usr/local/bin/cht.sh
sudo chmod o+x /usr/local/bin/cht.sh

sudo pip install cheat
</code></pre>
<ul>
<li><strong>Ubuntu</strong></li>
</ul>
<pre><code class="language-bash">sudo apt-get install ntfs-3g wget curl zsh thunderbird firefox python-pip

sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"

sudo wget https://cht.sh/:cht.sh -O /usr/local/bin/cht.sh
sudo chmod o+x /usr/local/bin/cht.sh
</code></pre>
<hr />
<p>Si tu as un disque / partition en commun entre Windows et Linux (pour partager tes documents et musiques par exemple), tu as la possibilité de <em>monter</em> ce disque à chaque lancement de Linux pour y avoir accès facilement :</p>
<ul>
<li><code>sudo blkid</code> te donne des informations sur tous les disques</li>
<li>copie le <code>UUID</code> de la partition en commun</li>
<li>rajoute la ligne <code>UUID=&lt;ton_UUID_copié&gt; /media/commun ntfs-3g auto,user,exec,rw 0 0</code> à la fin du fichier <code>/etc/fstab</code> (il faut ouvrir un éditeur de texte en <code>sudo</code>)</li>
<li>au prochain redémarrage, ton disque commun sera accessible dans <code>/media/commun/</code></li>
<li>tu pourras faire des liens symboliques pour accéder à tes dossiers facilement, par exemple pour tes documents :</li>
</ul>
<pre><code class="language-bash">cd ~
rm -rf Documents
ln -s /media/commun/Documents .
</code></pre>
<hr />
<p>Enfin, si tu veux avoir des exemples de fichiers de configuration pour <strong>vim</strong>, <strong>git</strong>, <strong>zsh</strong> ou encore <strong>i3</strong> sous Manjaro-i3, tu peux aller voir <a href="https://github.com/terae/dotfiles">ce dépôt GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-1"><a class="header" href="#git-1">Git</a></h1>
<p><em>Cette page s'adresse à tous les membres du Club.</em></p>
<p>On utilise un <a href="https://fr.wikipedia.org/wiki/Logiciel_de_gestion_de_versions">gestionnaire de versions</a> pour manager l'ensemble du code : <a href="https://git-scm.com/">git</a>.</p>
<p>Ce choix a de très nombreux avantages :</p>
<ul>
<li>L'évolution de tout le code est sauvegardée donc on peut rappeler une version antérieure d'un fichier à tout moment</li>
<li>Si on perd des fichiers ou que l'on se trompe, on peut facilement revenir à un état stable</li>
<li><code>git</code> permets de collaborer sur un même code, c'est à dire que plusieurs développeurs peuvent participer au code et le logiciel s'occupe de rassembler l'ensemble des modifications</li>
<li>On peut profiter de tous ces avantages avec très peu de travail supplémentaire</li>
</ul>
<h2 id="installation-de-git-1"><a class="header" href="#installation-de-git-1">Installation de <code>git</code></a></h2>
<p>Afin de bénéficier de tous les avantages de <code>git</code>, il n'y a rien de plus simple : il suffit d'exécuter la commande suivante.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install git
</code></pre>
<p><em><strong>Astuce :</strong></em> pour vérifier que l'installation d'une application a bien marché, tu peux appeler la commande <code>which</code> qui te retourne le chemin vers l'exécutable, ou encore l'exécuter avec le flag <code>--version</code> :</p>
<pre><code class="language-bash">$ which git
/usr/bin/git

$ git version
git version 2.11.0
</code></pre>
<h2 id="apprendre-à-utiliser-cet-outil"><a class="header" href="#apprendre-à-utiliser-cet-outil">Apprendre à utiliser cet outil</a></h2>
<h3 id="apprendre-en-ligne-1"><a class="header" href="#apprendre-en-ligne-1">Apprendre en ligne</a></h3>
<p><code>git</code> est un logiciel extrêmement pratique une fois qu'on l'a pris en main, alors voici ton premier travail à la maison : <a href="https://learngitbranching.js.org/">apprendre visuellement git</a>. Le tutoriel est multilangue, et si tu préfères suivre un tuto en français en voici un d'<a href="https://openclassrooms.com/courses/gerez-vos-codes-source-avec-git">OpenClassrooms</a>.</p>
<p>Vu qu'il sait faire de très nombreuses choses, ce n'est bien sûr pas la peine d'apprendre toutes ses commandes par coeur. Voici des <em>Cheat Sheets</em> qui vont te faire gagner du temps :</p>
<ul>
<li><a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf">Cheat sheet de GitHub (en)</a></li>
<li><a href="https://services.github.com/on-demand/downloads/fr/github-git-cheat-sheet.pdf">Chear sheet de GitHub (fr)</a></li>
<li><a href="https://www.git-tower.com/blog/git-cheat-sheet/">Cheat sheet de Tower</a></li>
</ul>
<h3 id="ba-ba-des-commandes-1"><a class="header" href="#ba-ba-des-commandes-1">B.A.-BA des commandes</a></h3>
<p>Si tu as besoin d'aide pour utiliser <code>git</code>, les forums de <a href="http://stackoverflow.com/">StackOverflow</a> te permettent de répondre à tes questions les plus complexes.</p>
<p>Ensuite, voici une <a href="https://git-scm.com/docs">documentation d'API</a> des différentes fonctions.</p>
<p>En général cependant, tu vas devoir utiliser le même socle de commandes et le but de ce paragraphe est de te lister le <em><strong>template</strong></em> de commandes à utiliser ; je t'invite néanmoins à aller lire la documentation de chacune de ces commandes pour voir à quel point elles peuvent être puissantes.</p>
<ol>
<li>
<p>Avant de commencer à travailler, il faut récupérer le travail réaliser par les autres développeurs. Si tu as déjà des <code>commit</code>s en local, tu peux spécifier le flag <code>--rebase</code> pour avoir une architecture linéaire ; sinon <code>git</code> va <code>merge</code>r la branche locale et celle distante même pour des intégrations triviales.</p>
<ul>
<li><code>git pull [--rebase]</code></li>
</ul>
</li>
<li>
<p>À présent, à toi de faire des modifications pour contribuer au dépôt. Une fois que tu as fini et que tu veux créer un paquet qui contient ta nouveauté, il faut demander à <code>git</code> de rajouter toutes tes modifications intéressantes. Tu peux également connaître les modfications que tu as faites soit fichier par fichier, soit ligne par ligne. Bien sûr, tu peux restreindre la recherche à un document ou à des fichiers en particulier en les rajoutant à la fin.</p>
<ul>
<li><code>git status</code> te liste tous les fichiers qui ont été modifiés / supprimés / créés</li>
<li><code>git diff</code> te montre toutes les additions et délétions dans le code pour l'ensemble de ces fichiers</li>
</ul>
</li>
<li>
<p>Il est temps de choisir les modifications que tu veux sauvegarder dans l'arborescence de <code>git</code>. Il y a plusieurs moyens d'y arriver en utilisant <code>git add</code> et <code>git reset</code> :</p>
<ul>
<li><code>git add *</code> te permets d'ajouter TOUTES les modifications, il ne faut donc pas l'utiliser si tu travailles sur plusieurs projets en même temps</li>
<li><code>git add &lt;file 1&gt; [file 2] [...]</code> ajoute les modifications de chaque fichier / dossier dans leur ensemble. Si tu crées un nouveau fichier, il faut utiliser cette méthode pour l'ajouter et non pas la suivante.</li>
<li><code>git add -p</code> permets de mixer <code>add</code> et <code>diff</code> ; il s'agit d'une méthode particulièrement efficace si tu as besoin de sauvegarder seulement quelques lignes et non pas l'ensemble des modifications sur un fichier. Une interface s'ouvre et tu peux choisir d'accepter avec <code>y</code> ou de refuser les modifications avec <code>n</code> ; d'autres commandes sont possibles notamment <code>q</code> pour quitter.</li>
<li><code>git reset</code> te permets d'annuler l'insertion des modifications dans la sauvegarde de <code>git</code> (mais il ne reset pas les modifications du fichier, rassure-toi). Tu peux également lui donner l'argument <code>-p</code> pour accéder à l'interface intéractive.</li>
</ul>
</li>
<li>
<p>Tu peux vérifier que tu as ajouter les bonnes modifications en appelant de nouveau</p>
<ul>
<li><code>git status</code> pour voir les fichiers</li>
<li><code>git diff --staged</code> pour voir les modifications dans le code</li>
</ul>
</li>
<li>
<p>Il est enfin temps de créer le 'paquet' de modifications, appelé <code>commit</code>. Afin de pouvoir s'y retrouver plus facilement, les <code>commit</code>s ont chacun un numéro unique (appelé hash ; il a cette tête : <code>44bf09d0a2c36585aed1c34ba2e5d958a9379718</code> et est généré automatiquement) et également un message que tu dois choisir pour expliquer ce à quoi il sert. C'est très intéressant de créer un <code>commit</code> par fonctionnalité, et donc qui modifie éventuellement plusieurs fichiers, afin de pouvoir relire l'historique ensuite. Pense donc à en réaliser plusieurs au cours de ton travail, tu pourras facilement revenir à des versions précédentes ce qui est très bénéfique !</p>
<ul>
<li><code>git commit -m &lt;message&gt;</code></li>
<li><code>git commit --amend</code> te permets de juste rajouter des modifications au dernier commit pour ne faire qu'un seul paquet avec les anciennes et nouvelles modifs.</li>
</ul>
</li>
<li>
<p>Maintenant que tu as créé plusieurs <code>commit</code>s, tu peux vérifier que tout s'est bien passé en faisant appel à l'historique. Tu pourras y observer le numéro de chaque commit, leur auteur, leur date de création ainsi que leur message d'accompagnement.</p>
<ul>
<li><code>git log</code></li>
</ul>
</li>
<li>
<p>Enfin, les modifications que tu viens de faire ont pour but d'être partagées aux autres développeurs et donc envoyés sur le dépôt distant de <a href="https://github.com/orgs/ClubRobotInsat/">github.com</a>. Normalement, si tu as bien suivi les étapes de clonage présentées un peu plus bas, tout devrait être déjà configuré pour n'avoir qu'à taper ceci :</p>
<ul>
<li><code>git push -u origin &lt;branch&gt;</code> la première fois pour demander à envoyer les <code>commit</code>s sur le flux <code>origin</code>, c'est à dire github, correspondant à la branche actuelle (par exemple <code>master</code>)</li>
<li><code>git push</code> les fois suivantes ; tout va marcher ensuite à condition d'avoir une connexion internet :wink:</li>
</ul>
</li>
</ol>
<p>Je n'ai pas parlé d'un certain nombre de commandes car tu ne devrais pas les utiliser quotidiennement. Voici une liste de fonctione néanmoins intéressantes dont tu peux aller voir la documentation :</p>
<ul>
<li><code>git branch</code> - notion que je n'ai que très peu abordée, <code>git</code> travaille avec des branches pour faciliter le travail sur plusieurs projets en parallèle</li>
<li><code>git checkout</code> - permets de se ballader d'une branche à une autre branche ou à un commit en particulier</li>
<li><code>git reset</code> - idél pour enlever les modifs d'un <code>git add</code> et pour supprimer des <code>commit</code>s foireux présents localement</li>
<li><code>git revert</code> - applique les modifications complémentaires à un commit, idéal pour annuler un commit foireux déjà envoyé sur le serveur</li>
<li><code>git merge</code> - permets à deux branches de fusionner ; fonctionnalité sympa pour travailler indépendamment sur un projet puis l'intégrer dans la branche principale une fois qu'il est fonctionnel</li>
<li><code>git rebase</code> - permets de copier des commits pour avoir une arborescence plus linéaire</li>
<li><code>git rebase -i</code> - fenêtre intéractive pour réorganiser les commits comme tu veux</li>
<li><code>cherry-pick</code> - copie un ensemble de commits à l'endroit actuel, ce qui simplifie l'utilisation d'un <code>git rebase</code></li>
<li><code>git stash</code> - mémorise des modifications dans un endroit à part ; ça te permets de sauvegarder un travail qui ne compile pas par exemple. Options intéressantes : <code>drop</code>, <code>pop</code>, <code>list</code>, <code>show</code>, <code>save &lt;NAME&gt;</code>, <code>-p</code>.</li>
<li><code>git tag</code> - marque permannante sur un commit pour y accéder n'importe quand (à sa création, il faut appeler <code>git push --follow-tags</code> pour le partager avec tout le monde).</li>
<li><code>git fetch</code> - télécharge les infos sur le dépôt distant ; contrairement à <code>git pull</code>, aucun <code>merge</code> n'est réalisé entre le dépôt localement et celui à distance, donc cette commande est très peu utilisée</li>
</ul>
<h2 id="création-dun-compte-github-1"><a class="header" href="#création-dun-compte-github-1">Création d'un compte <a href="https://github.com">GitHub</a></a></h2>
<p>Afin de partager notre travail, on utilise les serveurs de GitHub. Il s'agit d'un service web qui offre une interface graphique à <code>git</code> tout en permettant de récupérer les projets du Club n'importe où.</p>
<p>Il faut donc que tu te crées un compte sur le site : <a href="https://github.com/">github.com</a>.</p>
<p>Une fois que c'est fait, demande à un membre du Club de t'ajouter dans l'organisation <a href="https://github.com/orgs/ClubRobotInsat/">ClubRobotINSAT</a>.</p>
<h2 id="configuration-de-git-1"><a class="header" href="#configuration-de-git-1">Configuration de <code>git</code></a></h2>
<p>Il faut configurer ton ordinateur pour qu'il te connaisse, voici comment :</p>
<ol>
<li>Ton nom associé aux <code>commit</code>
<ul>
<li><code>git config --global user.name "[ton nom]"</code></li>
</ul>
</li>
<li>Ton adresse mail associée aux <code>commit</code> (de préférence celle utilisée lors de la création de ton compte GitHub)
<ul>
<li><code>git config --global user.email "[ton adresse mail]"</code></li>
</ul>
</li>
<li>Colorisation des lignes (pas obligatoire mais pratique)
<ul>
<li><code>git config --global color.ui auto</code></li>
</ul>
</li>
</ol>
<h2 id="2-méthodes-pour-cloner-les-dépôts-1"><a class="header" href="#2-méthodes-pour-cloner-les-dépôts-1">2 méthodes pour <code>clone</code>r les dépôts</a></h2>
<h3 id="méthode-simple-avec-https"><a class="header" href="#méthode-simple-avec-https">Méthode simple avec HTTPS</a></h3>
<p>Le clonage en HTTPS est le plus simple et le plus couramment utilisé. Il ne demande que le lien vers le dépôt pour le cloner, et lorsqu'une authentification est requise (clone d'un dépôt privé, push, ...) il faut entrer son identifiant du serveur git (dans notre cas, <a href="https://github.com">github.com</a>) ainsi que son mot de passe.</p>
<p>Voici comment récupérer le code de la partie <code>info</code> :</p>
<pre><code class="language-bash">git clone https://&lt;ton_login_github&gt;@github.com/ClubRobotInsat/info.git
cd info
</code></pre>
<h3 id="méthode-alternative-avec-ssh"><a class="header" href="#méthode-alternative-avec-ssh">Méthode alternative avec SSH</a></h3>
<p><a href="https://github.com">github.com</a> propose une autre fonctionnalité accéder au serveur par <a href="https://fr.wikipedia.org/wiki/Secure_Shell">SSH</a>. La mise en place de cette méthode est un peu plus longue que le simple protocole HTTPS, mais ça te permettra de t'affranchir de devoir entrer ton mot de passe et ton identifiant à chaque intéraction avec le serveur.</p>
<p>Je te laisse suivre les <a href="https://help.github.com/articles/connecting-to-github-with-ssh/">instructions détaillées</a> pour ajouter la clef SSH sur github.</p>
<p>Enfin, voici comment récupérer un dépôt :</p>
<pre><code class="language-bash">git clone git@github.com:ClubRobotInsat/info.git
cd info
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide-2"><a class="header" href="#ide-2">IDE</a></h1>
<p><em>Cette page s'adresse à la fois aux infos et aux élecs soft.</em></p>
<p>Comme tu as pu le constater, l'arborescence du code est assez complexe et il y a beaucoup de fichiers. Pour coder facilement, il existe des outils qui nous facilitent la vie : les <a href="https://fr.wikipedia.org/wiki/Environnement_de_d%C3%A9veloppement">environnements de dévelopement</a>, ou encore des IDE.</p>
<p>Dans ce guide, nous installerons un IDE pour le langage <a href="https://isocpp.org/">C++</a> qui est le langage utilisé pour la partie informatique du robot. Notre choix se porte sur CLion qui est développé par JetBrains. Il s'agit d'un IDE à la fois flexible, simple d'utilisation, multiplateforme et qui a la particularité d'utiliser nativement <a href="https://cmake.org/">CMake</a>, le système de build utilisé par notre code.</p>
<p>Cet IDE est normalement payant, mais une version d'éducation (licence valide 1 an, renouvelable tant que l'on est étudiant) est disponible.</p>
<h2 id="téléchargement-de-lide"><a class="header" href="#téléchargement-de-lide">Téléchargement de l'IDE</a></h2>
<p>Pour commencer, il faut :</p>
<ol>
<li>Se rendre sur la page de <a href="https://www.jetbrains.com/clion/download/">CLion</a> et télécharger la dernière version, ou <a href="https://www.jetbrains.com/toolbox/app/?fromMenu">télécharger la <strong>Toolbox App</strong></a> si tu veux utiliser des IDEs pour d'autres langages</li>
<li>Pendant le téléchargement, aller sur la page de <a href="https://www.jetbrains.com/shop/eform/students">jetbrains.com</a> pour demander une licence éducation. L'adresse mail à fournir est celle de l'INSA (<em>&lt;nom&gt;@etud.insa-toulouse.fr</em>) pour que JetBrains accepte de délivrer la licence.</li>
<li>Va voir ta boîte mail, un message contenant un lien de confirmation est arrivé : confirme ton adresse mail</li>
<li>Tu reçois enfin un autre mail avec les infos de la licence, qu'il faudra saisir dans CLion</li>
</ol>
<h2 id="lancement"><a class="header" href="#lancement">Lancement</a></h2>
<p>Une fois le téléchargement terminé, il ne reste plus qu'à configurer ton ordinateur pour exécuter l'IDE :</p>
<ol>
<li>Il faut extraire l'archive téléchargée sur le site de CLion et copier le dossier <code>&lt;clion-version&gt;</code> dans <code>/opt/clion</code>:
<pre><code class="language-bash">cd ~/Downloads
tar -xvf &lt;nom de l'archive d'installation&gt;
sudo cp &lt;nom du dossier extrait&gt; /opt/clion -R
</code></pre>
</li>
<li>On renomme le script de lancement <code>clion.sh</code> en <code>clion</code> parce que c'est plus joli (selon mes goûts, j'aime aussi le orange si jamais).
<pre><code class="language-bash">sudo mv /opt/clion/bin/clion.sh /opt/clion/bin/clion
</code></pre>
</li>
<li>Il faut maintenant ajouter le script de lancement de Clion à ta <a href="https://fr.wikipedia.org/wiki/Variable_d%27environnement">variable d'environnement</a> <code>$PATH</code>:
<pre><code class="language-bash">echo "export PATH=/opt/clion/bin:$PATH" &gt;&gt; ~/.bashrc
</code></pre>
Le <code>PATH</code> est une variable d'environnement qui contient une suite de chemins séparés par des deux points <code>:</code>.
La ligne ci-dessus concatène lors de l'ouverture d'un terminal <strong>bash</strong> à la variable <code>PATH</code> le chemin de lancement de CLion.</li>
<li>Tu peux maintenant ouvrir un terminal et taper :
<pre><code class="language-bash">clion
</code></pre>
Ou, si jamais tu n'a pas suivi l'étape de renommage :
<pre><code class="language-bash">clion.sh
</code></pre>
</li>
</ol>
<p><em><strong>Pour les utilisateurs d'un Ubuntu standard :</strong></em> Lorsque CLion est en cours d'exécution, son icône est affiché dans la barre des tâches à gauche. Pour le lancer plus rapidement, il te suffit de faire un click droit sur l'icône -&gt; 'Lock to Launcher'</p>
<p>Si jamais l'IDE se lance, tu viens d'installer avec succès CLion ! Sinon je t'encourage à venir montrer le message d'erreur aux gens du club.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="informatique-2"><a class="header" href="#informatique-2">Informatique</a></h1>
<p><img src="pre_2021/info//images/com/raspy.svg" alt="Raspberry PI 3 - Club Robot INSA Toulouse" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mise-en-place-1"><a class="header" href="#mise-en-place-1">Mise en place</a></h1>
<p>Dans cette section, nous allons installer pas à pas tous les outils pour pouvoir développer du code dans le pôle informatique du Club Robot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide-3"><a class="header" href="#ide-3">IDE</a></h1>
<p>Normalement, tu as déjà suivi les instructions de la section <a href="pre_2021/info/mise_en_place//outils_communs/ide.html">Outils Communs - IDE</a>, tu as donc l'IDE CLion déjà fonctionnel.</p>
<p>Si ce n'est pas le cas, reviens un peu en arrière et installe CLion !</p>
<h2 id="configuration-spécifiques-au-club-robot"><a class="header" href="#configuration-spécifiques-au-club-robot">Configuration spécifiques au Club Robot</a></h2>
<p>Il ne reste plus qu'une étape et la configuration de ton IDE sera finalisée pour la partie <code>info</code>.</p>
<p>Dans le menu <code>File -&gt; Settings</code>, dérouler l'item <code>Build, Execution, Deployment</code> et sélectionner <code>CMake</code>. Il faut ensuite remplir certains champs :</p>
<ul>
<li>dans <code>CMake options</code>, mettre le texte <code>-DDEBUG=on -DBITS=64</code> : on spécifie à <code>CMake</code> des flags supplémentaires qui sont utilisés par le projet</li>
<li>dans <code>Generation path</code>, mettre le texte <code>build</code></li>
<li>dans <code>Build options</code>, mettre le texte <code>-j 4</code> : on compile avec 4 coeurs (ou 8 si ton processeur en a 8)</li>
</ul>
<p>Enfin, pour pouvoir tester les IA via la liaison série (<a href="https://fr.wikipedia.org/wiki/RS-232">RS232</a>) en utilisant CLion, et sans nécessiter les droits <code>root</code>, il faut ajouter ton utilisateur au groupe ayant accès à la liaison série <code>dialout</code> :</p>
<pre><code class="language-bash">sudo usermod -a -G dialout &lt;NOM_UTILISATEUR&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="répertoire-de-travail-1"><a class="header" href="#répertoire-de-travail-1">Répertoire de travail</a></h1>
<p>On utilise <code>git</code> pour gérer plus efficacement le code. Si le nom de ce logiciel ne te dis rien, je te conseille de revenir un peu en arrière pour aller lire <a href="pre_2021/info/mise_en_place//outils_communs/git.html">cette page</a>.</p>
<h2 id="clonage-du-dépôt"><a class="header" href="#clonage-du-dépôt">Clonage du dépôt</a></h2>
<p>Si ce n'est pas déjà fait, je te conseille de te créer un dossier spécifique à tout le Club Robot, par exemple comme ceci :</p>
<pre><code class="language-bash">mkdir -p ~/ClubRobot
cd ~/ClubRobot
</code></pre>
<p>Ensuite, on a besoin de deux dossiers en informatique, un premier qui contient tout le code info et un second qui permets de créer des tables de simulation facilement.</p>
<p>En t'inspirant de ce que tu as appris pour <a href="pre_2021/info/mise_en_place//outils_communs/git.html#a2-m%C3%A9thodes-pour-cloner-les-d%C3%A9p%C3%B4ts">cloner des dépôts</a>, je t'invite à récupérer les deux dossiers :</p>
<ul>
<li>
<pre><code class="language-bash">git clone https://github.com/ClubRobotInsat/pytable.git
git clone https://github.com/ClubRobotInsat/info.git
cd info
</code></pre>
</li>
<li>
<pre><code class="language-bash">git clone git@github.com:ClubRobotInsat/pytable.git
git clone git@github.com:ClubRobotInsat/info.git
cd info
</code></pre>
</li>
</ul>
<p>Félicitations, te voilà possesseur de tout le savoir informatique du Club !</p>
<h2 id="fonctionnement-des-branches"><a class="header" href="#fonctionnement-des-branches">Fonctionnement des branches</a></h2>
<p>Comme tu peux le voir <a href="https://github.com/ClubRobotInsat/info/branches">sur la page GitHub</a>, on utilise plusieurs <code>branch</code>es en même temps. Cette fonctionnalité de <code>git</code> nous permets de travailler en parallèle sur plusieurs projets.</p>
<p>La branche <code>master</code> est protégée : on n'y mets que des versions totalement fonctionnelles <em>(cette branche ne nous sert par beaucoup)</em>.</p>
<p>Tout le code que nous écrivons passe par la branche <code>develop</code> donc je t'invite dès maintenant à te rendre dessus :</p>
<pre><code class="language-bash">git checkout develop
git pull
</code></pre>
<p>Il s'agit de notre branche principale de développement. Afin d'avoir une architecture propre pour s'y retrouver, on utilise des branches pour chaque fonctionnalité en cours de développement. L'objectif est de partir de <code>develop</code> qui est propre, basculer sur une branche temporaire pour développer la fonctionnalité puis <code>merge</code> ce nouveau code lorsqu'il est fonctionnel dans <code>develop</code>.</p>
<p>Prenons l'exemple d'un développement sur le simulateur :</p>
<pre><code class="language-bash">git checkout develop     # On se mets sur la branche mère `develop`
git checkout -b dev-simu # Création d'une nouvelle branche spécialement pour le simulateur à partir de `develop`
# MAKE YOUR CODE
git add -p               # Ajout des fonctionnalités
git commit               # Autant de commits que tu veux jusqu'à ce que ça marche
</code></pre>
<p>Une fois que tu es satisfait de ton code, tu as deux possibilités :</p>
<ul>
<li><code>git checkout develop &amp;&amp; git merge dev-simu</code> pour intégrer directement le code dans la branche principale ; il faut que tu sois sur de toi :wink:</li>
<li>Depuis <a href="https://github.com/clubrobotinsat/info/pulls">la page <strong>Pull requests</strong></a>, crée une nouvelle requête pour <code>merge</code> ta nouvelle branche <code>dev-simu</code> dans <code>develop</code>. Ça permets d'avoir une <em>review</em> d'autres personnes sur ton travail, ce qui ne fait jamais de mal. Le retour des autres membres te permets de perfectionner ton code, te faire penser à certaines choses qui n'apparaissent pas dans les tests unitaires par exemple ou encode de valider ton travail pour l'intégrer dans le code. Bien évidemment, cette manière de faire est très fortement recommandée !</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation"><a class="header" href="#compilation">Compilation</a></h1>
<p>Dans cette section, nous allons t'installer tous les outils qui te permettront de compiler le projet informatique.</p>
<h2 id="logiciels-nécessaires"><a class="header" href="#logiciels-nécessaires">Logiciels nécessaires</a></h2>
<p>On utilise les outils suivants :</p>
<ul>
<li><code>git</code> : gestionnaire de versions pour le code, que tu as déjà dû installer</li>
<li><code>cmake</code> : grâce aux différents <code>CMakeLists.txt</code>, le projet se compile très facilement en invoquant <code>cmake</code> puis <code>make</code> (nous verrons plus tard comment utiliser cet outil)</li>
<li><code>clang-format</code> : cet utilitaire permets d'homogéniser tout le code pour qu'il respecte la même norme d'écriture</li>
<li><code>libbox2d-dev</code>, <code>libirrlicht1.8</code> : ces librairies permettent d'utiliser le simulateur du club</li>
</ul>
<p>Heureusement, un script s'occupe d'installer tous ces outils et d'autres encore pour assurer la compilation sans erreur du projet. Voici comment l'appeler (en considérant que vous êtes dans le dossier <code>info</code>):</p>
<pre><code class="language-bash">scripts/install.sh tools
</code></pre>
<h2 id="applications-recommandées"><a class="header" href="#applications-recommandées">Applications recommandées</a></h2>
<h3 id="formattage-du-code"><a class="header" href="#formattage-du-code">Formattage du code</a></h3>
<p>Un <em>hook</em> permets de lancer un script à chaque commit pour formater le code comme il faut :</p>
<pre><code class="language-bash">scripts/install.sh format
</code></pre>
<h3 id="gcc-recent-en-tant-que-compilateur"><a class="header" href="#gcc-recent-en-tant-que-compilateur"><em>gcc</em> recent en tant que compilateur</a></h3>
<p>Cette section ne s'applique que si tu as eu un problème lors de l'exécution du script d'installation, pour <code>gcc-7</code> et <code>g++-7</code>.</p>
<p>Pour pouvoir compiler l'ensemble du code, il te faut un compilateur supportant <code>C++ 17</code>, donc au minimum <code>g++-7</code>.</p>
<h4 id="version-7"><a class="header" href="#version-7">version 7</a></h4>
<p>Si tu es sur un ancien Ubuntu (avant 17.04) :</p>
<pre><code class="language-bash">sudo add-apt-repository ppa:ubuntu-toolchain-r/test
</code></pre>
<p>Sinon :</p>
<pre><code class="language-bash">sudo add-apt-repository ppa:jonathonf/gcc-7.1
</code></pre>
<p>Puis :</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install gcc-7 g++-7
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 70 --slave /usr/bin/g++ g++ /usr/bin/g++-7
</code></pre>
<p>Si tu es sur Ubuntu 18, tu peux même installer <code>g++-8</code> :</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install gcc-8 g++-8
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-8
</code></pre>
<h4 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-compilation</a></h4>
<p>Pour pouvoir compiler du code qui sera compris par la raspberry (et pas que par ton ordinateur), tu vas avoir besoin d'autres versions de gcc. Pour les installer, tape simplement :
<code>sudo apt install g++-8-arm-linux-gnueabihf gcc-8-arm-linux-gnueabihf</code></p>
<h2 id="autres-installations"><a class="header" href="#autres-installations">Autres installations</a></h2>
<h3 id="lib-wiimote"><a class="header" href="#lib-wiimote">Lib Wiimote</a></h3>
<p>Si tu veux pouvoir contrôler le robot à l'aide d'une WiiMote, il faut installer la librairie <code>WiiC</code> nécessaire aux démos :</p>
<pre><code class="language-bash">scripts/install.sh wii
</code></pre>
<h3 id="clang-en-tant-que-compilateur"><a class="header" href="#clang-en-tant-que-compilateur"><em>Clang</em> en tant que compilateur</a></h3>
<p>Si tu veux utiliser un autre compilateur par défaut (<a href="https://clang.llvm.org/"><code>clang</code></a>), voici les commandes à utiliser :</p>
<pre><code class="language-bash">sudo apt-get install clang-3.8
sudo update-alternatives --install /usr/bin/c++ c++ /usr/bin/clang++-3.8 100
</code></pre>
<p>Cependant, tous les membres actuels utilisent <code>gcc</code> par défaut.</p>
<h3 id="petrilab"><a class="header" href="#petrilab">Petrilab</a></h3>
<p>Ce logiciel permets d'éditer des <a href="https://fr.wikipedia.org/wiki/R%C3%A9seau_de_Petri">réseaux de Petri</a>. Il a été développé en interne par <a href="https://github.com/rems4e">rems4e</a> et il nous permets de créer graphiquement des stratégies.</p>
<p>Son installation actuelle est vouée à évoluer prochainement pour le plus avoir les fichiers binaires directement dans le dépôt git, et les systèmes d'exploitation pris en charge pour le moment sont les suivants :</p>
<ul>
<li>Ubuntu 14.04 <code>Trusty</code></li>
<li>Ubuntu 17.04 <code>Zesty</code></li>
<li>Ubuntu 18.04 <code>Bionic</code></li>
</ul>
<p>Pour avoir des informations sur ton OS, utilise la commande <code>lsb_release --all</code> ; s'il correspond à ceux disponibles, alors tu peux simplement appeler le script d'installation :</p>
<pre><code class="language-bash">scripts/install.sh petri
</code></pre>
<h2 id="problèmes-de-compilation-connus"><a class="header" href="#problèmes-de-compilation-connus">Problèmes de compilation connus</a></h2>
<ul>
<li>Problème de <em>clock skew</em> ? Il suffit de lancer <code>find -exec touch \{\} \;</code> dans le dossier <code>info</code>. Attention, cela peut être un petit peu long.</li>
<li>Problème lors d'un appel à <code>cmake</code> ? Commence par <em>clean</em> tous les fichiers générés : <code>Tools &gt; CMake &gt; Reset Cache and Reload Project</code>.</li>
</ul>
<h2 id="test-de-lenvironnement-de-travail"><a class="header" href="#test-de-lenvironnement-de-travail">Test de l'environnement de travail</a></h2>
<p>A présent que ton ordinateur est totalement configuré, il est temps de compiler le code !</p>
<p>L'interface de CLion peut paraître compliquée de prime abord, c'est pourquoi il ne faut pas hésiter à demander de l'aide à un membre du Club.</p>
<p>Une des fonctionnalités les plus utilisées est celle de la compilation intégrée. Pour cela, en haut à droite de la fenêtre, choisis la target <code>BuildAll</code>. Comme tu peux le voir, de nombreuses applications peuvent être compilées, et on veut actuellement s'assurer que tout compile chez toi. Ensuite, appuie sur le bouton à gauche de la liste déroulante pour compiler. Attention, ça va prendre un peu de temps.</p>
<p><img src="pre_2021/info/mise_en_place//images/ide/BuildAll.png" alt="CLion et sa fonctionnalité BuildAll" /></p>
<p>Si il n'y a pas de messages d'erreur, <em><strong>BRAVO</strong></em> tu viens d'installer avec succès tout l'environnement de travail !</p>
<p>Sinon, je te conseille de te rapprocher d'un membre du pôle informatique.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outils-informatiques"><a class="header" href="#outils-informatiques">Outils informatiques</a></h1>
<p>Si ce n'est pas déjà fait, je te conseille dans un premier temps d'installer <code>git</code> et <code>CLion</code> en allant  dans la section des <a href="pre_2021/info/outils//outils_communs/index.html">outils communs</a>.</p>
<p>Le code informatique a une certaine taille (700 fichiers pour 200.000 lignes de code) et l'ensemble des fichiers sont répartis dans une arborescence relativement dense.</p>
<p>De plus, n'oublie pas cette devise :</p>
<blockquote>
<p>Un bon informaticien est un informaticien fénéant.</p>
</blockquote>
<p>Ainsi, on proscrit au maximum les copiés/collés donc certaines parties de code sont empaquetés dans des <code>librairies</code> et sont réutilisées dans de très nombreux endroits du projet.</p>
<p>Enfin, il faut toujours se rappeler qu'un ordinateur est bête et qu'il n'exécute que ce qu'on lui dit de faire, donc pour compiler ton Intelligence Artificielle révolutionnaire qui va nous envoyer directement en finale, il ne suffit pas d'appeler le compilateur avec <code>g++ IA.cpp</code> mais il faut donner les liens vers les librairies qui s'occupent des cartes électroniques, celles vers les outils mathématiques, spécifier quels répertoires sont utilisés pour compiler, éventuellement créer les librairies dynamiques associées et bien d'autres choses encore.</p>
<p>Afin d'éviter de t'infliger de telles soufrances, on utilise un utilitaire qui permets de gérer efficacement un tel projet grâce à <code>cmake</code>. On va ensuite détailler les librairies développées en interne au club pour faciliter la programmation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake"><a class="header" href="#cmake">CMake</a></h1>
<p><code>cmake</code> est un utilitaire open-source et multi-plateformes qui permet indépendemment du compilateur de générer des fichiers utilisables pour la compilation. De plus, l'IDE <a href="https://www.jetbrains.com/clion/">CLion</a> utilise nativement <code>cmake</code>, ce qui veut dire qu'il va te faire gagner énormément de temps à chaque fois que tu travailleras avec un projet configuré avec <code>cmake</code>.</p>
<p>Son installation est très simple, il te suffit d'exécuter</p>
<pre><code class="language-bash">sudo apt-get install cmake
</code></pre>
<h2 id="explications-du-fonctionnement"><a class="header" href="#explications-du-fonctionnement">Explications du fonctionnement</a></h2>
<p><code>cmake</code> est à utiliser avec le programme <code>make</code> (tu n'as pas à l'installer en plus, il est déjà présent sur ton ordinateur).</p>
<p>À l'origine, les projets en <code>C</code> étaient compilés avec <code>make</code> grâce à des fichiers de configuration, des <code>Makefile</code>. Pour te donner une idée de ce à quoi ils ressemblent, voici un exemple (qui n'a rien à voir avec le Club Robot) :</p>
<pre><code class="language-make">CC        := gcc
LD        := gcc

vpath %.c $(SRC_DIR)

define make-goal
$1/%.o: %.c
	$(CC) -std=gnu99 -Wall -m32 -g -I $(INCLUDES) -c $$&lt; -o $$@
endef

.PHONY: all checkdirs clean

all: checkdirs build/client

build/client: $(OBJ_CLI)
	$(LD) -m32 $^ -o $@ -lm -lpthread -g

checkdirs: $(BUILD_DIR)

$(BUILD_DIR):
	@mkdir -p $@

clean:
	@rm -rf $(BUILD_DIR)

distclean:
	@rm -rf $(BUILD_DIR)
	@-rm -f *.tar.gz || true

$(foreach bdir,$(BUILD_DIR),$(eval $(call make-goal,$(bdir))))
</code></pre>
<p>Si tu es en train de te dire que c'est illisible, c'est normal et tu n'as pas à apprendre cette syntaxe rassure-toi.</p>
<p>En effet, l'objectif de <code>cmake</code> et de rajouter une surcouche à l'étape de compilation en permettant au programmeur d'écrire dans un anglais plus lisible (c'est à dire qu'il rajoute un couche d'abstraction).</p>
<p>Ainsi, tu vas travailler avec des fichiers de configuration nommés <code>CMakeLists.txt</code>. Voici un petit exemple du fichier qui gère tout le code du robot principal :</p>
<pre><code class="language-cmake">set(ROBOT_PRINC_SOURCE
        ../Commun/Strategie.cpp
        librobot/Robot.cpp
        librobot/MecaManager.cpp
        librobot/Strategie.cpp
        #librobot/Ascenseur.cpp
        petri/Deplacement.cpp
        petri/Servo.cpp
        petri/Moteur.cpp
        petri/Utils.cpp
        petri/PetriCommon.cpp
        librobot/StrategyGenerator/MagicStrategy.cpp)

add_library(robotPrincipal STATIC ${ROBOT_PRINC_SOURCE})
add_library(robotPrincipalInterfaceElec STATIC ${ROBOT_PRINC_SOURCE})

target_link_libraries(robotPrincipal Cartes Robot Strategie)
target_link_libraries(robotPrincipalInterfaceElec Robot_Interfacer_Elec Cartes Strategie)

add_executable(debug_calibration_depla debug/CalibrationDepla.cpp)
target_compile_options(debug_calibration_depla PUBLIC -Wno-deprecated)
target_link_libraries(debug_calibration_depla robotPrincipal)

include_directories(/usr/local/include/wiic/)

set(wiimote_sources IA/IAWiimote.cpp wiimote/Wiimote.cpp)
add_executable(IAWiimote ${wiimote_sources})
include_directories(/usr/local/include/wiic/)

add_executable(IAPrincipal IA/IAPrincipal.cpp)

if (RASPI)
	message(STATUS "Compiling IAPrincipal for the raspi")
	link_directories(/usr/arm-linux-gnueabihf/lib)
	target_link_libraries(IAPrincipal robotPrincipal PetriRuntime dl)

else()
	target_link_libraries(IAWiimote robotPrincipal wiicpp)
	target_link_libraries(IAPrincipal robotPrincipal)
endif()


add_executable(IATestDeplacement IA/IATestDeplacement.cpp)
target_link_libraries(IATestDeplacement robotPrincipal)

add_executable(IATestMeca IA/IATestMeca.cpp)
target_link_libraries(IATestMeca robotPrincipal)
</code></pre>
<p>Ensuite, une fois ces fichiers bien configurés, il te suffit d'aller dans la racine du dossier et de taper les commandes suivantes :</p>
<pre><code class="language-bash">mkdir -p build
cd build
cmake ..
make all
</code></pre>
<p>Tout est automatisé ; dans un premier temps les <code>Makefile</code>s vont être générés puis la commande <code>make</code> va lire ces fichiers pour les compiler grâce à <code>g++</code>. À la fin du processus (la compilation peut prendre jusqu'à une dizaine de minutes en tout), tu auras les fichiers binaires dans le dossier <code>/info/build</code> prêts à être exécutés.</p>
<h2 id="cheatsheet"><a class="header" href="#cheatsheet">Cheatsheet</a></h2>
<p>Ce paragraphe n'a bien sûr pas pour but d'être exhaustif, si tu as besoin de trouver des commandes spécifiques je te conseille d'aller voir <a href="https://gitlab.kitware.com/cmake/community/wikis/home">vers le wiki</a>.</p>
<h3 id="cmakeliststxt-principal"><a class="header" href="#cmakeliststxt-principal"><code>CMakeLists.txt</code> principal</a></h3>
<p>Pour une meilleure lisibilité, les configurations sont réparties dans chaque dossier. Il y a un <code>CMakeLists.txt</code> principal qui fait des configurations globales, et qui appelle ensuite les <code>CMakeLists</code> des sous-dossiers pour compartimenter le simulateur du robot par exemple.</p>
<ul>
<li><code>cmaks_minimum_required(VERSION 3.0)</code> - certaines fonctionnalités de <code>cmake</code> sont apparues dans les versions les plus récentes donc il faut toujours spécifier ce flag</li>
<li><code>project(root)</code> - définission du nom global du projet</li>
<li><code>option(&lt;NAME&gt; "&lt;comments&gt;" [DEFAULT])</code> - permets de donner des options pendant le lancement de <code>cmake</code>. Par exemple, avec l'<code>option(BITS "Build en 32 ou 64 bits" 64)</code>, on peut forcer la compilation en 32 bits avec l'appel <code>cmake .. -DBITS=32</code></li>
<li><code>add_definitions(&lt;DEFINITION&gt;)</code> - spécifie des définitions pour la compilation</li>
<li><code>add_subdirectory(&lt;PATH&gt;)</code> - appelle le <code>CMakeLists</code> d'un dossier enfant, par exemple celui du simulateur</li>
<li><code>link_directories(/usr/local/lib/)</code> - permets d'utiliser des librairies déjà existantes (par exemple, celle de <a href="http://box2d.org/">box2d</a> pour la gestion du moteur physique)</li>
</ul>
<h3 id="commandes-les-plus-utilisées"><a class="header" href="#commandes-les-plus-utilisées">Commandes les plus utilisées</a></h3>
<ul>
<li><strong>conditions</strong> :
<pre><code>   if(COLOR)
      set(CMAKE_COLOR_MAKEFILE ON)
   else()
      set(CMAKE_COLOR_MAKEFILE OFF)
   endif()
</code></pre>
Tests d'égalité : <code>${BITS} EQUAL 32</code>, <code>${CMAKE_CXX_COMPILER_ID} STREQUAL "^(Apple)?Clang$"</code></li>
<li><strong>créer des variables</strong> : <strong><code>set(&lt;NAME&gt; &lt;VALUE)</code></strong> ; exemple : <code>set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++14")</code> ; <code>set(FILES_SOURCE src/file1.cpp src/file2.cpp)</code></li>
<li><strong>librairies</strong>
<ul>
<li>Créer une librairie : <code>add_library(&lt;NAME&gt; STATIC ${FILES_SOURCE})</code></li>
<li>Lier une cible vers une librairie : <code>target_link_libraries(&lt;TARGET&gt; &lt;Lib1&gt; [Lib2] [...])</code></li>
<li>Récupérer les fichiers d'une librairie externe : <code>find_package(&lt;NAME&gt;)</code> (<a href="https://cmake.org/cmake/help/v3.0/command/find_package.html">wiki</a>)</li>
</ul>
</li>
<li>créer un nouvel exécutable : <code>add_executable(&lt;NAME&gt; &lt;file1&gt; [file2] [...])</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="petrilab-1"><a class="header" href="#petrilab-1">PetriLab</a></h1>
<p>Cette application a été créée en interne au Club Robot par <a href="https://github.com/rems4e">Rémi SAUREL</a>.</p>
<p>Au lieu d'écrire les IAs (Intelligences Artificielles) directement en ligne de code, ce qui peut rapidement être indigeste et surtout très peu maintenable pendant la coupe, le logiciel permets d'utiliser une interface graphique pour gérer toute la stratégie.</p>
<p>Ses avantages sont multiples :</p>
<ul>
<li>sans aucune notion en informatique, le logiciel est accessible à Monsieur Toulemonde</li>
<li>il gère la parallélisation des tâches (avancer en ouvrant des pinces tout en allumant des moteurs et en affichant du texte à l'écran), ce qui demanderait beaucoup de travail en lignes de code</li>
<li>on peut contrôler le robot depuis un mode <code>debug</code>, et donc construire la stratégie en live</li>
</ul>
<p>Le logiciel offre de nombreuses fonctionnalités, et cette page a pour but de t'expliquer comment l'utiliser.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Ce logiciel n'est pas en open-source et son installation n'est accessible qu'aux membres du Club Robot actuellement. De plus, il faut que tu aies Ubuntu 14.04, 17.04 ou 18.04.</p>
<p>Pour ce faire, après avoir <a href="pre_2021/info/outils//info/mise_en_place/repertoire_de_travail.html#clonage-du-d%C3%A9p%C3%B4t">cloner le dépôt info</a>, je t'invite à écrire cette ligne de commande :</p>
<pre><code class="language-bash">cd &lt;dossier info&gt;
scripts/install.sh petri
</code></pre>
<p>Le script d'installation va te demander un mot de passe ; à ce moment, demande à un membre du Club pour finaliser ton installation.</p>
<h2 id="prise-en-main-du-logiciel"><a class="header" href="#prise-en-main-du-logiciel">Prise en main du logiciel</a></h2>
<p><em><strong>TODO</strong></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explications"><a class="header" href="#explications">Explications</a></h1>
<p>La lecture de ce dossier va te permettre d'avoir un avant goût de l'architecture du code informatique. Je vais essayer de te donner les clefs pour comprendre comment te ballader dans l'arborescence et j'en profiterais pour entrer dans des détails plus techniques.</p>
<p>Bien entendu, ce tutoriel ne peut pas être exhaustif donc je te conseille d'aller voir le code directement et de lancer quelques exécutables pour comprendre leur fonctionnement, en utilisant les clefs de lecture que je vais te donner ici.</p>
<p>Bonne lecture !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-de-la-racine-du-projet-info"><a class="header" href="#architecture-de-la-racine-du-projet-info">Architecture de la racine du projet info</a></h1>
<p>Si tu as déjà regardé des projets C++, tu as certainement dû te rendre compte d'une certaine similaritude entre les dossiers tout en haut de l'architecture.
Cette 'normalisation' permets de passer d'un projet à un autre sans être perdu, et bien sûr une architecture bien structurée permets de gagner beaucoup de temps.</p>
<p>Je te propose un listing des items qui valent un coup d'oeil. Pour rappel, tu peux regarder le code durant ta lecture sur <a href="https://github.com/ClubRobotInsat/info">github</a> et tu peux cliquer sur les liens de chaque fichier.</p>
<h2 id="fonctionnement-de-git"><a class="header" href="#fonctionnement-de-git">Fonctionnement de <code>git</code></a></h2>
<p>Afin de proposer tous ses services, <code>git</code> a besoin d'un certain nombre de fichiers de configuration. Voici ses principaux ainsi que leur rôle :</p>
<ul>
<li>
<p><strong><code>.git/</code></strong> - Ce dossier contient toutes les informations utiles à <code>git</code> pour gérer le répertoire de travail. Je te conseille grandement de voir ce dossier comme une boîte noire et de ne pas y bidouiller des fichiers au risque de tout casser !</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/blob/develop/.gitignore"><code>.gitignore</code></a></strong> - Cette fonctionnalité de <code>git</code> est très intéressante : elle permets de demander au logiciel d'ignorer les fichiers spécifiés. Par exemple, on demande à <code>git</code> de ne pas <code>commit</code> les exécutables à chaque fois car ça n'a aucun intérêt et ça prendrait bien trop de place.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/.gitmodules"><code>.gitmodules</code></a> - On travaille avec d'autres projets open source et <code>git</code> propose des sous-modules qui correspondent à des dossiers dont l'origine vient d'un autre projet. On peut donc utiliser des librairies développées par d'autres personnes sans devoir passer du temps nous-mêmes à les créer. Attention cependant, si tu veux rajouter un sous-module au projet, il vaut mieux utiliser la commande <code>git submodule add &lt;lien&gt; [chemin local]</code> pour être sûr de bien tout configurer, puis il faut faire appel à <code>git submodule update --init --recursive --remote</code> pour mettre à jour tous les submodules (mais cette commande est automatisée à chaque appel à <code>cmake</code>).</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/.gitattributes"><code>.gitattributes</code></a> - On demande explicitement à <code>git</code> de considérer certains fichiers d'une certaine manière, par exemple tous les <code>.petri</code> comme des fichiers binaires (dans notre cas, ça évite de polluer l'affichage des commits sur github).</p>
</li>
</ul>
<h2 id="fichiers"><a class="header" href="#fichiers">Fichiers</a></h2>
<ul>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/blob/develop/LICENSE"><code>LICENSE</code></a></strong> - Ce fichier permets de spécifier la license utilisée pour la mise en open source du code ; on utilise la <a href="https://opensource.org/licenses/MIT">license MIT</a> et je t'invite à te renseigner sur les <a href="https://opensource.org/licenses">licenses d'open source</a> si le domaine de l'open source t'intéresse.</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/blob/develop/README.md"><code>README.md</code></a></strong> - Ce fichier est présent dans tous les répertoires hébergés sur <a href="https://github.com">github.com</a>. Il permets de savoir ce qu'il y a dans le dépôt, donner des explications sur le code, faire de la documentation ou encore donner des références vers d'autres projets ; la rédaction de ce fichier est très libre.</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/blob/develop/CMakeLists.txt"><code>CMakeLists.txt</code></a></strong> - Il s'agit du fichier de configuration de <a href="https://cmake.org/">cmake</a> global à tout le projet. Si ce n'est déjà fait, je t'invite à aller lire <a href="pre_2021/info/explications/info/outils/cmake.html">la documentation sur CMake</a> pour avoir une idée de ce que fait le logiciel.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/.clang-format"><code>.clang-format</code></a> - Tu ne vas pas forcément trouver ce fichier dans tous les projets, mais il est très pratique et permets d'appliquer des règles d'indentation à chaque <code>commit</code> pour s'assurer une homogénisation du code entre les développeurs.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/doxyconfig"><code>doxyconfig</code></a> - <a href="https://www.stack.nl/~dimitri/doxygen/">Doxygen</a> est un utilitaire qui permets de créer de la documentation à partir du code en utilisant ce fichier de configuration. Malheureusement, la documentation actuelle ne permets pas d'utiliser cet outil et un gros travail est à réaliser pour avoir une documentation fiable.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/TODO.txt"><code>TODO.txt</code></a> - Comme son nom l'indique, ce fichier permets de recenser les projets sur lesquels travailler pour l'année en cours.</p>
</li>
</ul>
<h2 id="dossiers"><a class="header" href="#dossiers">Dossiers</a></h2>
<ul>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/"><code>src/</code></a></strong> - Ce dossier regroupe tout le code source du projet informatique.</p>
</li>
<li>
<p><strong><code>build/</code></strong>, <code>build_arm/</code> - Ces dossiers sont le résultat de la (cross-)compilation du code et ils contiennent les exécutables. Bien entendu, ils ne sont présents que localement et <code>git</code> les ignore lors du processus de création des <code>commit</code>s.</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/tree/develop/third_parties/"><code>third_parties/</code></a></strong> - Sous-modules (librairies) utilisés par le projet sous la forme de clones. Tout est automatisé dès lors que tu exécutes <code>cmake ..</code> depuis un dossier <code>build</code>.</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/tree/develop/doc/"><code>doc/</code></a></strong> - Dossier qui reprends les documentation jusqu'à présent du projet. Ce dossier a pour vocation de disparaître pour laisser la place à la documentation que tu lis actuellement.</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/"><code>scripts/</code></a></strong> - Ce dossier est très intéressant dans le sens où il propose de nombreux scripts qui vont te faciliter la vie. Si tu veux des exemples concrets de l'utilisation des commandes <a href="https://www.gnu.org/software/bash/">bash</a> va vite lire ces scripts !</p>
<ul>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/build_arm.sh"><code>build_arm.sh</code></a> : Cross-compilation de <code>[all|principal|wii|test]</code> pour une archi ARM (la cible à compiler est à donner en paramètre).</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/install.sh"><code>install.sh</code></a> : Utilitaire pour t'aider à configurer ton ordinateur. Il est capable d'installer <code>[all|tools|petri|format|wii|raspi]</code> (paramètre à donner en argument) ; tu as déjà utilisé ce script pour la mise en place du dépôt normalement.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/pre-commit"><code>pre-commit</code></a> : script copié et automatiquement appelé à chaque commit dès lors que tu lances <code>scripts/install.sh format</code>, pour bien indenter ton code</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/send_file_to_rpi.sh"><code>send_file_to_rpi.sh</code></a> : se connecte au raspi et y envoie le fichier souhaité</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/send_ia_principale.sh"><code>send_ia_principale.sh</code></a> : cross-compile la target principale et envoi l'exécutable grâce au script précédent (script magique qui te mets bien 5 minutes avant un match !)</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/ssh_into_rpi.sh"><code>ssh_into_rpi.sh</code></a> : se connecte au raspi en SSH ; il faut préalablement configurer la connexion et brancher un câble RJ45 pour que ça marche</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/simu_launcher.sh"><code>simu_launcher.sh</code></a> : Utilitaire pour exécuter automatiquement le simulateur</p>
</li>
</ul>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/precompiled-libraries/"><code>precompiled-libraries/</code></a> - On utilise des librairies, notamment pour l'utilisation de la wii-mote. Pour plus de simplicité, on a cross-compilé ces librairies une fois pour toutes et on les stock ici afin de compiler plus facilement pour l'architecture ARM.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/cmake_modules"><code>cmake_modules/</code></a> - Répertorie des fonctions <code>cmake</code> pour aller chercher facilement des librairies sur ton ordinateur (les scripts restent très peu lisibles mais ils sont fonctionnels).</p>
</li>
</ul>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>J'espère que cette énumération te permets d'y voir un peu plus clair et que ça ne te donne pas envie d'oublier à jamais l'architecture info !</p>
<p>Les parties suivantes vont entrer dans les détails de ce qu'il y a dans le dossier <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/"><code>src/</code></a>, n'hésite pas à demander à un informaticien du club plus d'explications sur tout ce qu'il y a en 'annexe' du code source.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue-globale-du-projet"><a class="header" href="#vue-globale-du-projet">Vue globale du projet</a></h1>
<p>En étant à la racine du dossier, je t'invite à exécuter ces deux commandes :</p>
<pre><code class="language-bash">$ find src -type f | wc -l
678

$ find src -type f | xargs wc -l
186823 total
</code></pre>
<p>Il y a actuellement 678 fichiers source pour presque 200.000 lignes de code ; je te l'accorde c'est beaucoup.</p>
<p>Bien sûr, tous ces fichiers sont structurés et ce petit schéma peut te donner une idée des merveilles que tu peux trouver dans le dossier <code>src/</code> :</p>
<p><img src="pre_2021/info/explications/../../images/info/arborescence.png" alt="Arborescence du projet de manière graphique" /></p>
<p>Bien entendu, ce fichier est à mettre à jour en fonction des nouvelles fonctionnalités apportées, et si tu veux y participer il faut utiliser le logiciel <a href="https://wiki.gnome.org/Apps/Dia/">dia</a>.</p>
<pre><code>sudo apt-get install dia
</code></pre>
<p>Comme tu peux t'en apercevoir, il y a trois parties principales :</p>
<ul>
<li><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/commun/"><code>commun</code></a> - Tu peux y retrouver plein d'outils qui facilitent la programmation (manipulation d'unités physiques, constantes, manipulation de la communication, ...). Ce dossier est hyper important, mais je te conseille dans un premier temps d'utiliser les outils pour travailler sur le reste avant de te plonger dans ces librairies (certaines notions sont un peu compliquées et tout ce code n'est pas forcément directement lié à la robotique).</li>
<li><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/"><code>simulateur/</code></a> - Ce dossier regroupe l'ensemble des fichiers nécessaires pour mettre au point un simulateur graphique qui nous permet de tester la stratégie du robot avant de l'avoir en vrai, mécaniquement parlant. Si tu veux en savoir plus sur l'architecture du simulateur, elle est détaillée <a href="pre_2021/info/explications/simu.html">ici</a>.</li>
<li><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/"><code>robot/</code></a> - Il y a toute la stratégie, les interfaces de manipulation des actionneurs, ... C'est dans ce dossier que la majorité du code est écrit, et c'est bien sûr la partie la plus ancrée avec les autres pôles.</li>
</ul>
<h2 id="présentation-des-abstraction-informatiques-autour-du-robot"><a class="header" href="#présentation-des-abstraction-informatiques-autour-du-robot">Présentation des abstraction informatiques autour du robot</a></h2>
<p>En informatique, il y a de nombreuses couches d'abstraction qui séparent les cartes électroniques de l'IA du match. Je te propose un petit aperçu de ces couches, des explications supplémentaires et spécifiques à chaque couche te seront apportées en suivant.</p>
<p><em><strong>CE TABLEAU DOIT ÊTRE MIS À JOUR</strong></em></p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;border-color:#999;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
.tg .tg-uys7{border-color:inherit;text-align:center}
.tg .tg-us36{border-color:inherit;vertical-align:top}
.tg .tg-xrpy{font-weight:bold;font-size:18px;border-color:inherit;text-align:center}
</style>
<table class="tg">
  <tr>
    <th class="tg-xrpy" colspan="5">Couches d'abstraction</th>
    <th class="tg-xrpy">Explications brèves</th>
    <th class="tg-xrpy" colspan="2">Localisation</th>
  </tr>
  <tr>
    <td class="tg-uys7" colspan="5">Petrilab</td>
    <td class="tg-uys7"><span style="font-weight:bold">Interface graphique</span> pour créer les stratégies</td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Principal/petri/">src/robot/Principal/petri/</a></td>
  </tr>
  <tr>
    <td class="tg-uys7">IAPrincipale</td>
    <td class="tg-uys7">IAWiiMote</td>
    <td class="tg-uys7">IATests</td>
    <td class="tg-uys7">IATestLidar</td>
    <td class="tg-uys7">...</td>
    <td class="tg-uys7"><span style="font-weight:bold">Exécution</span> de la <span style="font-weight:bold">stratégie</span> / tests haut niveau</td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Principal/IA/">src/robot/Principal/IA/</a></td>
  </tr>
  <tr>
    <td class="tg-uys7" colspan="2">Stratégie</td>
    <td class="tg-uys7" colspan="3">MecaManager</td>
    <td class="tg-uys7"><span style="font-weight:bold">Couleur</span>, <span style="font-weight:bold">repère</span>, temps, tirette ; fonctions <span style="font-weight:bold">haut niveau</span></td>
    <td class="tg-uys7"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Principal/librobot/Strategie.h">Strategie.h</a></td>
    <td class="tg-us36"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Principal/librobot/MecaManager.h">MecaManager.h</a></td>
  </tr>
  <tr>
    <td class="tg-uys7" colspan="5">RobotPrincipal <span style="font-style:italic">(public RobotCommun)</span></td>
    <td class="tg-uys7"><span style="font-weight:bold">Assignation</span> des cartes pour <span style="font-weight:bold">2018</span><br></td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Principal/librobot/Robot.h">src/robot/Principal/librobot/Robot.h</a></td>
  </tr>
  <tr>
    <td class="tg-uys7" colspan="5">RobotCommun <span style="font-style:italic">(virtual)</span></td>
    <td class="tg-uys7"><span style="font-weight:bold">Com'</span>, <span style="font-weight:bold">adversaire</span>, <span style="font-weight:bold">déplacements</span>, cartes</td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Commun/Robot.h">src/robot/Commun/Robot.h</a></td>
  </tr>
  <tr>
    <td class="tg-uys7">Déplacement</td>
    <td class="tg-uys7">Servos</td>
    <td class="tg-uys7">Moteurs<br></td>
    <td class="tg-uys7">Évitement<br></td>
    <td class="tg-uys7">...</td>
    <td class="tg-uys7"><span style="font-weight:bold">Interfaces</span> bloquantes</td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Commun/">src/robot/Commun/</a></td>
  </tr>
  <tr>
    <td class="tg-uys7" colspan="5">Cartes électroniques</td>
    <td class="tg-uys7">Communication par <span style="font-weight:bold">trames</span></td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Cartes/">src/robot/Cartes/</a></td>
  </tr>
</table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communication-avec-le-hardware"><a class="header" href="#communication-avec-le-hardware">Communication avec le hardware</a></h1>
<p>En robotique, il est crucial de pouvoir communiquer entre l'ordinateur décisionnaire et avec l'ensemble des capteurs / moteurs qui animent le robot.</p>
<h2 id="histoire-de-la-communication-dans-le-club"><a class="header" href="#histoire-de-la-communication-dans-le-club">Histoire de la communication dans le Club</a></h2>
<p>Historiquement, le robot du Club était composé d'une multitude de cartes décentralisées et chacune avait une fonction spéficique (s'occuper de tous les servos moteurs par exemple). Ces cartes étaient reliées par un <a href="https://fr.wikipedia.org/wiki/Bus_de_donn%C3%A9es_CAN">bus CAN</a> avec l'ordinateur et de nombreuses trames transitaient de manière asynchrone.</p>
<p>Cependant, le savoir de l'utilisation des technologies utilisées (des microcontrôleurs à PIC) s'est perdue et entre 2017 et 2019, on a décidé de changer l'architecture pour</p>
<ul>
<li>maîtriser l'ensemble de la chaîne entre le hard et le soft</li>
<li>réaliser une documentation et un code propre pour faciliter le maintien et la passation du savoir</li>
<li>avoir une solution rapide pour remplacer de l'électronique en cas de dysfonctionnement</li>
<li>augmenter les capacités des cartes électroniques</li>
</ul>
<p>Ainsi, on a à présent une architecture décentralisée sur plusieurs cartes industrielles <a href="https://eu.mouser.com/new/stmicroelectronics/stm-nucleo-development-boards/">STM32 Nucleo</a>. La communication avec le soft se fait par ethernet, ce qui augmente la facilité de maintenance, la fiabilité et la puissance de communication.</p>
<hr />
<p>Il est maintenant temps de rentrer dans les détails techniques de cette communication décentralisée.</p>
<h2 id="trames-de-communication"><a class="header" href="#trames-de-communication">Trames de communication</a></h2>
<p>Le but est d'utiliser les bénéfices d'une communication entre deux 'cartes mères', et donc de partager le maximum d'informations entre l'informatique et l'électronique. Ainsi, les trames ne correspondent plus à un ordre sporadique addressé au hardware, mais elles regroupent l'ensemble de l'état du robot.</p>
<p>L'ordinateur envoie l'état du robot tel qu'il souhaite l'être, et la carte électronique travaille pour atteindre l'état voulu. Cet état général est envoyé par l'info puis renvoyé par l'élec et ce en permanence, avec une fréquence de <strong>FIXER LA FREQUENCE</strong>.</p>
<p>Le format de l'état se veut modulaire en JSON, afin de pouvoir être utilisé quel que soit le robot. Concrètement, la carte électronique est considérée comme un ensemble de modules indépendants (déplacement, évitement, moteurs, servos, capteurs...) qui possèdent chacun un ID, avec un <strong>maximum de 16</strong> modules connectés.</p>
<p>La tableau suivant regroupe les IDs des modules 'génériquement', mais il n'est bien sûr pas figé.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ID</th><th style="text-align: center">Module</th></tr></thead><tbody>
<tr><td style="text-align: center">0x01</td><td style="text-align: center">Déplacement</td></tr>
<tr><td style="text-align: center">0x02</td><td style="text-align: center">Servos</td></tr>
<tr><td style="text-align: center">0x03</td><td style="text-align: center">IO</td></tr>
<tr><td style="text-align: center">0x04</td><td style="text-align: center">Évitement</td></tr>
<tr><td style="text-align: center">0x05</td><td style="text-align: center">Moteurs</td></tr>
<tr><td style="text-align: center">0x06</td><td style="text-align: center">Capteurs</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="format-général-dune-trame"><a class="header" href="#format-général-dune-trame">Format général d'une trame</a></h2>
<p>Lorsque la partie informatique communique avec la carte appropriée à propos d'un module, les informations partagées sont encapsulées suivant plusieurs blocs :</p>
<ul>
<li>Chaque module sait parser <em>(ie lire et écrire)</em> un flux d'octets qui correspond à un format texte JSON, qui est très simple à lire. La spécification de la structure de données échangées dépend de chaque module et peut se trouver <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules">dans ce dossier</a>. Elle est également spécifiée plus loin dans ce document.</li>
<li>Pour savoir à quel module est addressé la trame, on rajoute son <strong><code>ID</code></strong> devant la trame sur un <code>u8</code>.</li>
<li>Enfin, la trame est envoyée sur le support physique :
<ul>
<li>dans le cas d'une liaison UDP, la taille de la trame se retrouve grâce aux informations du protocole de transport, donc il suffit d'envoyer un message contenant les données <code>{ID, trame}</code>. Les addresses IP utilisées sont les suivantes : <code>192.168.&lt;ID robot&gt;.&lt;ID module&gt;</code>, avec <code>&lt;ID robot&gt;</code> valant respectivement <code>0</code> et <code>1</code> pour les robots primaire et secondaire.</li>
<li>pour toutes les autres communications série, on encapsule <code>{ID, trame}</code> dans un header qui contient :
<ul>
<li>4 octets qui permettent de distinguer le début d'une trame intéressante ; c'est nécessaire car on est dans une communication asynchrone. Dans le cas du club, elles commencent par le pattern <code>0xAC DC AB BA</code> pour spécifier leur début</li>
<li>1 octet pour contenir la taille du message intéressant, c'est à dire la taille de <code>{ID, trame}</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="création-dune-liaison-de-communication"><a class="header" href="#création-dune-liaison-de-communication">Création d'une liaison de communication</a></h2>
<p>La classe <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Communication/Communicator.h"><code>Communicator</code></a> s'occupe se gérer la communication élec-info. Il suffit de faire appel à la méthode <code>connect</code> avec les bons arguments et la bonne liaison série est instanciée puis est capable de lire et écrire des trames.</p>
<p>Cet objet est capable de parler sur n'importe quel médium de communication, en faisait appel à un <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Communication/Protocol.h"><code>Protocol</code></a>. La première méthode appelable est <code>send_frame</code>, qui envoie une trame ; la seconde doit être lancée dans un thread spécifique et permets de recevoir des données pour les traiter avec un handler à fournir : <code>recv_frame(const atomic_bool&amp; b, function&lt;void(GlobalFrame)&gt;)</code>. Le premier argument permets d'interrompre la fonction, qui est bloquée dans un <code>while(b)</code>.</p>
<p>Voici les protocoles  possibles avec leurs arguments :</p>
<ul>
<li><strong>Liaisons séries</strong>
<ul>
<li><code>protocol_null</code> : <code> </code>, toutes les trames sont perdues</li>
<li><code>protocol_tcpip</code> : <code>string address, uint16_t port</code> connexion TCP client vers le serveur <code>address:port</code></li>
<li><code>protocol_local</code> : <code> </code>, les trames sont envoyées en TCP vers un le serveur <code>localhost:4321</code></li>
<li><code>protocol_pipes</code> : <code>string rx, string tx</code>, lecture et écriture sur des pipes nommées ; par défaut : <code>rx: "/tmp/read.pipe"</code>, <code>tx: "/tmp/write.pipe"</code></li>
<li><code>protocol_udp</code> : <code>string address, uint16_t local_port, uint16_t remote_port</code>, liaison UDP depuis le port local vers le serveur UDP <code>address:remote_port</code>. Ce protocole peut être utilisé dans les deux sens de communication, contrairement à l'implémentation actuelle de <code>protocol_tcpip</code>.</li>
</ul>
</li>
<li><strong>Communications sur plusieurs liaisons séries</strong>
<ul>
<li><code>protocol_ethernet</code> : <code>initializer_list&lt;UDPConnection&gt;</code>, permets de centraliser <code>N</code> connections UDP en un unique appel à un thread de réception bloquant. Ce protocole gère aussi l'association <code>id_module &lt;-&gt; UDP communication thread</code>.</li>
</ul>
</li>
</ul>
<p><img src="pre_2021/info/explications//images/info/communication.png" alt="UML de la communication" title="Diagramme UML de la communication" /></p>
<hr />
<h2 id="modules-spécialisés"><a class="header" href="#modules-spécialisés">Modules spécialisés</a></h2>
<p>Chaque module a un rôle particulier (gérer les servos, se déplacer, détecter l'adversaire, capter des infos dans ce monde de sauvage, ...). Pour faciliter la maintenabilité du code, des parties sont mises en commun entre l'info et l'élec.</p>
<p>Les deux parties utilisent un langage de programmation différent donc les deux parties doivent utiliser le même protocole pour communiquer. La solution retenue est d'envoyer des messages en format JSON encapsulés dans de l'UDP via une liaison ethernet.</p>
<p>Les formats de JSON sont appropriés pour le debug car les messages sont lisibles avec <a href="pre_2021/info/explications/www.wireshark.org">wireshark</a>. De plus, ils sont bien plus maintenables car le code est bien plus simple (on utilise des librairies pour parser le JSON).</p>
<p>LQ seule prérogative pour la partie en <code>Rust</code> est de déclarer des structures de données qui correspondent aux formats transités en JSON.</p>
<h3 id="format-du-module-servos"><a class="header" href="#format-du-module-servos">Format du module <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/Servos.h"><code>Servos</code></a></a></h3>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/Servos.h">Cette classe</a> permets de gérer un ensemble de <a href="https://www.robotshop.com/media/files/pdf/manual-drs-0101.pdf">servos-moteurs</a> en connaissant l'ensemble des informations qui leur sont propres et dont l'état est partagé avec les élecs.</p>
<p>Pour avoir une idée technique de son API, je te conseille d'aller voir directement le code source.
L'interface permets de rajouter des servos (ID &gt; 0) puis de contrôler chaque partie avec des fonctions thread-safe.</p>
<p>La sûreté par rapport au partage des données se fait grâce à une <a href="http://www.cplusplus.com/reference/mutex/">variable mutex</a> partagée et qui est bloquée à chaque accès sur des variables : si la trame des servos est en cours de génération, l'écriture du nouvel angle doit attendre pour que le mutex soit libéré.</p>
<p>Actuellement, cette classe gère 8 servos (la valeur est constante dans le code) et la trame associée est définie ainsi :</p>
<pre><code>&lt;id&gt;
{
  "id": &lt;u8&gt;,
  "known_position": &lt;u16&gt;,
  "control": "[Position|Speed]",
  "data": &lt;u16&gt;,
  "rotation": "[Clockwise|CounterClockwise]",
  "blocked": &lt;bool&gt;,
  "mode": "[Unblocking|HoldOnBlock]",
  "color": "[Block|Red|Green|Yellow|Blue|Magenta|Cyan|White]"
}
</code></pre>
<p>Les états de chaque servomoteur est envoyé individuellement par le module pour limiter l'impact d'une perte de paquet ainsi que pour faciliter la lecture des trames.</p>
<h3 id="format-du-module-motors"><a class="header" href="#format-du-module-motors">Format du module <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/Motors.h"><code>Motors</code></a></a></h3>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/Motors.h">Cette classe</a> fournit une interface pour travailler avec 8 moteurs asservis, 8 moteurs non-asservis et 8 brushless, dont les fonctions associées sont spécifiques. Voici la trame qui spéficie les informations de tout ce beau monde :</p>
<pre><code>&lt;id&gt;
{
  ## TODO
}
</code></pre>
<h3 id="format-du-module-io"><a class="header" href="#format-du-module-io">Format du module <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/IO.h"><code>IO</code></a></a></h3>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/IO.h">Cette classe</a> est un vestige d'une ancienne façade avec plein de boutons <em>(pour choisir la couleur, le type de connexion...)</em>. Elle ne sert actuellement qu'à détecter si la tirette est enclenchée ou non et ne relaye donc qu'un Booléen par l'intermédiaire de cette structure de trame :</p>
<pre><code>&lt;id&gt;
{
  "tirette": &lt;bool&gt;
}
</code></pre>
<h3 id="format-du-module-navigation"><a class="header" href="#format-du-module-navigation">Format du module <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/Navigation.h"><code>Navigation</code></a></a></h3>
<p><em><strong>TODO</strong></em></p>
<hr />
<h2 id="interface-de-communication"><a class="header" href="#interface-de-communication">Interface de communication</a></h2>
<p>Comme tu l'as vu dans les parties précédentes, on possède à présent plein de modules qui gèrent des aspects différents du robot, et le <code>ModuleManager</code> offre un interfaçage facile pour connaître l'état du robot.</p>
<p>On peut générer l'état global du robot dans une trame, et mettre à jour le robot depuis une trame globale ; il ne reste plus qu'à gérer la communication entre l'info et l'élec !</p>
<p>Pour cela, tu peux aller voir <a href="https://github.com/ClubRobotInsat/info/tree/master/src/robot/Commun/Communication/ElecCommunicator.h">du côté du communicateur</a>. Son but est d'avoir en paramètre une classe qui lit et écrit des <code>GlobalFrame</code>s, ainsi qu'un médium de communication et il gère automagiquement la communication pour se connecter, exécuter le protocole de transmission de trames et arrêter à sa destruction la communication.</p>
<p>Afin d'être aussi général que possible, le communicateur peut prendre en paramètre n'importe quel objet qui donne accès aux fonctions de parsing :</p>
<ul>
<li><code>void read_frame(const GlobalFrame&amp;);</code></li>
<li><code>std::vector&lt;GlobalFrame&gt; write_frame() const;</code></li>
</ul>
<p>Si l'objet fourni ne possède pas ces deux définitions, la méthode <code>communicate_with_elecs</code> <em>(sencée être exécutée dans un thread pour recevoir et envoyer les trames)</em> devient inaccessible ; si la méta-programmation ne te fait pas peur tu peux aller voir <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Communication/ParsingClassChecker.hpp">comment vérifier l'existance des fonctions de parsing</a>.</p>
<hr />
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>Voici un récapitulatif des couches d'abstraction que l'on vient d'aborder dans ce document :</p>
<ul>
<li>
<p>Wrapping de structures brutes en JSON pour connaître l'état de chaque module : <em><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Modules/">lien</a></em></p>
<ul>
<li>du code <code>C++</code> et <code>Rust</code> (respectivement pour les infos et les élecs) englobe ces C-structs</li>
<li>nombreux avantages : rajout de sécurité, tests et interface fonctionnelle</li>
</ul>
</li>
<li>
<p>le <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Modules/ModuleManager.h"><code>ModuleManager</code></a> regroupe tous ces modules</p>
<ul>
<li>manipulation facilitée</li>
<li>tout l'état du robot est centralisé</li>
<li>parsing des trames globales</li>
</ul>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/master/src/robot/Communication/Communicator.h">communication avec les élecs</a> depuis les fonctions de parsing du <code>ModuleManager</code></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="détection-de-ladversaire--lidar-1"><a class="header" href="#détection-de-ladversaire--lidar-1">Détection de l'adversaire : LIDAR</a></h1>
<p>Jusqu'à présent, la détection de l'adversaire venait d'un projet <em>home-made</em> du club : un laser monté sur tourelle envoyait un rayon laser autour de la base. Une pièce réfléchissante était posée sur les robots adverses et le système était capable de connaître une valeur booléenne sur la présence d'un adversaire. Mécaniquement, le rayon passait soit au-dessus soit en-dessous de l'adversaire s'il n'était pas dans un rayon de 30 à 50 centimètres de notre robot. Les électroniques étaient enfin capables de nous donner l'angle auquel le robot a été détecté.</p>
<h2 id="explications-1"><a class="header" href="#explications-1">Explications</a></h2>
<p>Cette solution s'est inclinée face à l'utilisation de <a href="pre_2021/info/explications/">LIDAR</a>s depuis 2019. Il s'agit d'un capteur beaucoup plus précis que notre ancienne tourelle, qui map en 2D son environnement avec des lasers. En sortie, on a une liste de distances qui représentent N points détectés à une certaine distance de notre robot.</p>
<p>Le code développé en interne au club permets d'utiliser deux LIDARs différents : <strong>[Hokuyo](https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/Doc/Doc\ Hokuyo.pdf)</strong> et <strong><a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/Doc/doc_SICK.pdf">SICK TiM55x</a></strong>, le plus précis.</p>
<p>Dans un premier temps, un <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/Driver">code driver</a> est capable de communiquer avec chacun de ces LIDARs. Pour avoir une interface d'acquisition, il suffit d'utiliser ce code :</p>
<pre><code class="language-cpp">#include "Lidar/Driver/lidar.h"
std::unique_ptr&lt;Lidar&gt; my_lidar = Lidar::open_lidar(Lidar::Any);
</code></pre>
<h3 id="sick-tim55x"><a class="header" href="#sick-tim55x">SICK TiM55x</a></h3>
<p>Pour utiliser ce capteur, il faut exécuter le code en tant que <code>root</code>. De plus, il faut actuellement brancher l'électronique sur une alimentation à <code>16V / 0.2 A</code> pour brancher le câble circulaire à 5 broches sur le LIDAR. Il faut utiliser un autre câble USB que celui soudé entre le LIDAR et l'ordinateur.</p>
<h2 id="capacités-actuelles"><a class="header" href="#capacités-actuelles">Capacités actuelles</a></h2>
<p>Le code est capable de <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/filtre.h">filtrer</a> les trames d'acquisition. Ces points sont <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/lidarsToGrid.h">entreposés dans un plan 2D</a> en fonction des <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/commun/MathToolbox/Repere.h">coordonnées</a> du lidar ce qui permets de connaître la position absolue de chaque point dans un repère quelconque, quelque soit la position initiale du robot.</p>
<p>Grâce à la grande précision des LIDARs, la cartographie de toute la table est possible. Vu que le LIDAR est placé tout en haut de notre robot, les seuls points observés par le LIDAR représentent des points sur la table <em>(les arbitres n'influent pas sur les acquisitions)</em> en-dehors des objets à manipuler. Ainsi, seuls les robots adverses sont vus par le LIDAR, et donc les objets détectés par le LIDAR <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/FindRobots.h">sont considérés comme des robots adverses</a>.</p>
<h2 id="intégration-dans-le-code"><a class="header" href="#intégration-dans-le-code">Intégration dans le code</a></h2>
<p>Ce capteur est externe au travail dans électroniciens donc la classe <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Robot.h">Robot</a> contient directement une instance d'un <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/lidar.h">LIDAR</a> en plus du <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/ModuleManager.h">ModuleManager</a>. Il donne à disposition l'accès à <code>optional&lt;FrameLidar&gt; get_lidar_frame() const</code>, qui est ensuite utilisée <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Strategy/AbstractStrategy.h">dans la stratégie</a> pour détecter les adversaires en fonction de la position du robot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="création-dun-robot-1"><a class="header" href="#création-dun-robot-1">Création d'un robot</a></h1>
<p>Dans la <a href="pre_2021/info/explications/communication.html">partie précédente</a>, tu as vu comment sont gérées la communication et la représentation électronique des différents modules.</p>
<p>À présent, il est temps de voir comment le code informatique gère l'abstraction d'un robot !</p>
<h2 id="le-regroupement-des-constantes"><a class="header" href="#le-regroupement-des-constantes">Le regroupement des constantes</a></h2>
<p>Le choix a été fait de définir toutes les constantes dans un même <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot.ini">fichier d'initialisation</a>.</p>
<p>Ça permet notamment d'avoir un moyen de changer une constante (la durée d'un match, la composition modulaire des robots...) sans avoir à recompiler tout le projet, et donc de gagner du temps.</p>
<p>On utilise le <a href="https://en.wikipedia.org/wiki/INI_file">format INI</a>, comoposé de sections, de clefs et de valeurs ; le fichier est lisible et facilement maintenable.</p>
<h2 id="accès-aux-constantes-dans-le-code"><a class="header" href="#accès-aux-constantes-dans-le-code">Accès aux constantes dans le code</a></h2>
<p>Toutes les constantes sont initialisées en C++ dans <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/commun/Constants.h">ce fichier</a>. Une instance des constantes est définie globalement et il suffit de ce code pour récupérer des informations :</p>
<pre><code class="language-cpp">#include &lt;Constants.h&gt;

int main() {
  Duration match = GLOBAL_CONSTANTS().get_match_duration();
}
</code></pre>
<p>Bien entendu, ces constantes servent à définir globalement un match (temps de jeu, taille de la table...) mais elles permettent également de définir les robots présents sur la table, comme nous allons le voir.</p>
<h2 id="lobjet-robot"><a class="header" href="#lobjet-robot">L'objet <code>Robot</code></a></h2>
<p>Conceptuellement, un robot a besoin de répondre à différents critères :</p>
<ol>
<li>il possède une architecture électronique et donc mécanique</li>
<li>sa partie informatique <em>(décisionnelle)</em> est capable de communiquer avec sa partie électronique <em>(applicative)</em></li>
<li>il peut prendre des décisions pour évoluer dans son environnement</li>
</ol>
<p>Ça tombe bien, parce qu'on a à notre disposition le <code>ModuleManager</code> qui résoud le problème <strong>1</strong>, et l'<code>ElecCommunicator</code> qui correspond au <strong>2</strong>. Enfin, la partie <strong>3</strong> est une fonction réalisée à un niveau d'abstraction supérieur, et on va l'aborder dans la section <em><strong>Stratégie</strong></em>.</p>
<p>Un <code>Robot</code> a donc deux rôle principaux : il gère le <code>ModuleManager</code> et s'occupe de la communication en lançant dans un <a href="https://en.cppreference.com/w/cpp/thread/thread">thread</a> la communication.</p>
<p>Afin de simplifier son utilisation à la fois dans le contexte de la Coupe et afin de débuguer les modules électroniques.</p>
<ul>
<li>On peut construire l'électronique 'à la main' en créant un <code>ModuleManager</code> puis en le donnant au constructeur du <code>Robot</code> :</li>
</ul>
<pre><code class="language-cpp">// Création du module manager qui va héberger les modules
auto m = std::make_shared&lt;PhysicalRobot::ModuleManager&gt;();

// Ajout d'un module "Servos" avec deux servomoteurs
auto&amp; servos = m-&gt;add_module&lt;PhysicalRobot::Servos&gt;(2);
servos.add_servo(5, 120_deg);
servos.add_servo(6, 50_deg, PhysicalRobot::Servos::BlockingMode::HOLD_ON_BLOCKING);

// Création d'un robot à partir du ModuleManager précédemment instancié
// Le deuxième argument est une liste de paramètres permettant d'initialiser la connexion au robot
// Ici on aura une connexion de type "PIPES"
PhysicalRobot::Robot robot(m, {"prog", "PIPES"});
</code></pre>
<ul>
<li>Utilisation du fichier <code>src/robot.ini</code> dans lequel on peut définir en-dehors du programme les variables d'initialisation pour n'importe quel robot (<code>primary</code>, <code>secondary</code>, <code>adversary</code>, <code>best_robot_of_the_world</code>...). Un robot initialisé à partir d'un <code>ModuleManager</code> se nomme <code>guest</code>, donc le nom est réservé :smile:</li>
</ul>
<pre><code class="language-ini">[robot.primary]
position_x=250        ; mm
position_y=1500       ; mm
size_x=300            ; mm
size_y=300            ; mm
size_z=420            ; mm
angle=-90             ; deg

[robot.primary.modules]
moving=1
servos=2
motors=3
avoidance=4
io=5
</code></pre>
<hr />
<p>Il est donc très facile de créer une instance qui possède à la fois l'architecture électronique et qui s'occupe de la communication.</p>
<p>Je te laisse te reporter aux différents tests pour avoir des exemples de comment l'utiliser (pour tester les servos par exemple) ; les robots complets utilisés pendant les matches sont utilisés dans la <code>Strategy</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-du-simulateur"><a class="header" href="#architecture-du-simulateur">Architecture du simulateur</a></h1>
<p>Le simulateur est fait pour être modulaire, c'est à dire que l'on peut passer d'une solution graphique à une autre et on peut rajouter des modules pour le robot facilement.</p>
<p>Il y a 5 composantes principales :</p>
<ul>
<li>La  <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/physique/"><code>physique/</code></a> permet de simuler le comportement de tous les objets physiquement
en prenant en compte les collisions, les déplacements etc. Pour ce faire, on utilise la librairie <a href="http://box2d.org/">Box2D</a>, un moteur physique.</li>
<li>Le  <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/graphique/"><code>graphique/</code></a> permet d'afficher tous les objets de la table dans un environnement
3D avec la possibilité de s'y déplacer, de zoomer ... Ici encore, on utilise une librairie, <a href="http://irrlicht.sourceforge.net/">Irrlicht</a>, en tant que moteur graphique.</li>
<li>La <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/gui/"><code>gui/</code></a> gère l'interface utilisateur, affiche des informations utiles (telles que l'état
du robot par exemple) et permet de piloter le simulateur.</li>
<li>La <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/communication/"><code>communication/</code></a> permets de simuler le comportement des cartes électroniques.
On peut donc utiliser la même stratégie en réel et sur le simulateur qui demande au robot d'<code>avancer</code> de 10 cm par exemple, et l'application va simuler les actions.</li>
<li>Le <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/core/"><code>core/</code></a> permets enfin de tout coordonner pour avoir un simulateur fonctionnel.</li>
</ul>
<h2 id="coeur"><a class="header" href="#coeur">Coeur</a></h2>
<p>Le simulateur est entièrement controllé par la classe <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/core/Simulateur.h"><code>Simulateur</code></a>.
Cette classe est instanciée directement dans le <code>main</code> et contrôle les différents modules. Elle contient des méthodes pour initialiser le simulateur,
reset la table, ajouter des robots à la simulation, et terminer proprement une session.</p>
<p>La classe <code>Simulateur</code> contient une instance de <code>World</code>.</p>
<h2 id="communication-1"><a class="header" href="#communication-1">Communication</a></h2>
<p>La communication du simulateur fonctionne en mirroir de celle de l'IA. Le code a donc plus ou moins la même structure : plusieurs modules, rassemblés dans un <code>ModuleManager</code>,
et un communicator pour gérer l'envoi des trames.</p>
<p>Le simulateur implémente ses propres modules spécifiques, qui jouent le rôle des cartes dans le robot réel. Ces modules fonctionnent exactement sur le même principe que les
modules côté IA : ils reçoivent des trames, les lisent, effectuent des actions et envoient de nouvelles trames en réponse.</p>
<p>Le simulateur jouant le rôle des cartes du robot, il envoit une trame seulement en réponse à une trame de la partie informatique. Ce comportement est implémenté dans la méthode
<code>communicationThread()</code> du <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/communication/SimuCommunicator.cpp"><code>SimuCommunicator</code></a>.</p>
<h2 id="partie-physique"><a class="header" href="#partie-physique">Partie physique</a></h2>
<p>L'API de la partie physique est constituées de deux interfaces :
<a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/physique/IPhysicalContext.h"><code>IPhysicalContext</code></a>, qui permet de créer des objets dans le moteur physique
et <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/physique/IPhysicalInstance.h"><code>IPhysicalInstance</code></a>, qui permet de gérer un objet physique en
particulier.</p>
<p>Le coeur du simulateur ne manipule que ces interfaces, et n'a pas besoin de savoir comment c'est implémenté derrière. L'utilisation d'interfaces de cette manière permet le
<strong>découplage</strong> des différentes parties du simulateur. Pour plus d'information sur le couplage des composants logiciels d'une application, voici un lien vers
<a href="https://fr.wikipedia.org/wiki/Couplage_(informatique)">la page Wikipedia</a></p>
<h3 id="implémentation"><a class="header" href="#implémentation">Implémentation</a></h3>
<p>L'implementation du moteur physique du simulateur est réalisée à l'aide du moteur physique <a href="https://box2d.org/">Box2D</a>. Elle se situe dans le dossier
<a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/physique/box2D/"><code>physique/box2D/</code></a>.</p>
<p>Il y a quelques années, le simulateur utilisait un moteur physique en 3D. Même si les simulations étaient plus réalistes, il était difficile de configurer l'environnement
pour que le robot se comporte comme en vrai. C'est pourquoi nous sommes passés à un moteur en 2D.</p>
<h2 id="partie-graphique"><a class="header" href="#partie-graphique">Partie graphique</a></h2>
<p>De même que la partie physique, la partie graphique du simulateur est manipulée via deux interfaces,
<a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/graphique/IGraphicalContext.h"><code>IGraphicalContext</code></a> pour créer les objets 3D de l'affichage
et <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/graphique/IGraphicalInstance.h"><code>IGraphicalInstance</code></a> pour modifier les propriétés d'un
objet en particulier.</p>
<h3 id="implémentation-1"><a class="header" href="#implémentation-1">Implémentation</a></h3>
<p>Nous utilisons <a href="http://irrlicht.sourceforge.net/">Irrlicht</a> pour l'implémentation de l'affichage graphique de la simulation. Celle-ci se trouve dans le dossier
<a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/graphique/irrlicht/"><code>graphique/irrlicht/</code></a>.</p>
<h2 id="interface-utilisateur-gui"><a class="header" href="#interface-utilisateur-gui">Interface utilisateur (GUI)</a></h2>
<p>Pour pouvoir interagir avec le simulateur, il faut des boutons, des champs de texte, etc. Ces fonctionnalités sont assez différentes de l'affichage 3D du simulateur.
De plus, Irrlicht ne nous permet pas de rajouter facilement des éléments d'UI (User Interface) à l'affichage 3D. La GUI est donc un module séparé de l'affichage 3D.
Le coeur du simulateur interagit avec ce module à travers l'interface <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/gui/IGuiContext.h"><code>IGuiContext</code></a>.</p>
<p>Le module doit aussi transmettre les ordres de l'utilisateur au simulateur. Pour se faire, il reçoit lors de son initialisation un objet de type
<a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/gui/IGuiClient.h"><code>IGuiClient</code></a>, qui possède des méthodes permettant d'éxecuter des actions
sur le simulateur.</p>
<h3 id="implémentation-2"><a class="header" href="#implémentation-2">Implémentation</a></h3>
<p>La librarie utilisée pour la GUI se nomme <a href="https://www.gtkmm.org/en/">Gtkmm</a>. C'est un port C++ de la librairie C <em>Gtk</em> utilisée dans de nombreuses programmes comportant
une interface graphique. Vous pourrez trouver une doc très détaillée de Gtkmm
<a href="https://developer.gnome.org/gtkmm-tutorial/unstable/gtkmm-tutorial.html">ici</a>.</p>
<p>La GUI se compose actuellement d'une fenêtre comportant plusieurs panneaux. Les panneaux sont créés avec <a href="https://glade.gnome.org/">Glade</a>. Ils sont sauvegardés dans
le dossier <code>gui/gtk/glade/</code> sous forme de fichiers <code>.glade</code>. A la création de la fenêtre, le simulateur charge ces différents panneaux et les ajoute à la fenêtre
principale. Comme ça le placement des composants est déjà fait, il ne reste plus qu'à écrire le code qui exécute l'action demandée par l'utilisateur.</p>
<p>Les différentes classes qui gèrent les panneaux ont toutes un nom de la forme <code>Panel[Nom du panneau].h/.cpp</code>. Le <code>PanelConnect</code> est un bon exemple si vous voulez implémenter
votre propre panneau !</p>
<h2 id="complément-sur-le-couplage-"><a class="header" href="#complément-sur-le-couplage-">Complément sur le couplage :)</a></h2>
<pre><code>Section à rédiger
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Électronique-logicielle"><a class="header" href="#Électronique-logicielle">Électronique Logicielle</a></h1>
<p>L’électronique logicielle (ou <em>elec soft</em> pour les intimes) consiste à concevoir le fonctionnement logiciel d'un microcontrôleur et de ses périphériques.</p>
<p>Le but des cartes électroniques est de fournir à la partie informatique du robot un moyen simple d'envoyer des commandes aux différents actionneurs et de lire les différents capteurs. Pour certains types de composants c'est assez simple (les composants binaires comme les LEDs ou les vannes) et pour d'autres cela implique plus de travail (servomoteurs numériques, moteurs à courant continu).</p>
<p>La carte électronique va donc avoir un rôle d’intermédiaire entre l'ordinateur embarqué et le monde physique du robot. Normalement, si tout va bien durant l'année, un circuit imprimé a été réalisé afin que le microcontrôleur puisse parler avec les actionneurs/capteurs.</p>
<p>Il suffit donc de programmer le microcontrôleur pour qu'il envoie les bons signaux quand on lui demande !</p>
<h1 id="plus-de-documentation"><a class="header" href="#plus-de-documentation">Plus de documentation</a></h1>
<p>Tu veux encore plus de documentation ? Ta soif de savoir ne s'étanche pas ? Tu cherches le détail du fonctionnement du module UART du microcontrôleur stm32f103 ? Tu n'arrive pas à savoir si l’adresse <code>0x4000400C</code> est un Timer ou un I2C ? Tu cherches le layout du W5500 ? Tu veut comprendre les arcanes de l'elec ? Toutes ces informations se trouvent dans l'archive compilée par mes soins, <a href="pre_2021/elec_soft/../images/elec_soft/DOC.tar.gz">ici</a></p>
<p>Inclu notamment :</p>
<ul>
<li>ref du stm32f103</li>
<li>ref du stm32f446</li>
<li>ref du tcs3200</li>
<li>ref des drs0101</li>
<li>ref des ponts h</li>
<li>ref du w5500</li>
</ul>
<p>(liste non contractuelle)</p>
<p><a href="pre_2021/elec_soft/../images/elec_soft/DOC.tar.gz">Archive</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organisation--architecture"><a class="header" href="#organisation--architecture">Organisation &amp; Architecture</a></h1>
<p>Le code est séparée en deux : les fonctionnalités partagées entre les cartes sont dans <a href="https://github.com/ClubRobotInsat/librobot">librobot</a> et chaque carte est implémentée dans le repo git <code>firmware-&lt;fonctionnalité&gt;</code>.</p>
<p>Il y a actuellement (après la coupe de 2019), 4 cartes:</p>
<ul>
<li><a href="https://github.com/ClubRobotInsat/firmware-navigation"><code>firmware-navigation</code></a></li>
<li><a href="https://github.com/ClubRobotInsat/firmware-servos"><code>firmware-servos</code></a></li>
<li><a href="https://github.com/ClubRobotInsat/firmware-io/"><code>firmware-io</code></a></li>
<li><a href="https://github.com/ClubRobotInsat/firmware-io-secondary"><code>firmware-io-secondary</code></a></li>
</ul>
<h2 id="librobot"><a class="header" href="#librobot">Librobot</a></h2>
<p>Cette librairie a été introduite afin de réutiliser du code entre les cartes.
Un effet sympathique de cette librairie c'est qu'il possible d'y écrire des <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">tests unitaires</a>.</p>
<p>La documentation de la librairie est regénérée par <a href="https://fr.wikipedia.org/wiki/Travis_CI">Travis</a> (script <a href="https://github.com/ClubRobotInsat/librobot/blob/master/.travis.yml">ici</a>) à chaque commit et se trouve <a href="https://clubrobotinsat.github.io/librobot/librobot/">ici</a>.</p>
<h2 id="cartes"><a class="header" href="#cartes">Cartes</a></h2>
<p>Chaque carte est structurée de la même façon. Voici le contenu de <code>firmware-navigation</code> pour le commit <code>c86b1a0cd1d5da5030a1fac55fae41ac4cf591d7</code> :</p>
<pre><code>├── black_pill.cfg
├── Cargo.lock
├── Cargo.toml
├── debug.sh
├── interfaces
│  ├── stlink-v2-1.cfg
│  └── stm32f1x.cfg
├── memory.x
├── README.md
├── src
│  ├── main.rs
│  ├── robot.rs
│  └── variables.rs
└── target
   ├── debug
   │  ├── build
   │  ├── deps
   │  ├── examples
   │  ├── incremental
   │  └── native
   ├── release
   │  ├── build
   │  ├── deps
   │  ├── examples
   │  ├── incremental
   │  └── native
   └── thumbv7m-none-eabi
      ├── debug
      └── release

</code></pre>
<p>Les fichiers <code>Cargo.toml</code> et <code>Cargo.lock</code> listent les dépendances du projet. Il faut noter que <code>Cargo.lock</code> est suivi par git, comme ça tout le monde compile les mêmes versions des librairies (c'est très important pour tout le monde ai le même code !).</p>
<p>Le fichier <code>black_pill.cg</code> et ceux présents dans <code>interfaces</code> sont les fichiers de configuration de OpenOCD afin de flasher la carte.</p>
<p>Le fichier <code>debug.sh</code> invoque <code>gdb</code> aves les bons arguments pour se connecter à OpenOCD et flasher la carte.</p>
<p>Le fichiers <code>memory.x</code> décrit l'organisation de la mémoire du microcontrolleur.</p>
<p>Le fichier <code>README.md</code> sers de documentation minimale pour la carte.</p>
<p>Dans le dossier <code>src</code> on trouve :
* <code>main.rs</code> : contiens la logique de la fonction main
* <code>robot.rs</code> : contiens l'initialisation du microcontrolleur et de ses périphériques</p>
<p>Enfin, le dernier dossier qui nous intérresse est le dossier <code>target/thumbv7m-none-eabi</code> qui contiens le résultat de la compilation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mise-en-place-2"><a class="header" href="#mise-en-place-2">Mise en place</a></h1>
<p>Dans cette section, nous allons installer pas à pas tous les outils pour pouvoir développer du code pour le robot.</p>
<p>Avant d'attaquer cette partie tu as installé avec succès :</p>
<ul>
<li><a href="pre_2021/elec_soft/mise_en_place/git.html">git</a></li>
<li><a href="pre_2021/elec_soft/mise_en_place/ide.html">CLion</a></li>
</ul>
<p>Nous allons donc commencer par installer un compilateur Rust, ainsi que des outils pour pouvoir flasher, déboguer et tester le code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation-1"><a class="header" href="#compilation-1">Compilation</a></h1>
<p>Dans cette section, tu vas faire le grand pas et mettre en place tous les outils pour bidouiller sur les cartes du club robot !</p>
<p>Attention, les instructions sont valables uniquement pour Linux, et sont à adaptées pour ceux qui ont des distributions Linux différentes de Ubuntu.</p>
<h1 id="outils-génériques"><a class="header" href="#outils-génériques">Outils génériques</a></h1>
<p>Tout d'abord il te faut installer les outils suivants :</p>
<ul>
<li><code>gdb-arm-none-eabi</code> : <code>gdb</code> est un débuggeur, tu installes ici la version pour l'architecture <code>arm</code> sans os (<code>none</code>). Tu trouveras plus d'informations sur gdb par <a href="https://fr.wikipedia.org/wiki/GNU_Debugger">ici</a>. Pour les notions d'architecture, tu peux toujours lire la page sur l'<a href="https://fr.wikipedia.org/wiki/Architecture_de_processeur">architecture matérielle</a> sur wikipédia.</li>
<li><code>gcc-arm-none-eabi</code> : <code>gcc</code> est un compilateur pour le langage C. Tu installes la version pour compiler vers l'architecture <code>arm</code> ici.</li>
<li><code>openocd</code> : cet outil permet de communiquer avec le microcontrôleur : c'est grâce à lui que l'on peut envoyer des exécutables dessus et les déboguer.</li>
</ul>
<p>Sur Ubuntu, cela se fait en exécutant les commandes suivantes dans un terminal :</p>
<pre><code class="language-bash">sudo apt update
sudo apt install git gdb-multiarch gdb-arm-none-eabi gcc-arm-none-eabi openocd
</code></pre>
<p>La première commande mets à jour les paquets disponibles, la deuxième les installe.</p>
<h2 id="customisation-de-gdb"><a class="header" href="#customisation-de-gdb">Customisation de gdb</a></h2>
<p>Bien que très puissant, gdb propose une interface d'un autre siècle. Je te propose de rendre cette interface plus agréable !</p>
<ol>
<li>On récupère un fichier tout fait qui rend l'interface de gdb supportable :
<pre><code class="language-bash">wget -P ~ git.io/.gdbinit
</code></pre>
</li>
<li>On autorise le chargement de ce fichier par gdb :
<pre><code class="language-bash">echo "set auto-load safe-path /" &gt;&gt; ~/.gdbinit
</code></pre>
</li>
</ol>
<h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>Pour installer Rust, tu peux te référer aux instructions sur <a href="https://rustup.rs">rustup.rs</a>. Les paramètres par défaut sont très bien.
Si tu as bien installé Rust, quand tu ouvres un nouveau terminal et que tu tapes :</p>
<pre><code class="language-bash">rustc --version
</code></pre>
<p>Il devrait s'afficher un texte qui ressemble à ça (tu auras certainement une version plus récente, là il s'agit de la version du 20 Mai 2019) :</p>
<pre><code class="language-bash">rustc 1.35.0 (3c235d560 2019-05-20)
</code></pre>
<h1 id="utilitaires"><a class="header" href="#utilitaires">Utilitaires</a></h1>
<p>Pour bidouiller plus efficacement, tu peux aussi installer quelques outils plutôt pratiques.</p>
<h2 id="obligatoire--rustfmt"><a class="header" href="#obligatoire--rustfmt">Obligatoire : rustfmt</a></h2>
<p>Dans un projet informatique, plusieurs personnes ont des conventions d'alignement du texte différent, différentes manières d'aller à la ligne dans les déclarations, etc. Si jamais tu t'ennuies, tu peux demander à un barbu si il préfère les tabulations ou les espaces pour indenter le code, flame ware garantie !
Dans le but d'uniformiser le code produit par tout le monde, on utilise un outil <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> qui va venir formater le code. Plus besoin de se prendre la tête avec l'indentation ou les retours à la ligne dans les gros appels de fonctions : on lance <code>rustfmt</code> et le code est formaté.</p>
<p>Cet outil est <strong>obligatoire</strong>, autrement ton installation ne fonctionnera pas. Pour l'installer il suffit de taper dans un terminal :</p>
<pre><code class="language-bash">rustup component add rustfmt-preview
</code></pre>
<h2 id="optionnel--cargo-edit"><a class="header" href="#optionnel--cargo-edit">Optionnel : cargo-edit</a></h2>
<p>L'outil <code>cargo-edit</code> permet d'ajouter facilement des librairies depuis la ligne de commande dans un projet. Pour plus d'informations tu peux aller lire la description de l'outil par <a href="https://crates.io/crates/cargo-edit">ici</a>.</p>
<pre><code class="language-bash">cargo install cargo-edit
</code></pre>
<h2 id="optionnel-cargo-clone"><a class="header" href="#optionnel-cargo-clone">Optionnel cargo-clone</a></h2>
<p>L'outil <code>cargo-clone</code> permet de récupérer le code source de n'importe quelle librairie disponible sur <a href="https://crates.io">crates.io</a> en une ligne de commande.</p>
<pre><code class="language-bash">cargo install cargo-clone
</code></pre>
<h1 id="erreurs-courantes"><a class="header" href="#erreurs-courantes">Erreurs courantes</a></h1>
<p>Quelques erreurs arrivent régulièrement et sont dû à une mauvaise configuration du compilateur. En particulier l'erreur : <code>error: linking with `cc` failed: exit code: 1</code> peut être résolue ainsi :
On installe gdb-multilib : <code>sudo apt install gcc-multilib</code>.
Si l'erreur n'est pas résolue, on vérifie que l'on a choisi le bon compilateur : <code>sudo update-alternatives --config gcc</code> et choisir gcc-8.</p>
<pre><code class="language-bash">expected struct heapless::string::String, found a different struct heapless::string::String
</code></pre>
<p>La version de librobot utilisée n'est pas la bonne, il faut choisir la branch "master" (et non "dev-new-pid") :</p>
<pre><code class="language-bash">nano Cargo.toml
librobot = {git="https://github.com/ClubRobotInsat/librobot", default-features=false}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="répertoire-de-travail-2"><a class="header" href="#répertoire-de-travail-2">Répertoire de travail</a></h1>
<p>Maintenant ouvrons le projet du club robot avec CLion et vérifions que tout fonctionne.</p>
<p>Pour commencer, si tu n'as jamais entendu parler de <code>git</code> ou que tu ne te sens pas très à l'aide avec, tu peux revenir un peu en arrière et lire <a href="pre_2021/elec_soft/mise_en_place/outils_communs/git.html">ceci</a>.</p>
<p>On va compiler le code de la carte servomoteurs.</p>
<h1 id="récupérer-le-code-de-la-librairie"><a class="header" href="#récupérer-le-code-de-la-librairie">Récupérer le code de la librairie</a></h1>
<p>Pour récupérer le code, je te suggère de commencer par te créer un dossier qui contiendra tous les répertoires du club robot (si ce n'est pas déjà fait).
Une fois placé dans ce dossier, tu peux exécuter la commande :</p>
<pre><code class="language-bash">git clone https://github.com/ClubRobotInsat/librobot
</code></pre>
<p>Cette commande va venir demander à <code>git</code> d'aller récupérer la dernière version du code disponible sur <a href="https://github.com/ClubRobotInsat/librobot">github</a> pour la librairie du club robot.</p>
<p>Un nouveau dossier <code>librobot</code> a du apparaître.</p>
<h1 id="récupérer-le-code-de-la-carte-électronique"><a class="header" href="#récupérer-le-code-de-la-carte-électronique">Récupérer le code de la carte électronique</a></h1>
<p>De même, il faut cloner un répertoire sur github pour avoir le code de la carte électronique :</p>
<pre><code class="language-bash">git clone https://github.com/ClubRobotINSAT/firmware-servos
</code></pre>
<p>Il y a quelques étapes de configuration à faire avant de compiler :</p>
<ol>
<li>
<p>Il faut rajouter la cible <code>thumbv7m-none-eabi</code> avec rustup</p>
<pre><code class="language-bash">cd firmware-servos
rustup target add thumbv7m-none-eabi
</code></pre>
</li>
<li>
<p>Il faut vérifier que le projet compile bien :</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
</li>
</ol>
<p>Explication :</p>
<ul>
<li>
<p><code>thumbv7m</code> : jeu d'instruction ARMv7, il s'agit du jeu d'instruction du Cortex M4</p>
</li>
<li>
<p><code>none</code> : pas de système d'exploitation sur la carte électronique</p>
</li>
<li>
<p><code>eabi</code> : on aurait pu avoir l'option <code>hf</code> qui signifie "hard float", c'est à dire que le compilateur va émettre des instructions spéciales pour les calculs sur les nombres flottants au lieu de les calculer avec des entiers. En effet, certains microcontrôleurs embarquent un Floating Point Unit (FPU) qui permet de faire des calculs flottants rapidement. Cependant sur la black-pill il y a un <code>stm32f103</code> qui n'a pas de FPU on ne met donc pas cette option.</p>
</li>
</ul>
<p>Si la compilation a marché alors tout a été installé correctement !</p>
<h1 id="arborescence-du-code-et-fichiers-remarquables"><a class="header" href="#arborescence-du-code-et-fichiers-remarquables">Arborescence du code et fichiers remarquables</a></h1>
<p>Pour comprendre les différents fichiers présents dans le dossier du projet, tu peux revenir en arrière et lire <a href="pre_2021/elec_soft/mise_en_place/../organisation/index.html">Organisation du code</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide-4"><a class="header" href="#ide-4">IDE</a></h1>
<p>Normalement tu as suivi les instructions de la section <a href="pre_2021/elec_soft/mise_en_place//outils_communs/ide.html">Outils Communs - IDE</a>, tu as donc une installation de CLion fonctionnelle.</p>
<p>Si ce n'est pas le cas, reviens un petit peu en arrière et installe CLion !</p>
<h2 id="installation-du-plugin-pour-rust"><a class="header" href="#installation-du-plugin-pour-rust">Installation du plugin pour Rust</a></h2>
<p>En électronique logicielle, nous utilisons le langage <strong>Rust</strong>. Tu en entendras parler un peu plus loin dans la documentation. En attendant il faut installer un plugin pour supporter le langage dans CLion.</p>
<p>Il faut commencer par ouvrir les options de CLion <code>File&gt;Settings</code> ou encore <code>ctrl+alt+s</code>.</p>
<p>Dans le menu <code>Plugins</code> tu cliques sur <code>Install Jetbrains Plugins</code> et tu cherches <code>Rust</code> dans la fenêtre qui s'est ouverte. Pour lancer l'installation, il suffit de cliquer sur <code>Install</code>.</p>
<p>Normalement il devrait être possible de compiler, sinon tu peut aller voir dans <code>Settings &gt; Languages &amp; Frameworks &gt; Rust</code> si tout a été bien détecté et cliqué sur <code>download stdlib with rustup</code> si cela t'es proposé.</p>
<p><img src="pre_2021/elec_soft/mise_en_place//images/ide/plugin_install.png" alt="Installation du plugin pour Rust" title="Plugin pour Rust" /></p>
<h2 id="vérification-de-linstallation"><a class="header" href="#vérification-de-linstallation">Vérification de l'installation</a></h2>
<p>Si il n'y a pas de messages d'erreur, <em><strong>BRAVO</strong></em> tu viens d'installer avec succès le plugin Rust pour CLion !</p>
<h1 id="compilation-dun-projet"><a class="header" href="#compilation-dun-projet">Compilation d'un projet</a></h1>
<p>Maintenant c'est la dernière étape, le grand moment : nous allons compiler un projet.</p>
<p>C'est le moment de lancer CLion ! Une fois lancé, dans <code>File &gt; Open</code> choisi le dossier de <code>black-pill</code>.</p>
<p>Si tout se passe bien, tu devrais pouvoir compiler, tester et formater le code. Pour cela, il faut choisir la configuration adéquate, en haut à droite de ton interface et appuyer sur le bouton <code>run</code>.</p>
<p>Si la compilation fonctionne, tu peux passer à la suite c'est tout bon tu as tout installé avec succès !</p>
<h2 id="compilation-à-la-mano"><a class="header" href="#compilation-à-la-mano">Compilation à la mano</a></h2>
<p>Tu peux aussi compiler à la main (pratique parfois).</p>
<p>Pour cela, une fois à la racine du projet, exécute :</p>
<pre><code>cargo build --release --features = "primary" 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pour-flasher-une-carte"><a class="header" href="#pour-flasher-une-carte">Pour flasher une carte</a></h1>
<p>Commences par câbles un ST-LINK sur la carte. Sur l'image c'est une blue-pill, mais l'ordre des pins et le câblage est le même !</p>
<p><img src="pre_2021/elec_soft/mise_en_place/../../images/elec_soft/F103C8T6_w_ST-Link.jpg" alt="test" />
Une fois câblé, lances OpenOCD à la racine du projet :</p>
<pre><code>sudo openocd -f black_pill.cfg
</code></pre>
<p>Si le ST-LINK a été bien câblé, alors OpenOCD devrait rester ouvert en tache de fond.</p>
<p>Une fois openocd en tâche de fond, il suffit de lancer dans un terminal le script <code>debug.sh</code> qui se trouve dans le dossier du projet pour flasher la carte.</p>
<h2 id="precautions-pour-le-deboggage"><a class="header" href="#precautions-pour-le-deboggage">Precautions pour le deboggage</a></h2>
<ul>
<li>Ne pas poser de cartes non vernies directement sur l'armature métallique du robot, cela peut créer des court-circuits dans la carte et l'endommager !</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apprendre-rust"><a class="header" href="#apprendre-rust">Apprendre Rust</a></h1>
<p>Pour apprendre Rust, en parallèle avec la formation le mieux reste de lire <a href="https://doc.rust-lang.org/book/second-edition/">The Rust Book</a> (deuxième édition). Il s'agit du meilleur moyen d'apprendre le langage, mais ce n'est pas le seul.</p>
<p>Voici une liste de ressources non exhaustive qui te servira peut être un jour :</p>
<ul>
<li><a href="https://rust-embedded.github.io/book/">The Embedded Rust Book</a> : Un bouquin expliquant comment fonctionne l'embarqué et la programmation sur microcontrôleur en Rust. <strong>Très bonne lecture</strong> :)</li>
<li><a href="http://rustbyexample.com/">Rust by example</a> : Une collection d'exemples permettant de comprendre les concepts du langage, très bonne lecture en complément de <em>The Rust Book</em>.</li>
<li><a href="https://doc.rust-lang.org/book/">The Rust Book v1</a> : A lire si le chapitre que tu cherches n'est pas dans la v2. Le livre n'est pas obsolète, mais il est moins bien que la v2.</li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">The Cookboook</a> : Un livre de <em>recettes</em> pour des opérations classiques.</li>
<li><a href="https://doc.rust-lang.org/std/">La documentation de la librairie standard</a> : La référence de toutes les fonctions/structures/traits/méthodes de la librairie standard.</li>
</ul>
<p>Il existe aussi une série de posts de blogs, c'est toujours pratique pour apprendre surtout quand c'est en Français :</p>
<ul>
<li><a href="http://blog.guillaume-gomez.fr/Rust">Tutoriel Rust</a> - Guillaume Gomez</li>
<li><a href="https://levans.fr/borrowing-and-lifetimes-in-rust-fr.html">Les emprunts et les durées de vies en Rust</a> - Victor Berger</li>
<li><a href="https://github.com/Songbird0/Rust_FAQ">Retrouvez un grand nombre de Questions/Réponses dans cette FAQ dédiée à rust !</a> - Anthony Defranceschi/Songbird0</li>
<li><a href="https://github.com/Songbird0/FR_RBE">Traduction française du livre Rust by example</a> - Anthony Defranceschi/Songbird0</li>
</ul>
<p>Enfin il y a une <a href="https://github.com/ctjhoa/rust-learning">page github</a> qui recense encore plus de ressources que tu peux toujours consulter.</p>
<p>Pour la programmation embarquée il y a aussi de la documentation, la plupart est recensée sur <a href="https://github.com/rust-embedded/awesome-embedded-rust">awesome-embedded</a>.</p>
<p>Il y enfin quelques posts de blogs bien pratiques, ainsi que de la documentation de certaines librairies :</p>
<ul>
<li><a href="https://japaric.github.io/discovery/">Une série de post d'introduction sur un stm32discovery</a> - Japaric</li>
<li><a href="http://blog.japaric.io/quickstart/">Un post qui date des débuts de Rust sur microcontrolleur</a> - Japaric</li>
<li><a href="http://blog.japaric.io/fearless-concurrency/">Introduction au framework RTFM</a> - Japaric</li>
<li><a href="http://blog.japaric.io/rtfm-v2/">Evolution du framework RTFM</a> - Japaric</li>
<li><a href="https://docs.rs/cortex-m-quickstart/0.3.1/cortex_m_quickstart/">La description de la librairie <code>cortex-m-quickstart</code></a></li>
<li><a href="https://docs.rs/embedded-hal/0.2.1/embedded_hal/">La description de la librairie <code>embedded-hal</code></a></li>
</ul>
<h1 id="aide"><a class="header" href="#aide">Aide</a></h1>
<p>Tu as besoin d'aide ?
Le meilleur moyen de résoudre ton problème est d'aller sur le chan <strong>#rust-beginners</strong> sur le <a href="pre_2021/elec_soft/irc.mozilla.org">serveur IRC</a> de Mozilla.
Si tu n'as pas de client IRC, tu peux aussi passer par une <a href="https://client00.chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust-beginners">interface web</a>.</p>
<p>Pour des questions plus complexes, tu peux aussi poster sur <a href="https://www.reddit.com/">reddit</a> ou demander aux gens du club ! :wink:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communication-des-modules-avec-linformatique"><a class="header" href="#communication-des-modules-avec-linformatique">Communication des modules avec l'informatique</a></h1>
<p>L'informatique et l'électronique doivent se mettre d'accord sur les trames envoyées pour communiquer.</p>
<p>Un réseau RJ45 est déployé dans le robot et chaque carte possède sa propre IP en <code>192.168.1.ID_CARTE</code> si il s'agit du robot primaire ou en <code>192.168.2.ID_CARTE</code> si il s'agit du robot secondaire.</p>
<p>Le PC embarqué possède une adresse au même format (192.168.X.254). Typiquement, la carte déplacement du second robot possède l'adresse 192.168.2.1.</p>
<p>L'informatique s’attend à recevoir les informations de la carte <code>ID_CARTE</code> sur le port 5000 + ID_CARTE. Cette même carte écoute sur le port 50 + ID_CARTE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="electronique-matérielle-1"><a class="header" href="#electronique-matérielle-1">Electronique matérielle</a></h1>
<p>Cette section est réservée à l'électronique matérielle au club robot. Ici tu apprendras le nécessaire pour atteindre le but ultime de tout électronicien au club : produire des cartes électroniques qui</p>
<ul>
<li>Ne prennent pas feu</li>
<li>Actionnent des moteurs</li>
<li>Exploitent des mesures de capteurs</li>
</ul>
<p>Les trois ressources principales en plus de cette doc sont :</p>
<ol>
<li><a href="https://openclassrooms.com/fr/courses/724810-lelectronique-de-zero">Openclassrooms</a> : Tu y trouveras un cours d'électronique générale, plutôt clair. C'est un très bon point de départ avant de se plonger dans le robot.</li>
<li>Le <a href="http://www.falstad.com/circuit/">simulateur de circuit Falstad</a> : Rapide à prendre en main pour simuler et mieux comprendre des circuits usuel. Je te recommande <strong>tres</strong> fortement d'y faire un tour rapide maintenant pour voir ce que tu peux faire avec. Son alternative professionelle est LTSpice.</li>
<li>La <a href="https://archipel-univtoulouse.hosted.exlibrisgroup.com/primo-explore/fulldisplay?docid=33TOUL_ALMA21413566170004116&amp;context=L&amp;vid=33INSA_VU1&amp;lang=fr_FR&amp;search_scope=default_scope&amp;adaptor=Local%20Search%20Engine&amp;isFrbr=true&amp;tab=default_tab&amp;query=any,contains,Syst%C3%A8mes%20%C3%A9lectroniques%20analogiques%20Amplification%20%20Filtrage%20et%20optronique&amp;sortby=date&amp;facet=frbrgroupid,include,102068340&amp;mode=Basic&amp;offset=0">Bible</a>, rédigée par nos professeurs d'électronique favoris. C'est une très bonne référence quand tu as envie d'en savoir plus sur un détail qui n'est pas assez ou mal expliqué en cours ou sur openclassrooms. Un exemplaire est disponible en lecture au Club, et il est facile à trouver dans nos BUs (cf. lien ci-dessus).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mise-en-place-3"><a class="header" href="#mise-en-place-3">Mise en place</a></h1>
<p>Installons les logiciels pour router des cartes éléctroniques ! Au club robot nous utilisons <a href="https://en.wikipedia.org/wiki/KiCad">KiCad</a>. Certains d'entre vous connaissent peut être Eagle mais la version Linux de ce dernier n'est pas au point du tout. De plus c'est un logiciel payant (on peut certes avoir des licenses étudiantes) alors que KiCad est un logiciel libre.</p>
<h1 id="installation-de-kicad"><a class="header" href="#installation-de-kicad">Installation de Kicad</a></h1>
<p>Tu peux installer KiCad sur les trois principaux OS : Ubuntu, Windows et OSX. Il faut faire attention à bien installer la version 5 !</p>
<p>Pour les autres distributions Linux demande directement aux gens du club !</p>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<h3 id="ubuntu"><a class="header" href="#ubuntu">Ubuntu</a></h3>
<p>Il suffit de rentrer les trois commandes suivantes pour obtenir la dernière version de Kicad (Kicad 5) :</p>
<p>** A Verifier **</p>
<pre><code class="language-bash">sudo add-apt-repository --yes ppa:js-reynaud/kicad-5
sudo apt update
sudo apt install kicad
</code></pre>
<p>Ces commandes sont nécessaires car on utilise la version 5 de Kicad qui est encore en beta.</p>
<p>Tu peux vérifier que l'installation a bien fonctionné en lançant Kicad. Normalement KiCad est livré avec des librairies de composants. Si elles ne sont pas installées chez toi, rapproche-toi d'un membre du club !</p>
<h3 id="osx"><a class="header" href="#osx">OSX</a></h3>
<p>Il existe deux méthodes pour installer Kicad sur un Mac. La classique en allant sur http://kicad-pcb.org/download/osx/, puis en telechargeant la dernière version stable, ou avec Homebrew.</p>
<p>Homebrew et fonctionne à peu près comme aptitude sur Linux. C'est un très bon outil qui permet d'installer facilement beaucoup d'applications disponibles sur Linux mais pas nativement sur mac (comme wget par exemple). Je profite juste de l'installation de Kicad pour présenter cet outil très utile.
N'hésite pas à faire un tour sur leur site pour en savoir plus, je ne parlerai ici que du nécéssaire pour installer Kicad.</p>
<p>https://brew.sh/index_fr</p>
<p>Pour installer homebrew, il suffit d'executer cette ligne dans un terminal :</p>
<pre><code class="language-bash">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></pre>
<p>Cette ligne télécharge et éxécute l'installeur pour Brew. Laisse-toi guider, il décrit ce qu'il fait au fur et a mesure de l'installation.</p>
<p>Une fois l'install terminée, il faut installer une extension de Brew appellée 'cask'. Elle permet d'installer proprement des applicaitons en passant par le téléchargement et la vérification du .app.</p>
<pre><code class="language-bash">brew install cask
</code></pre>
<p>Tout est prêt ! Il ne reste plus qu'à installer la dernière version de Kicad. Attention le téléchargement est lourd (3GB environ).</p>
<pre><code class="language-bash">brew cask install kicad
</code></pre>
<p>Kicad est désormais correctement installé sur ton ordinateur et peut s'utiliser comme n'importe quelle autre application.
Il est recommandé d'installer ses apps avec Homebrew autant que possible. Pour savoir si une app est disponible sur leurs dépôts, utilise</p>
<pre><code class="language-bash">brew search [nom à rechercher]
</code></pre>
<p>Si brew trouve des résultats, un simple  <code>brew install [nom trouvé]</code> se chargera de l'installation.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Il suffit de récupérer et lancer l'installeur le plus récent parmis tout ceux proposés sur <a href="http://downloads.kicad-pcb.org/windows/nightly/">cette</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organisation-1"><a class="header" href="#organisation-1">Organisation</a></h1>
<h2 id="organisation-des-dossiers"><a class="header" href="#organisation-des-dossiers">Organisation des dossiers</a></h2>
<p>Voici une arborescence typique d'un dossier de travail en cours d'année :</p>
<pre><code>hardware
├── boards
│   ├── pump_2019_f103
│   └── servo_2019_f103
├── digikey-kicad-library
│   ├── digikey-footprints.pretty
│   ├── digikey-symbols
│   └── src
└── libkicad-robot
    ├── @Robot_symbols 
    ├── @Robot.3D
    ├── @Robot.pretty
    ├── datasheets
    ├── projets communs
    └── libeagle-robot

</code></pre>
<p>On y retrouve 3 dossiers :</p>
<ul>
<li>les cartes en cours de travail (le dossier <code>boards</code>)</li>
<li>la librairie du club (le dossier <code>kicad</code>)</li>
<li>la librairie de digikey (le dossier <code>digikey-kicad-library</code>)</li>
</ul>
<h3 id="dossier-boards"><a class="header" href="#dossier-boards">Dossier <code>boards</code></a></h3>
<p>Dans ce dossier, il y a pour chaque carte un dossier avec comme nom <code>&lt;fonction&gt;_&lt;année de la coupe&gt;_&lt;µc&gt;</code> écrit en <a href="https://fr.wikipedia.org/wiki/Snake_case">snake_case</a>. Dans le dossier de la carte on retrouve :</p>
<ul>
<li>le projet kicad, un fichier <code>.pro</code></li>
<li>le schematic de la carte, un fichier <code>.sch</code></li>
<li>le routage de la carte, un fichier <code>.pcb</code>
NB : la liste des cartes est accessible dans les references de ce chapitre.</li>
</ul>
<h3 id="dossier-libkicad-robot"><a class="header" href="#dossier-libkicad-robot">Dossier <code>libkicad-robot</code></a></h3>
<p>On retrouve 6 dossiers importants dans celui-ci :</p>
<ul>
<li>Trois dossiers <code>@Robot</code> : les librairies de composants propres au Club</li>
<li><code>datasheets</code> : les datasheets des composants du club et autres documents importants</li>
<li><code>projets communs</code> :  des cartes et des blocs élémentaires qui servent de base aux projets</li>
<li><code>libeagle-robot</code> : les anciennes librairies du Club</li>
</ul>
<h2 id="organisation-des-projets-git"><a class="header" href="#organisation-des-projets-git">Organisation des projets git</a></h2>
<p>Chaque carte a un projet git unique afin de découpler totalement les cartes du la librairie de symbole.</p>
<p>On peut ainsi utiliser l'onglet <strong>release</strong> pour uploader les typons, le plan d'implantation et le <em>bill of materials</em> afin de pouvoir retrouver toutes ces informations un jour.</p>
<p>L'onglet <strong>issue</strong> du repo sers à suivre les problèmes et les choses à faire sur la carte.</p>
<p>L'onglet <strong>projet</strong> permet de suivre l'avancement de la carte.</p>
<p>Par exemple pour la carte <a href="https://github.com/ClubRobotInsat/deplacement_2019_f103">deplacement_2019_f103</a> dans l'onglet <a href="https://github.com/ClubRobotInsat/deplacement_2019_f103/issues">issues</a> on retrouve les tâches à faire (si elles n'ont pas été toutes faîtes).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-de-la-librairie-et-des-projets-du-club-robot"><a class="header" href="#installation-de-la-librairie-et-des-projets-du-club-robot">Installation de la librairie et des projets du Club Robot</a></h1>
<p>Pour obtenir les composants du club afin de pouvoir ouvrir correctement les cartes que nous avons réalisée par le passé, il suffit de te préparer un dossier conforme à l'arborescence décrite dans la page précédente. Pour cela, il faut ouvrir un terminal, te placer là ou tu souhaites tout installer, et entrer ces commandes :</p>
<pre><code class="language-bash"># On construit l'arborescence
mkdir -pv hardware/boards
cd hardware
# On y clone les librairies du Club et de DigiKey
git clone https://github.com/ClubRobotInsat/libkicad-robot.git
git clone https://github.com/digikey/digikey-kicad-library.git
</code></pre>
<p>Ne ferme pas le terminal, on n'en a pas fini :)</p>
<p>Si tu n'as pas <code>git</code> sur ton ordinateur je te renvoie à la section <a href="pre_2021/elec_mat/mise_en_place/git.html">correspondante</a>.</p>
<p>Il faut maintenant ouvrir un terminal et configurer <code>git</code> pour qu'il s'interface bien avec Kicad. Pour cela tu dois lancer le script <code>setup_git.sh</code> :</p>
<pre><code class="language-bash"># On se place dans le dossier où tu as clone le repo du club
cd kicad
# On lance le script
./setup_git.sh
</code></pre>
<p>Il faut ensuite rajouter ces librairies avec l'interface de Kicad.</p>
<h2 id="ajout-des-la-librairies-de-symboles-et-de-footprints"><a class="header" href="#ajout-des-la-librairies-de-symboles-et-de-footprints">Ajout des la librairies de symboles et de footprints</a></h2>
<ol start="0">
<li>Ouvre Kicad, puis ouvre <code>Preferences -&gt; Configure Paths...</code>. On va indiquer où Kicad doit chercher nos librairies. Normalement, tu obtiens une fenêtre qui liste tous les <em>Paths</em> (chemins de fichiers, comme sur linux) gérés par Kicad. On va y ajouter le nôtre : clique sur <code>Add</code>, puis entre :</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td>KIROBOT</td><td><code>Ton dossier **hardware**</code>/libkicad-robot</td></tr>
</tbody></table>
</div>
<ol>
<li>
<p>Ouvre ensuite l'éditeur de symbole, pour cela clique sur le petit composant (deuxième carré en partant de la gauche)</p>
<p><img src="pre_2021/elec_mat/mise_en_place/assets/kicad/open_symbol_editor.png" alt="Cliques sur le bouton rouge pour ouvrir l&#39;éditeur de symbole" /></p>
</li>
<li>
<p>Ensuite, il faut rajouter la librairie contenant les <em>symboles</em> du club : <code>Preferences &gt; Manage Symbol Libraries</code>.
Dans le menu qui va s'ouvrir, clique sur <code>Browse Libraries</code> et navigue jusqu'au dossier <code>hardware/libkicad-robot/@Robot_symbols</code> et séléctionne <code>@Robot.lib</code>
Normalement tu as le résultat suivant à la fin de cette opération.
<img src="pre_2021/elec_mat/mise_en_place/assets/kicad/symbol_added.png" alt="La librairie de symboles après ajout des symboles du club robot" />
Si tu observes la même chose alors tu as réussi ton installation ! Tu peux maintenant ouvrir les <em>schematic</em> du club robot sans problème !</p>
</li>
<li>
<p>Tu peux fermer l'éditeur de symbole et passer sur l'éditeur de <em>footprint</em>, c'est le quatrième bouton en partant de la gauche.
<img src="pre_2021/elec_mat/mise_en_place/assets/kicad/open_footprint_editor.png" alt="Cliques sur le bouton rouge pour ouvrir l&#39;éditeur de footprint" /></p>
</li>
<li>
<p>Ouvre le gestionnaire de librairie <code>Preferences &gt; Manage footprint libraries</code> et cliques sur <code>Browse Libraries</code> dans la fenêtre qui s'ouvre.</p>
</li>
<li>
<p>Navigue jusqu'à arriver au répertoire <code>hardware/libkicad-robot/@Robot.pretty</code> et clique sur Ok.</p>
</li>
<li>
<p>Normalement tu devrais obtenir le résultat suivant :
<img src="pre_2021/elec_mat/mise_en_place/assets/kicad/footprint_added.png" alt="La librairie de footprints aprés ajout de celle du club" /></p>
</li>
<li>
<p>Répète les opérations 1 à 6 pour ajouter à KiCAD n'importe quelle source externe de composants. Nous utilisons aussi ponctuellement les librairies offertes par DigiKey (distributeur de composants élec en ligne). Importe leurs libs dans <code>hardware/digikey-kicad-library</code> (<em>ctrl-a</em> te sera utile pour les symbols).</p>
</li>
<li>
<p>Si tout s'est bien passé <strong>BRAVO</strong> tu peux maintenant ouvrir et modifier toutes les cartes du club robot et créer les tiennes !</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-dutilisation-de-kicad"><a class="header" href="#guide-dutilisation-de-kicad">Guide d'utilisation de Kicad</a></h1>
<h2 id="intro"><a class="header" href="#intro">Intro</a></h2>
<p>On parlera ici de l'utilisation de KiCAD spécifique au club. Pour l'utilisation générale, consulte la doc inclue dans KiCAD, dans le menu aide/help. Elle est claire, et très bien complétée sur internet par une série de vidéos produites par <a href="https://www.youtube.com/watch?v=vaCVh2SAZY4&amp;index=9&amp;list=PLEBQazB0HUyR24ckSZ5u05TZHV9khgA1O&amp;t=0s">DigiKey</a>.</p>
<p>La réalisation d'une carte suit le <img src="pre_2021/elec_mat/../images/kicad/kicad_flowchart.png" alt="workflow" /> indiqué dans la doc de kicad.</p>
<h2 id="ouverture-dune-carte"><a class="header" href="#ouverture-dune-carte">Ouverture d'une carte</a></h2>
<p>Quand tu souhaites visualiser ou modifier une carte, ouvre (double clic) son fichier projet (.pro) ou ouvre directement son schematic avec kicad. Il se peut que des symboles soient 'cassés' : ils sont remplacés par les points d'interrogation. Dans ce cas, édite les : clic droit -&gt; properties -&gt; edit properties et choisis 'change' sous le champ 'Library Symbol'. Remplace alors le symbole par sa version à jour. Si tu ne le trouve nulle part, vérifie si tu as bien importé les librairies du club, et celles offertes par DigiKey.</p>
<h2 id="création-dune-carte"><a class="header" href="#création-dune-carte">Création d'une carte</a></h2>
<p>Pour créer une carte, il faut suivre <em>méticuleusement</em> le protocole suivant pour être certain de ne pas imprimer de carte inutilisable, ou juste trop difficile à imprimer.</p>
<p><strong>1) Pose toi la question de quel template utiliser.</strong></p>
<p>Pour le moment le club n'en a qu'un seul pour une carte classique avec une blackpill et un USR-US1 (le connecteur ethernet) dessus. Copie donc le template <code>libkicad-robot/templates/carte_generique_2019_stm32f103</code> dans ton dossier <code>boards</code>. et renomme le dossier et les fichiers en suivant cette convention :</p>
<pre><code>boards
├── {fonction}_{année}_{microcontrôleur}
│   ├── {fonction}_{année}_{microcontrôleur}.pro
│   ├── {fonction}_{année}_{microcontrôleur}.sch
│   └── {fonction}_{année}_{microcontrôleur}.kicad_pcb
</code></pre>
<p>Dans la mesure du possible, tous les noms <em>sont_en_minuscules_séparés_par_des_underscores</em> (convention snake_case).</p>
<p><strong>2) Préparaion du schematic</strong></p>
<p>Dans un premier temps, il faut remplir l'encadré en bas à droite avec l'insertion de texte, c'est à dire remplir les champs en gras (nom, prénom, date, titre de la carte). La date sera actualisée à chaque grosse mise à jour.
Chaque fichier et chaque carte doit être tracable en cas de besoin. Ceux qui reprendront ta carte quand tu auras quitté le club doivent avoir quelqu'un à qui poser les questions !</p>
<p><strong>3) Préparation du routage</strong></p>
<p>Ouvre maintenant le pcb de ta nouvelle carte et <strong>VERIFIE LES DESIGN RULES</strong>. Il va falloir bien suivre, la suite est très importante et te fera gagner <em>beaucoup</em> de temps. \n Un peu de contexte : plus une piste est large, plus elle peut conduire du courant sans chauffer. Une piste qui chauffe, ca veut dire des soudures qui fondent ou des composants qui grillent. Mais plus une piste est large, plus le routage sera difficile. Le nouveau jeu est donc de dimensionner chaque piste en fonction de son utilisation : pistes fines pour du signal, pistes larges pour la puissance.</p>
<p>Pour cela, la solution idéale serait justement de pouvoir indiquer à KiCAD quelles connexions seront utilisées pour de la logique, et quelles connexions feront passer des gros courants. Ca tombe bien ! <em>Setup -&gt; Design rules...</em> à été inventé pour ca. C'est un processus en deux étapes.</p>
<ul>
<li>
<p>D'abord on remplit le tableau 'Net classes'. On indique à KiCAD la liste des différents types de connexion.
La plupart du temps nous n'aurons que des pistes logiques. Tant qu'il n'y a pas de puissance, change la classe <code>default</code>en y entrant 0.381 dans <code>Clearance</code> et 0.381 dans <code>Track Width</code>.</p>
</li>
<li>
<p>Ouvre ensuite l'onglet <code>Global Design Rules</code> et remplis le tableau (en bas à droite) :</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th>Width</th></tr></thead><tbody>
<tr><td>Track 1</td><td>0.254</td></tr>
<tr><td>Track 2</td><td>0.381</td></tr>
<tr><td>Track 3</td><td>0.762</td></tr>
</tbody></table>
</div>
<p>Ce sont les trois épaisseurs <em>standard</em> qu'utilise le club. Quand tu choisiras ton épaisseur de piste (en haut à gauche de l'interface de pcbnew), tu devras utiliser la 3 quand c'est possible, puis la 2 si nécéssaire, puis la 1 <strong>sur une distance très courte</strong> dans le pire des cas.</p>
<p>Pour finir, il faut remplir compléter le texte à l'envers (nom, prénom, date, titre de la carte). Il sert à rendre ta carte encore mieux tracable, et à aider à l'imprimer à l'endroit.</p>
<p>En principe, tout est prêt pour que tu commences à ajuster le schematic puis à dessiner le PCB toi-même. Le chapitre suivant donne des indications et explique le fonctionnement de certains outils usuels.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conseils--astuces-pour-réussir-sa-carte"><a class="header" href="#conseils--astuces-pour-réussir-sa-carte">Conseils &amp; Astuces pour réussir sa carte</a></h1>
<h2 id="organisation-et-clarté-su-schematic"><a class="header" href="#organisation-et-clarté-su-schematic">Organisation et clarté su schematic</a></h2>
<p>La règle d'or lors du dessin d'un schematic est la <strong>lisibilité</strong> ! Comme il ne représente rien en réalité, il faut qu'il soir le plus lisible possible, et le plus facile à modifier !
Deux outils sont indispensables à maitriser (pas de vraie difficulté) :</p>
<h3 id="place-graphic-lines-or-polygons"><a class="header" href="#place-graphic-lines-or-polygons">"Place graphic lines or polygons"</a></h3>
<p>Il te permet d'encadrer chaque partie de ton circuit. On cherche en général à l'organiser (donc diviser) en fonctions élémentaires. Par exemple, tous les connecteurs de puissance seront à un endroit, toutes les led dans un autre, le microcontroleur sera au centre etc... Chaqun de ces bloc-fonction doit être encadré et nommé avec l'outil "Place text".</p>
<h3 id="place-net-label"><a class="header" href="#place-net-label">"Place net label"</a></h3>
<p>Il est l'heure de te présenter ton nouvel outil favori. Petit retour théorique : le potentiel électrique (tension par rapport à la masse, ou 'altitude electrique') est le même le long d'un fil. C'est toujours valable si deux fils sont connectés ! Ils forment alors un <strong>noeud</strong> (de fils), ou <strong>net</strong> en anglais. On comprend alors que le potentiel electrique est le même partout sur un noeud donné ! L'équivalent <strong>noeud &lt;=&gt; potentiel</strong> nous permet de nommer une connexion entre plusieurs parties du circuit : c'est le <strong>net label</strong>. L'opportunité est fantasique : tu n'as plus besoin de connecter des composants avec des fils (ce sera brouillon rapidement), mais tu peux placer un <strong>net label</strong> (appelé label par abus de language) sur chaque pin à connecter, et ce peu importe leur nombre ! Cet outil nous permet de rendre invisible les fils entre les différents blocs : le schematic devient beaucoup plus clair !</p>
<h2 id="ordre-des-priorités-pendant-le-routage"><a class="header" href="#ordre-des-priorités-pendant-le-routage">Ordre des priorités pendant le routage</a></h2>
<p>Pour commencer, il faut savoir ce que tu es en train de faire. Si tu est en train de créer une carte pas très compliquée, ce sera une <em>'simple face'</em>, sinon nous travaillerons en <em>'double face'</em>. La différence est qu'en double face tu pourras placer beaucoup plus de pistes qu'en simple face. Les faces sur lesquelles nous travailleront sont judicieusement nommées Top et Bottom, donc recto et verso.</p>
<p>Deux rappels avant de commencer à dessiner :</p>
<ul>
<li>Deux pistes sur une même face ne peuvent pas se croiser</li>
<li>Les composants traversants ne sont jamais du même côté que les pistes auxquelles ils sont connectés, sinon ils seront impossibles à souder !</li>
</ul>
<p>Par défaut, place les <strong>composants traversants</strong> au <strong>TOP</strong> et les <strong>pistes et cms</strong> au <strong>BOTTOM</strong>.</p>
<h2 id="placement-des-composants"><a class="header" href="#placement-des-composants">Placement des composants</a></h2>
<p>Avant de connecter les composants, il faut les placer (<em>duh</em>). Il n'y a pas de règle générale pour t'aider. Ca se fait très empiriquement. On commence au moins par placer les connecteurs et les led sur les bords de la carte. Dans la mesure du possible, il vaut mieux n'utiliser que deux arrêtes opposées : les entrées à gauche du microcontroleur et les sorties à droite. Tout sera plus simple pendant le câblage. Fais comme tu l'entends, mais pense au futur utilisateur de ta carte : n'hésite pas à abuser du rendu 3D de ta carte pour de demander <em>comment tu peux rendre cette carte facile à utiliser</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faire-tirer-sa-carte"><a class="header" href="#faire-tirer-sa-carte">Faire tirer sa carte</a></h1>
<p>Nous avons trois méthodes disponibles pour faire imprimer des cartes.</p>
<p>Quand tu as ton masque en pdf, tu peux passer par le/la responsable élec pour le <strong>transmettre directement au GEI</strong>. Ils nous improment gratuitement nos cartes simple et double face en 24 à 48h.</p>
<p>Si le temps presse, tu peux aussi <strong>aller directement au FabLab</strong> pour l'imprimer. Toute la procédure y est très bien expliquée là-bas dans un petit livret. N'hésite <strong>jamais</strong> a demander de l'aide à un membre du Club ou du FabLab : tirer une carte amène à manipuler des produits corrosifs.</p>
<p>Solution de dernier recours, nous avons quelquefois besoin de la <strong>commander sur internet</strong> (<a href="https://jlcpcb.com/">jlpcb</a> par exemple). Les cartes imprimées sont très propres et peuvent être multicouches (plus de deux plans). Le prix est cependant plus élevé qu'au FabLab, et les cartes mettent généralement longtemps à venir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annexe--références"><a class="header" href="#annexe--références">Annexe : Références</a></h1>
<p>Ici tu trouveras des listes diverses à consulter régulièrement lorsque tu travailles sur du hardware.
Pour le moment, cette annexe contient une liste des composants fréquement utilisés ainsi que l'ensemble des cartes électroniques réalisées ou achetées par le Club.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilisation-du-module-ethernet"><a class="header" href="#utilisation-du-module-ethernet">Utilisation du module ethernet</a></h1>
<p>La communication entre la raspberry pi et les cartes se fait par ethernet (udp) depuis 2018.
Maintenant, la partie matérielle de cette communication est basée sur le connecteur <a href="https://www.usriot.com/download/ES1/USR-ES1-EN%20V1.3.pdf">USR-ES1</a> :</p>
<p><img src="pre_2021/elec_mat/references/../../images/components/USR-ES1_pinout.png" alt="Module Ethernet" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annexe--liste-des-cartes-du-club"><a class="header" href="#annexe--liste-des-cartes-du-club">Annexe : liste des cartes du Club</a></h1>
<p>Voici la liste des cartes que nous avons au Club, utilisées ou non.</p>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Fonction</th><th>Statut</th><th>Stock</th><th>Lien</th></tr></thead><tbody>
<tr><td>Pompes</td><td>Contrôler les pompes à vide</td><td>En développement</td><td>0</td><td><a href="https://github.com/ClubRobotInsat/pump_2019_f103.git">github</a></td></tr>
<tr><td>Servomoteurs</td><td>Communiquer avec et alimenter les herkulex</td><td>En développement</td><td>0</td><td><a href="https://github.com/ClubRobotInsat/servo_2019_f103">github</a></td></tr>
<tr><td>Alim</td><td>Alimenter le robot de manière sécurisée</td><td>Active</td><td>2</td><td><a href="https://svn.etud.insa-toulouse.fr/roboinsat/elec/CarteAlimentation/">svn</a></td></tr>
<tr><td>Alim Raspi</td><td>Alimenter la Raspi de manière sécurisée et indépendante du robot</td><td>Active</td><td>1</td><td></td></tr>
<tr><td>Shield</td><td>Attacher proprement la nucléo au robot, permettre de ne pas utiliser ses jumpers directement</td><td>En refonte</td><td>1</td><td></td></tr>
<tr><td>Pont H</td><td>Alimenter et contrôler les moteurs DC</td><td>Active</td><td>6</td><td></td></tr>
<tr><td>Evitement</td><td>Asservir le moteur de la tourelle</td><td>Obsolète</td><td>1</td><td></td></tr>
<tr><td>Déplacement</td><td>Controler les moteurs de déplacement</td><td>En refonte</td><td>1</td><td><a href="https://github.com/ClubRobotInsat/deplacement_2019_f103">github</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="annexe--liste-des-composants-utilisés"><a class="header" href="#annexe--liste-des-composants-utilisés">Annexe : liste des composants utilisés</a></h1>
<p>Voici une liste <strong>non exhaustive</strong> des composants qu'utilise le club.
N'hésitez pas à la mettre à jour !</p>
<h2 id="connectique"><a class="header" href="#connectique">Connectique</a></h2>
<h3 id="pinsocket-et-pinheaders"><a class="header" href="#pinsocket-et-pinheaders">Pinsocket et pinheaders</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Pinsocket</td><td><a href="http://suddendocs.samtec.com/catalog_english/ssw_th.pdf">Liste</a></td><td>Fixer de manière réversible la nucléo à la carte shield</td></tr>
<tr><td>Pinsocket sécable</td><td>BL1.36Z</td><td>Pinsocket de n'importe quelle longueur.</td></tr>
</tbody></table>
</div>
<h3 id="connexion-carte-à-fil"><a class="header" href="#connexion-carte-à-fil">Connexion carte à fil</a></h3>
<h4 id="he14"><a class="header" href="#he14">HE14</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Connecteur Phoenix 2</td><td><a href="https://fr.farnell.com/phoenix-contact/1725656/bornier-sur-ci-2v-2-54mm/dp/3041359">1725656</a></td><td>Très fiables, 2 terminaux</td></tr>
<tr><td>Connecteur Phoenix 3</td><td><a href="https://fr.farnell.com/phoenix-contact/1725656/bornier-sur-ci-2v-2-54mm/dp/3041359">1725669</a></td><td>Très fiables, 3 terminaux</td></tr>
<tr><td>Connecteur Phoenix 5</td><td><a href="https://fr.farnell.com/phoenix-contact/1725656/bornier-sur-ci-2v-2-54mm/dp/3041359">2776439</a></td><td>Très fiables, 5 terminaux</td></tr>
<tr><td>HE14-f3</td><td>189-9441 (<a href="https://fr.rs-online.com">RS</a>)</td><td></td></tr>
<tr><td>HE14-f2</td><td>189-9435 (<a href="https://fr.rs-online.com">RS</a>)</td><td></td></tr>
<tr><td>HE14-m5</td><td>230-5082 (<a href="https://fr.rs-online.com">RS</a>)</td><td></td></tr>
<tr><td>HE14-m3</td><td>230-5060 (<a href="https://fr.rs-online.com">RS</a>)</td><td></td></tr>
<tr><td>HE14-m2</td><td>230-5054 (<a href="https://fr.rs-online.com">RS</a>)</td><td></td></tr>
</tbody></table>
</div>
<h3 id="autres"><a class="header" href="#autres">Autres</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Terminal Batterie vert</td><td></td><td></td></tr>
<tr><td>Connecteur MXS</td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="puissance"><a class="header" href="#puissance">Puissance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Bouton ARU</td><td></td><td>Contrôler l'alim du robot</td></tr>
<tr><td>Régulateur logique</td><td>PTH08080W</td><td>Passer de Vbat à 5v</td></tr>
<tr><td>Buck réglable</td><td>LM2576</td><td>Diminuer Vbat, utilisé pour avoir les 7.4V des herkulex</td></tr>
<tr><td>Gros interrupteur</td><td>MR02</td><td></td></tr>
<tr><td>Petit interrupteur</td><td></td><td></td></tr>
<tr><td>Fusible automobile</td><td></td><td></td></tr>
<tr><td>Fusible tube</td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="microcontrôleurs"><a class="header" href="#microcontrôleurs">Microcontrôleurs</a></h2>
<h2 id="communication-2"><a class="header" href="#communication-2">Communication</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Transcriever CAN</td><td>MCP2551</td><td></td></tr>
<tr><td>Recepteur IR</td><td>HR12020104</td><td></td></tr>
<tr><td>Magnétomètre</td><td>HMC 5883L</td><td></td></tr>
<tr><td>Accéléromètre 3 axes</td><td>MPU-6050</td><td></td></tr>
<tr><td>Module XBee</td><td>4214A-XBee</td><td></td></tr>
</tbody></table>
</div>
<h2 id="capteurs-1"><a class="header" href="#capteurs-1">Capteurs</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Webcam</td><td>COMedia 3088</td><td></td></tr>
<tr><td>Detecteur IR</td><td>SHARP</td><td></td></tr>
<tr><td>Gros bouton poussoir</td><td></td><td></td></tr>
<tr><td>Petit bouton poussoir</td><td></td><td></td></tr>
</tbody></table>
</div>
<h1 id="cms"><a class="header" href="#cms">CMS</a></h1>
<h2 id="résistances"><a class="header" href="#résistances">Résistances</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Valeur</th><th style="text-align: center">Package 0805</th><th style="text-align: center">Package 1206</th></tr></thead><tbody>
<tr><td>Résistance</td><td>0 R</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>47 R</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>50 R</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>100 R</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>150 R</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>169 R</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>220 R</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>240 R</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>300 R</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>330 R</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>348 R</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>470 R</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>499 R</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>620 R</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>1 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>1,2 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>1,5 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>2,2 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>2,26 kR</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>2,8 kR</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>3,3 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>4,3 kR</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>4,7 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>6,8 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>8,2 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>10 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>11,5 kR</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>12 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>15 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>20 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>22 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>33 kR</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>39 kR</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>43 kR</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>47 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>68 kR</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>75 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>100 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>180 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>200 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>250 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>470 kR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>Résistance</td><td>1 MR</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>2,2 MR</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
</tbody></table>
</div>
<h2 id="condensateurs"><a class="header" href="#condensateurs">Condensateurs</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Valeur</th><th style="text-align: center">Package 0805</th><th style="text-align: center">Package 1206</th></tr></thead><tbody>
<tr><td>22 pf</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>560 pf</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>1 nf</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>1,2 nf</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>2,2 nf</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>4,7 nf</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>10 nf</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>12 nf</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>12 nf</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>90 nf</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"></td></tr>
<tr><td>100 nf</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>220 nf</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>470 nf</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>920 nf</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>1 µf</td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>10 µf</td><td style="text-align: center"></td><td style="text-align: center"><img src="pre_2021/elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
</tbody></table>
</div>
<h2 id="autres-1"><a class="header" href="#autres-1">Autres</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th style="text-align: center">Package</th><th style="text-align: center">Quantité</th><th style="text-align: left">Autres</th></tr></thead><tbody>
<tr><td>Led Jaune</td><td style="text-align: center">1206</td><td style="text-align: center">4</td><td style="text-align: left">2V</td></tr>
<tr><td>Led Vertes</td><td style="text-align: center">1206</td><td style="text-align: center">3</td><td style="text-align: left">2V</td></tr>
<tr><td>Led Rouges</td><td style="text-align: center">1206</td><td style="text-align: center">50+</td><td style="text-align: left">2V</td></tr>
<tr><td>Diode Rectif Schottk</td><td style="text-align: center">2512</td><td style="text-align: center">10+</td><td style="text-align: left">30v, 1A, ref SS13B</td></tr>
<tr><td>Diode Mesure courant</td><td style="text-align: center">1206</td><td style="text-align: center">3</td><td style="text-align: left">0.01R , ref LVK12RO10FER</td></tr>
<tr><td>Optocoupleur</td><td style="text-align: center">8SOIC</td><td style="text-align: center">5</td><td style="text-align: left">ref HCPL-06360-000E</td></tr>
<tr><td>Optocoupleur</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left">ref H11D1</td></tr>
<tr><td>Résistance 0.1R</td><td style="text-align: center">2512</td><td style="text-align: center">20</td><td style="text-align: left">2W, 5%</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="cablage-du-robot"><a class="header" href="#cablage-du-robot">Cablage du Robot</a></h1>
<p>Pour le cablage de la carte déplacement, il y a le schéma suivant :</p>
<p><img src="pre_2021/elec_mat/../images/cablage_robot.png" alt="" title="Cablage du robot" /></p>
<p>Les conventions couleurs sont celles décrites sur le côté des roues codeuses, n'hésitez pas à vous y réferer !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documents-de-référence"><a class="header" href="#documents-de-référence">Documents de référence</a></h1>
<p>Cette section contiens la documentation pour chaque carte electronique.</p>
<p>Cette documentation est composée de :</p>
<ul>
<li>liste des composants spéciaux et leur datasheet</li>
<li>format du protocole de communication</li>
</ul>
<p><a href="pre_2021/reference/reference/commun.html">Commun</a> contiens tout ce qui est commun à toute les cartes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communs"><a class="header" href="#communs">Communs</a></h1>
<h1 id="sommaire-1"><a class="header" href="#sommaire-1">Sommaire</a></h1>
<ol>
<li><a href="pre_2021/reference/commun.html#communication">Communication</a></li>
<li><a href="pre_2021/reference/commun.html#microcontroleur">Microcontrôleur</a></li>
<li><a href="pre_2021/reference/commun.html#black-pill">Black-Pill</a></li>
<li><a href="pre_2021/reference/commun.html#quartz">Quartz</a></li>
</ol>
<h2 id="communication-3"><a class="header" href="#communication-3">Communication</a></h2>
<p>Pour la communication on utilise sur nos cartes un composants tout fait : le w5500.</p>
<p><a href="pre_2021/reference/../datasheets/w5500/w5500.pdf">Datasheet du w5500</a>.</p>
<p>Ce composant est monté sur une minicarte toute faîte que l'on achète chez <a href="https://www.makerfabs.com/Mini-Ethernet-Board-W5500.html">makerfabs</a>. (si le lien meurs, cherchez "mini ethernet board w5500").</p>
<p><img src="pre_2021/reference/../images/components/w5500.jpg" alt="Image de la mini carte" /></p>
<p><a href="pre_2021/reference/../datasheets/w5500/w5500_board_sizes.pdf">Dimension de la carte</a></p>
<p><a href="pre_2021/reference/../datasheets/w5500/w5500_board_schem.pdf">Schematic de la carte</a></p>
<p><img src="pre_2021/reference/../datasheets/w5500/w5500_board_pcb.png" alt="PCB de la carte" /></p>
<p>Coté logiciel, il existe une librairie sur <a href="https://crates.io/crates/w5500">crates.io</a>.</p>
<hr />
<h2 id="microcontroleur"><a class="header" href="#microcontroleur">Microcontroleur</a></h2>
<p>On utilise en ce moment le <a href="https://www.st.com/en/microcontrollers/stm32f103.html?querycriteria=productId=LN1565">stm32f103</a>.</p>
<p>Il viens en plusieurs déclinaisons (ce sont les lettres qui viennent derrière le nom du microcontrôleur). Les principales différences entre ces déclinaisons sont :</p>
<ul>
<li>Taille de la RAM</li>
<li>Taille de la flash</li>
<li>Nombre de timers</li>
</ul>
<p><a href="pre_2021/reference/../datasheets/stm32f103/f103_ref_manual.pdf">Manuel de référence de la famille des cortex M1</a></p>
<p><a href="pre_2021/reference/../datasheets/stm32f103/cortex_m1_ref_manual.pdf">Datasheet de la puce</a></p>
<hr />
<h2 id="black-pill"><a class="header" href="#black-pill">Black-Pill</a></h2>
<p>Pour le prototypage on utilise un <a href="pre_2021/reference/commun.html#microcontroleur">stm32f103</a> monté sur un PCB déjà routé.
La carte s'appelle <a href="https://robotdyn.com/stm32-arm-arduino-mini-system-dev-board-blue-pill-with-arduino-bootloader.html">black-pill</a>.</p>
<p><a href="pre_2021/reference/../datasheets/black-pill/black-pill-pinout.pdf">Pinout de la carte</a></p>
<p><a href="pre_2021/reference/../datasheets/black-pill/black-pill-schematic.pdf">Schematic de la carte</a></p>
<p><a href="https://wiki.stm32duino.com/index.php?title=Black_Pill">Plus d'informations sur la carte</a></p>
<hr />
<h2 id="quartz"><a class="header" href="#quartz">Quartz</a></h2>
<p>Le microcontroleur a besoin d'un signal d'horloge fixé pour pouvoir fonctionner correctement. Ce signal est généré par un <a href="https://fr.wikipedia.org/wiki/Quartz_(%C3%A9lectronique)">quartz</a> qu'il faut choisir selon plusieurs critères.</p>
<p>Le quartz a également besoin de composants externes pour fonctionner correctement : il faut ajouter 2 condensateurs de même valeur et éventuellement une résistance, selon le schéma suivant :</p>
<p><img src="pre_2021/reference/../images/components/Schema_quartz.png" alt="Schema_quartz" /></p>
<p>Le condensateur <a href="https://www.codecogs.com/eqnedit.php?latex=C_S" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_S" title="C_S" /></a> correspond à la capacité parasite due aux fils. On peut l'approximer à 5 pF dans les calculs.</p>
<p><strong>1. La marge de gain</strong></p>
<p>Pour faire naitre les oscillations dans le cristal, il faut s'assurer que la transconductance interne du microcontroleur (<a href="https://www.codecogs.com/eqnedit.php?latex=g_m" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_m" title="g_m" /></a>) est au moins 5 fois supérieure à celle du quartz choisi.
La marge de gain se calcule grâce a la formule suivante :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=Gain_{margin}=\frac{g_m}{g_{mcrit}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?Gain_{margin}=\frac{g_m}{g_{mcrit}}" title="Gain_{margin}=\frac{g_m}{g_{mcrit}}" /></a></p>
<p>Avec <a href="https://www.codecogs.com/eqnedit.php?latex=g_{mcrit}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_{mcrit}" title="g_{mcrit}" /></a> donné par la formule :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=g_{mcrit}&space;=&space;4*ESR*(2\pi&space;F)^2*(C_0&space;&plus;&space;C_L)^2" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_{mcrit}&space;=&space;4*ESR*(2\pi&space;F)^2*(C_0&space;&plus;&space;C_L)^2" title="g_{mcrit} = 4*ESR*(2\pi F)^2*(C_0 + C_L)^2" /></a></p>
<p>Où :</p>
<ul>
<li><a href="https://www.codecogs.com/eqnedit.php?latex=\textrm{ESR}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\textrm{ESR}" title="\textrm{ESR}" /></a> = <em>Equivalent Series Resistor</em> : la résistance série équivalente du quartz (donnée par le fabriquant, elle dépend de la fréquence de fonctionnement).</li>
<li><a href="https://www.codecogs.com/eqnedit.php?latex=\textrm{F}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\textrm{F}" title="\textrm{F}" /></a> = Fréquence de fonctionnement du quartz (donnée par le fabriquant).</li>
<li><a href="https://www.codecogs.com/eqnedit.php?latex=C_0" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_0" title="C_0" /></a> = <em>Shunt capacitance</em> : c'est la valeur de la capacité résultante des électrodes du quartz (donnée par le fabriquant).</li>
<li><a href="https://www.codecogs.com/eqnedit.php?latex=C_L" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_L" title="C_L" /></a> = <em>Load capacitance</em> (donnée par le fabriquant)</li>
</ul>
<p>La valeur de <a href="https://www.codecogs.com/eqnedit.php?latex=g_m" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_m" title="g_m" /></a> se trouve dans la datasheet du microcontrôleur.</p>
<p>Si la marge de gain calculée est bien supérieure à 5, on peut passer à l'étape suivante. Sinon, il faut choisir un autre quartz avec un <a href="https://www.codecogs.com/eqnedit.php?latex=g_m" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_m" title="g_m" /></a> plus petit.</p>
<p><strong>2. Choix des condensateurs externes <a href="https://www.codecogs.com/eqnedit.php?latex=C_{L1}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L1}" title="C_{L1}" /></a> et <a href="https://www.codecogs.com/eqnedit.php?latex=C_{L2}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L2}" title="C_{L2}" /></a></strong></p>
<p>On choisit les condensateurs de manière à respecter la relation :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=C_L-C_S&space;=&space;\frac{C_{L1}*C_{L2}}{C_{L1}&plus;C_{L2}]}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_L-C_S&space;=&space;\frac{C_{L1}*C_{L2}}{C_{L1}&plus;C_{L2}]}" title="C_L-C_S = \frac{C_{L1}*C_{L2}}{C_{L1}+C_{L2}]}" /></a></p>
<p>Si on prend <a href="https://www.codecogs.com/eqnedit.php?latex=C_{L1}=C_{L2}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L1}=C_{L2}" title="C_{L1}=C_{L2}" /></a>, on peut choisir <a href="https://www.codecogs.com/eqnedit.php?latex=C_{L1}=C_{L2}=2(C_L-C_S)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L1}=C_{L2}=2(C_L-C_S)" title="C_{L1}=C_{L2}=2(C_L-C_S)" /></a>.</p>
<p><strong>3. Choix d'une résistance externe <a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}" title="R_{Ext}" /></a></strong></p>
<p>Le quartz ne peut dissiper qu'une certaine puissance maximale donnée par le fabriquant : c'est le <em>Drive Level</em> du cristal. Si jamais la puissance dissipée par le quartz dépasse cette valeur, celui-ci peut être endommagé et griller.</p>
<p>Pour éviter cela, on peut choisir d'ajouter une résistance externe qui va dissiper la puissance en trop. pour savoir si on a besoin de cette résistance, il y a 2 manières de procéder :</p>
<ul>
<li>
<p><strong>Méthode 1 :</strong> Mesurer le courant <a href="https://www.codecogs.com/eqnedit.php?latex=I_Q" target="_blank"><img src="https://latex.codecogs.com/gif.latex?I_Q" title="I_Q" /></a> qui traverse le quartz pendant son fonctionnement à l'aide d'une sonde et d'un oscilloscope. On obtient ensuite le courant maximal admissible (en valeur pic-à-pic) par la formule :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=I_{Qmax_{pp}}&space;=&space;2\sqrt{\frac{2D_L}{ESR}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?I_{Qmax_{pp}}&space;=&space;2\sqrt{\frac{2D_L}{ESR}}" title="I_{Qmax_{pp}} = 2\sqrt{\frac{2D_L}{ESR}}" /></a></p>
<p>Si le courant mesuré est plus important, il faut ajouter <a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}" title="R_{Ext}" /></a>. Sinon, on a trouvé un quartz qui convient bravo !</p>
</li>
<li>
<p><strong>Méthode 2 :</strong> Mesurer la tension aux bornes de <a href="https://www.codecogs.com/eqnedit.php?latex=C_{L1}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L1}" title="C_{L1}" /></a> et en déduire le courant qui travers le quartz. Attention pour cette méthode il faut utiliser une sonde qui a une capacité en entrée inférieure à 1 pF. Le <em>Drive Level</em> est alors donné par la formule :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=D_L&space;=&space;\frac{ESR*(\pi*F*C_{tot})^2)*V_{pp}^2}{2}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?D_L&space;=&space;\frac{ESR*(\pi*F*C_{tot})^2)*V_{pp}^2}{2}" title="D_L = \frac{ESR*(\pi*F*C_{tot})^2)*V_{pp}^2}{2}" /></a></p>
<p>Où <a href="https://www.codecogs.com/eqnedit.php?latex=C_{tot}&space;=&space;C_{L1}&plus;\frac{{C_S}}{2}&plus;C_{sonde}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{tot}&space;=&space;C_{L1}&plus;\frac{{C_S}}{2}&plus;C_{sonde}" title="C_{tot} = C_{L1}+\frac{{C_S}}{2}+C_{sonde}" /></a> et <a href="https://www.codecogs.com/eqnedit.php?latex=V_{pp}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?V_{pp}" title="V_{pp}" /></a> est la valeur de tension pic-à-pic mesurée à l'oscilloscope.</p>
<p>Si le <em>Drive Level</em> calculé est supérieure à celui donné par le fabriquant, il faut ajouter <a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}" title="R_{Ext}" /></a>. Sinon, on a trouvé un quartz qui convient bravo !</p>
</li>
</ul>
<p>Calcul de <a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}" title="R_{Ext}" /></a> :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}&space;=&space;\frac{1}{2\pi&space;FC_{L2}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}&space;=&space;\frac{1}{2\pi&space;FC_{L2}}" title="R_{Ext} = \frac{1}{2\pi FC_{L2}}" /></a></p>
<p><strong>ATTENTION :</strong> si on a ajouté <a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}" title="R_{Ext}" /></a> il faut recalculer les valeurs de marges de gain en la prenant en compte :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=g_{mcrit}&space;=&space;4*(ESR&plus;R_{Ext})*(2\pi&space;F)^2*(C_0&plus;C_L)^2" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_{mcrit}&space;=&space;4*(ESR&plus;R_{Ext})*(2\pi&space;F)^2*(C_0&plus;C_L)^2" title="g_{mcrit} = 4*(ESR+R_{Ext})*(2\pi F)^2*(C_0+C_L)^2" /></a></p>
<p>Vérifier que la marge de gain est toujours supérieure à 5. Si ce n'est pas le cas, il faut choisir un autre quartz. Sinon, on a trouvé un quartz qui convient bravo !</p>
<p><strong>Exemple de calcul :</strong> Si on veut associer un quartz à 8 MHZ au microcontrôleur <a href="pre_2021/reference//datasheets/stm32f103/STM32F103x8.pdf">STM32F103C8T6</a>. On trouve un quartz qui a la fréquence de travaille demandée sur un site de confiance : <a href="https://fr.farnell.com/fox-electronics/foxsdlf-080-20/crystal-8-0mhz-20pf-smd/dp/2063972">celui-ci</a> par exemple (<a href="pre_2021/reference/datasheets/quartz/Quartz_8Mhz.pdf">datasheet</a>).</p>
<p>D'après les 2 datasheets, les valeurs dont on a besoin pour les calculs sont les suivantes :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=g_m&space;=&space;25\,mA/V\\&space;\indent&space;F&space;=&space;8\,&space;MHz\\&space;\indent&space;C_0&space;=&space;7\,&space;pF\\&space;\indent&space;ESR&space;=&space;80&space;\,\Omega&space;\\&space;\indent&space;C_L&space;=&space;20&space;pF\\" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_m&space;=&space;25\,mA/V\\&space;\indent&space;F&space;=&space;8\,&space;MHz\\&space;\indent&space;C_0&space;=&space;7\,&space;pF\\&space;\indent&space;ESR&space;=&space;80&space;\,\Omega&space;\\&space;\indent&space;C_L&space;=&space;20&space;pF\\" title="g_m = 25\,mA/V\\ \indent F = 8\, MHz\\ \indent C_0 = 7\, pF\\ \indent ESR = 80 \,\Omega \\ \indent C_L = 20 pF\\" /></a></p>
<p>On peut donc calculer notre marge de gain :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=g_{mcrit}&space;=&space;5.894.10^{-4}&space;\,A/V" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_{mcrit}&space;=&space;5.894.10^{-4}&space;\,A/V" title="g_{mcrit} = 5.894.10^{-4} \,A/V" /></a> donc <a href="https://www.codecogs.com/eqnedit.php?latex=Gain_{margin}&space;=&space;\frac{25}{0.5894}&space;=&space;42.4&space;>>&space;5" target="_blank"><img src="https://latex.codecogs.com/gif.latex?Gain_{margin}&space;=&space;\frac{25}{0.5894}&space;=&space;42.4&space;>>&space;5" title="Gain_{margin} = \frac{25}{0.5894} = 42.4 >> 5" /></a></p>
<p>Cette valeur de marge de gain étant largement suffisante, on peut calculer les valeurs de nos condensateurs :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=C_{L1}=C_{L2}=2(20-5)=30\,&space;pF" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L1}=C_{L2}=2(20-5)=30\,&space;pF" title="C_{L1}=C_{L2}=2(20-5)=30\, pF" /></a></p>
<p>Si jamais on devait ajouter une résistance externe, il faudrait que sa valeur soit de :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}&space;=&space;\frac{1}{2\pi&space;*8.10^6*30.10^{-12}}=663&space;\,\Omega" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}&space;=&space;\frac{1}{2\pi&space;*8.10^6*30.10^{-12}}=663&space;\,\Omega" title="R_{Ext} = \frac{1}{2\pi *8.10^6*30.10^{-12}}=663 \,\Omega" /></a></p>
<p>On aurait alors une marge de gain de 5 : il faudrait donc choisir un autre quartz ayant un ESR plus faible ou bien un <a href="https://www.codecogs.com/eqnedit.php?latex=C_L" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_L" title="C_L" /></a> plus petit.</p>
<p>Pour plus de précision, voir le <a href="pre_2021/reference//datasheets/quartz/Oscillator_choice_guide">guide du choix d'un quartz fourni par ST</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-déplacement"><a class="header" href="#carte-déplacement">Carte déplacement</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-servomoteur"><a class="header" href="#carte-servomoteur">Carte servomoteur</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-évitement"><a class="header" href="#carte-évitement">Carte évitement</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-capteur-couleur"><a class="header" href="#carte-capteur-couleur">Carte capteur couleur</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-pompe-à-vide"><a class="header" href="#carte-pompe-à-vide">Carte pompe à vide</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communication-test"><a class="header" href="#communication-test">Communication (test)</a></h1>
<p>Dans cette partie, on va parler un peu de la "<strong>communication</strong>" du Club (on s'adresse aux membres intéressés par cet aspect mais aussi et surtout au <em>président</em> et à son <em>secrétaire</em> !)</p>
<h3 id="communication-interne"><a class="header" href="#communication-interne">Communication interne</a></h3>
<p>De fait, les gens au Club ont besoin de communiquer <em>entre eux</em> (pratique pour faire un projet à plusieurs) : on utilisera <a href="https://gitter.im/club-robot-insat/">Gitter</a> pour ça ! Il existe aussi un groupe <a href="https://www.facebook.com/groups/809109805874317/?ref=bookmarks">Facebook</a> qui date, avec pas mal d'anciens dessus : n'hésitez pas à demander à vous y ajouter, et si vous avez des infos à partager avec des très vieux, allez-y !
On utilise enfin le <a href="https://drive.google.com/drive/">drive</a> associé à l'adresse gmail du Club, pour stocker les documents relatifs au secrétariat, à la trésorie, des photos, etc.</p>
<h3 id="communication-externe"><a class="header" href="#communication-externe">Communication externe</a></h3>
<p>Ensuite, la communication du Club avec <em>l'extérieur</em> est également primordiale. On entend par là :</p>
<ul>
<li>communication (publications) sur notre <strong>page <a href="https://www.facebook.com/ClubRobotINSAT/">Facebook</a></strong></li>
<li>réponse aux messages &amp; questions reçus <em>via</em> <strong>messenger</strong></li>
<li>réponse aux messages &amp; questions reçus par <strong>e-mails</strong></li>
<li>communication (e-mails) avec nos <strong>sponsors</strong> : les informer régulièrement des avancées du projet, etc.</li>
<li>communication (e-mails) avec l'<strong>INSA</strong> (GEI, service communication, GM, etc.) : idem</li>
<li>communication (publications) sur notre <strong>site <a href="https://etud.insa-toulouse.fr/~club_robot/">web</a></strong> (car oui il existe un site web ! (qui date lui aussi, qu'on essaie de garder à jours mais que de jeunes gens motivés pourraient très bien refaire un jour !))</li>
</ul>
<p><em>Tout au long de l'année</em>, pas mal de choses sont à promouvoir autour du Club (événements, vie quotidienne, etc) et on en parle <a href="pre_2021/com//com/ext">ici</a>, avec une petite check-liste pour ne jamais être perdu !</p>
<h3 id="pleins-dimages-"><a class="header" href="#pleins-dimages-">Pleins d'images !</a></h3>
<p>Pour tous ces aspects de communication, de nombreuses <a href="pre_2021/com/">ressources</a> (images, documents, etc) existent, et on vous les présente <a href="pre_2021/com/">ici</a> ! Vous y trouverez des <strong>logos</strong>, de jolies <strong>infographies</strong>, plein de choses (voir bientôt des tutos peut-être^^) qui vous permettront de présenter le Club sous son meilleur jour ! (même s'il y fait beau tous les jours :) )</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interne-entre-nous"><a class="header" href="#interne-entre-nous">Interne (entre nous)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitter"><a class="header" href="#gitter">Gitter</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messengerfacebook"><a class="header" href="#messengerfacebook">Messenger/Facebook</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="externe"><a class="header" href="#externe">Externe</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="site"><a class="header" href="#site">Site</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="page-facebook"><a class="header" href="#page-facebook">Page Facebook</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ressources--images"><a class="header" href="#ressources--images">Ressources &amp; images</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
