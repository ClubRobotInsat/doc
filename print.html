<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Documentation Club Robot Insa Toulouse</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="test.html"><strong aria-hidden="true">2.</strong> Test</a></li><li class="chapter-item expanded "><a href="outils_communs/index.html"><strong aria-hidden="true">3.</strong> Outils Communs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="outils_communs/dual_boot.html"><strong aria-hidden="true">3.1.</strong> Dual Boot</a></li><li class="chapter-item expanded "><a href="outils_communs/git.html"><strong aria-hidden="true">3.2.</strong> Git</a></li><li class="chapter-item expanded "><a href="outils_communs/ide.html"><strong aria-hidden="true">3.3.</strong> CLion</a></li></ol></li><li class="chapter-item expanded "><a href="info/index.html"><strong aria-hidden="true">4.</strong> Informatique</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="info/mise_en_place/index.html"><strong aria-hidden="true">4.1.</strong> Mise en place</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="info/mise_en_place/ide.html"><strong aria-hidden="true">4.1.1.</strong> IDE</a></li><li class="chapter-item expanded "><a href="info/mise_en_place/repertoire_de_travail.html"><strong aria-hidden="true">4.1.2.</strong> Répertoire de travail</a></li><li class="chapter-item expanded "><a href="info/mise_en_place/compilation.html"><strong aria-hidden="true">4.1.3.</strong> Compilation</a></li></ol></li><li class="chapter-item expanded "><a href="info/outils/index.html"><strong aria-hidden="true">4.2.</strong> Prise en main des outils</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="info/outils/cmake.html"><strong aria-hidden="true">4.2.1.</strong> CMake</a></li><li class="chapter-item expanded "><a href="info/outils/petrilab.html"><strong aria-hidden="true">4.2.2.</strong> PetriLab</a></li></ol></li><li class="chapter-item expanded "><a href="info/explications/index.html"><strong aria-hidden="true">4.3.</strong> Explications du code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="info/explications/racine.html"><strong aria-hidden="true">4.3.1.</strong> Architecture de la racine</a></li><li class="chapter-item expanded "><a href="info/explications/architecture.html"><strong aria-hidden="true">4.3.2.</strong> Vue globale du projet</a></li><li class="chapter-item expanded "><a href="info/explications/communication.html"><strong aria-hidden="true">4.3.3.</strong> Communication avec le hardware</a></li><li class="chapter-item expanded "><a href="info/explications/lidar.html"><strong aria-hidden="true">4.3.4.</strong> Détection de l'adversaire : LIDAR</a></li><li class="chapter-item expanded "><a href="info/explications/robot.html"><strong aria-hidden="true">4.3.5.</strong> Création d'un robot</a></li><li class="chapter-item expanded "><a href="info/explications/simu.html"><strong aria-hidden="true">4.3.6.</strong> Architecture du simulateur</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="elec_soft/index.html"><strong aria-hidden="true">5.</strong> Electronique Logicielle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="elec_soft/organisation/index.html"><strong aria-hidden="true">5.1.</strong> Organisation du code</a></li><li class="chapter-item expanded "><a href="elec_soft/mise_en_place/index.html"><strong aria-hidden="true">5.2.</strong> Mise en place</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="elec_soft/mise_en_place/compile.html"><strong aria-hidden="true">5.2.1.</strong> Compilation</a></li><li class="chapter-item expanded "><a href="elec_soft/mise_en_place/repo.html"><strong aria-hidden="true">5.2.2.</strong> Répertoire de travail</a></li><li class="chapter-item expanded "><a href="elec_soft/mise_en_place/ide.html"><strong aria-hidden="true">5.2.3.</strong> IDE</a></li><li class="chapter-item expanded "><a href="elec_soft/mise_en_place/flash.html"><strong aria-hidden="true">5.2.4.</strong> Flashage</a></li></ol></li><li class="chapter-item expanded "><a href="elec_soft/apprendre_rust.html"><strong aria-hidden="true">5.3.</strong> Apprendre Rust</a></li><li class="chapter-item expanded "><a href="elec_soft/modules/index.html"><strong aria-hidden="true">5.4.</strong> Communication des modules avec l'info</a></li></ol></li><li class="chapter-item expanded "><a href="elec_mat/index.html"><strong aria-hidden="true">6.</strong> Electronique matérielle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="elec_mat/mise_en_place/tools.html"><strong aria-hidden="true">6.1.</strong> Mise en place</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="elec_mat/mise_en_place/folders.html"><strong aria-hidden="true">6.1.1.</strong> Organisation</a></li><li class="chapter-item expanded "><a href="elec_mat/mise_en_place/install_git.html"><strong aria-hidden="true">6.1.2.</strong> Installation</a></li></ol></li><li class="chapter-item expanded "><a href="elec_mat/kicad.html"><strong aria-hidden="true">6.2.</strong> Préparer ta carte</a></li><li class="chapter-item expanded "><a href="elec_mat/tips&tricks.html"><strong aria-hidden="true">6.3.</strong> Conseils et outils usuels</a></li><li class="chapter-item expanded "><a href="elec_mat/production.html"><strong aria-hidden="true">6.4.</strong> Tirer une carte</a></li><li class="chapter-item expanded "><a href="elec_mat/references/index.html"><strong aria-hidden="true">6.5.</strong> Références</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="elec_mat/references/ethernet.html"><strong aria-hidden="true">6.5.1.</strong> Utilisation du module ethernet</a></li><li class="chapter-item expanded "><a href="elec_mat/references/ref_cartes.html"><strong aria-hidden="true">6.5.2.</strong> Annexe : liste des cartes du Club</a></li><li class="chapter-item expanded "><a href="elec_mat/references/ref_composants.html"><strong aria-hidden="true">6.5.3.</strong> Annexe : liste des composants usuels</a></li></ol></li><li class="chapter-item expanded "><a href="elec_mat/cablage.html"><strong aria-hidden="true">6.6.</strong> Cablage Robot</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">7.</strong> Documents de référence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/commun.html"><strong aria-hidden="true">7.1.</strong> Communs</a></li><li class="chapter-item expanded "><a href="reference/deplacement.html"><strong aria-hidden="true">7.2.</strong> Carte déplacement</a></li><li class="chapter-item expanded "><a href="reference/servomoteur.html"><strong aria-hidden="true">7.3.</strong> Carte servomoteur</a></li><li class="chapter-item expanded "><a href="reference/evitement.html"><strong aria-hidden="true">7.4.</strong> Carte évitement</a></li><li class="chapter-item expanded "><a href="reference/couleur.html"><strong aria-hidden="true">7.5.</strong> Carte capteur couleur</a></li><li class="chapter-item expanded "><a href="reference/pompe.html"><strong aria-hidden="true">7.6.</strong> Carte pompe à vide</a></li></ol></li><li class="chapter-item expanded "><a href="com/index.html"><strong aria-hidden="true">8.</strong> Communication (test)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="com/int/index.html"><strong aria-hidden="true">8.1.</strong> Interne (entre nous)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="com/int/gitter.html"><strong aria-hidden="true">8.1.1.</strong> Gitter</a></li><li class="chapter-item expanded "><a href="com/int/fb.html"><strong aria-hidden="true">8.1.2.</strong> Messenger/Facebook</a></li></ol></li><li class="chapter-item expanded "><a href="com/ext/index.html"><strong aria-hidden="true">8.2.</strong> Externe</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="com/ext/site.html"><strong aria-hidden="true">8.2.1.</strong> Site</a></li><li class="chapter-item expanded "><a href="com/ext/fb.html"><strong aria-hidden="true">8.2.2.</strong> Page Facebook</a></li></ol></li><li class="chapter-item expanded "><a href="com/res/md.html"><strong aria-hidden="true">8.3.</strong> Ressources &amp; images</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Documentation Club Robot Insa Toulouse</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="images/com/logo18.png" alt="" title="Logo du Club Robot" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Ce site internet contient la documentation du Club Robot de l'INSA Toulouse pour les parties électronique et informatique du robot.</p>
<p>Ce livre est rédigé avec <a href="https://github.com/rust-lang-nursery/mdBook">md-book</a>.</p>
<p>Le but de ce livre est de te guider pour l'installation des différents outils permettant de programmer au Club Robot.</p>
<p>Ce livre ne documentera pas le code du club, mais peut documenter les différents fichiers d'un projet. Il est là pour servir de référence en cas de problème et de questions vis à vis d'un fichier.</p>
<p>Sa lecture est préliminaire à la formation organisée en début d'année, et son but est de nous faire gagner du temps en vous faisant installer à la maison les outils de dévellopement.</p>
<p>Enfin, son écriture a commencé après Chocobot à la coupe de france de 2018 (Robot Cities).</p>
<p>Pour la suite du &quot;livre&quot;, si on s'est occupé de t'installer linux sur ton ordinateur ou si tu as une version de Ubuntu récente (&gt;16.04) tu peux te considérer comme un utilisateur &quot;standard&quot; et tu n'as pas besoin de suivre les sections pour les <em>power user</em>.</p>
<p>Si jamais tu trouves des fautes d'orthographes, des erreurs, des remarques ou toutes autres formes de contribution à faire n'hésite <strong>surtout pas</strong>. Les sources de ce livre sont sur <a href="https://github.com/ClubRobotInsat/doc-elec">ce repertoire github</a>, et il n'y a pas besoin de <code>git</code> pour y apporter des modifications simples : l'interface en ligne de github te permet de modifier les fichiers textes et de créer ton premier <em>commit</em> en quelques secondes! Il faut juste penser à demander aux membres du club d'ajouter ton compte dans la liste des utilisateurs autorisés.</p>
<p>Enfin, la phrase la plus importante en informatique à garder en tête durant toute ta formation :</p>
<blockquote>
<p>Le mieux est l'ennemi du bien, surtout au club robot.</p>
</blockquote>
<p><em>Un illustre anonyme</em></p>
<p><img src="images/com/tester_doute.jpeg" alt="Tester c'est douter" title="Tester c'est douter" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="outils-communs"><a class="header" href="#outils-communs">Outils Communs</a></h1>
<p>Cette section répertorie les principaux outils utilisés au Club Robot.</p>
<p>Ce tableau t'aidera à savoir quelles pages t'intéressent en fonction de ton pôle de prédilection :</p>
<table><thead><tr><th align="center"></th><th align="center"><a href="outils_communs/outils_communs/git.html">git</a></th><th align="center"><a href="outils_communs/outils_communs/ide.html">CLion</a></th><th align="center"><a href="outils_communs/info/outils/cmake.html">CMake</a></th><th align="center"><a href="outils_communs/elec_mat/tools.html">Kicad</a></th></tr></thead><tbody>
<tr><td align="center">Informatique</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td><td align="center"></td></tr>
<tr><td align="center">Electronique software</td><td align="center">✔️</td><td align="center">✔️</td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center">Electronique hardware</td><td align="center">✔️</td><td align="center"></td><td align="center"></td><td align="center">✔️</td></tr>
<tr><td align="center">Mécanique</td><td align="center">✔️</td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dual-boot-avec-linux"><a class="header" href="#dual-boot-avec-linux">Dual Boot avec Linux</a></h1>
<p>Tu as probablement un ordinateur sous Windows. Cependant, développer sous ce système d'exploitation est compliqué donc on utilise des systèmes Linux au club.</p>
<p>Tu as différentes manières d'utiliser Linux :</p>
<ul>
<li>Utiliser <a href="https://www.virtualbox.org/">VirtualBox</a>, une machine virtuelle pour exécuter Linux à l'intérieur de Windows (cependant, ton ordinateur va devoir exécuter deux systèmes d'exploitation en même temps donc il y aura des pertes de performance)</li>
<li>Installer un dual boot, c'est à dire qu'au démarrage de ton ordinateur, soit Windows soit Linux va être lancé, donc les performances de chaque OS vont être maximales mais ton disque dur aura une partie attribuée à Windows et une autre à Linux.</li>
</ul>
<p>Ce tuto est là pour t'expliquer comment installer un environnement sympa sous Linux.</p>
<h2 id="préliminaires-sous-windows"><a class="header" href="#préliminaires-sous-windows">Préliminaires sous Windows</a></h2>
<p>Avant tout, il faut faire quelques réglages sous Windows pour permettre l'installation d'un nouveau système d'expoitation (Windows n'aime pas trop partager un ordinateur). Pense aussi à sauvegarder toutes les données importantes ailleurs que sur ton PC. Je n'ai jamais eu de problème avec une installation de Linux, mais comme d'habitude, quand on joue avec les partitions de son disque dur, on prend des précautions (panne de courant/batterie pendant une étape critique par exemple).</p>
<ul>
<li><strong>Désactiver la mise en veille prolongée :</strong> par défaut, Windows ne s'éteint pas quand on le lui dit mais rentre en veille prolongée. Ceci est totalement inutile depuis qu'il y a des disques SSD, et ça empèche de démarrer sous un autre OS
<ul>
<li>ouvrir un terminal avec les droits administrateur (clic droit sur le logo windows, shell)</li>
<li>entrer la commande <code>powercfg -h off</code></li>
</ul>
</li>
<li><strong>Partitionner le disque dur :</strong> afin d'éviter tout problème de partionnement à cause de la fragmentation Windows, il vaut mieux utiliser directement les outils de Windows :
<ul>
<li>appuyer sur <code>Windows + R</code></li>
<li>saisir <code>diskmgmt.msc</code></li>
<li>clic droit sur le volume à partitionner (<em>Disque 0</em>) et sélectionner <code>Réduire le volume</code></li>
<li>choisir la taille de la partition désirée (Ubuntu demande 15Go minimum et recommande 25Go ; si tu as de la place tu peux faire une nouvelle partition à <code>40Go</code> pour être large)</li>
</ul>
</li>
</ul>
<p>Ton disque dur a maintenant un espace inutilisé, il est temps de l'utiliser !</p>
<h2 id="choix-du-système-linux"><a class="header" href="#choix-du-système-linux">Choix du système Linux</a></h2>
<p>Il te faut à présent choisir quel nouveau système d'exploitation utiliser. <strong>Linux</strong> est un <a href="https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg">univers très vaste</a>, que l'on peut sommairement classer :</p>
<ul>
<li>les systèmes basés sur les fichiers <code>.rpm</code>
<ul>
<li>CentOS</li>
<li>Fedora</li>
<li>openSUSE</li>
</ul>
</li>
<li>les systèmes dérivant de <code>Debian</code>
<ul>
<li><strong>Ubuntu</strong></li>
<li>Kali Linux</li>
</ul>
</li>
<li>les systèmes basés sur le <em>packet manager</em> <code>pacman</code>
<ul>
<li>Arch Linux</li>
<li><strong>Manjaro</strong></li>
</ul>
</li>
</ul>
<p>Tu peux demander des conseils aux membres si tu ne sais pas quel OS prendre, ils pourront même t'en faire essayer plusieurs !</p>
<h3 id="ubuntu-1804"><a class="header" href="#ubuntu-1804">Ubuntu 18.04</a></h3>
<p>Si tu n'as aucune idée de quel système choisir, je te conseille <a href="https://www.ubuntu.com/download/desktop">Ubuntu 18</a>, un système communautaire LTS (<em>Long Term Supported</em>) qui est très simple à prendre en main et pour laquelle les nombreux forums répondent à toutes tes questions.</p>
<p>Pour l'installer, il te suffit de <a href="https://www.ubuntu.com/download/desktop/thank-you?country=US&amp;version=18.04.1&amp;architecture=amd64">télécharger l'ISO</a> et la mettre sur une clef USB.</p>
<p><strong>! Attention !</strong>
Sauvegarde toutes les données sur ta clé USB avant de continuer ! Ta clef sera effacée par la suite (mais tu pourras la réinitialiser après avoir installé Linux, puis remettre tes données dessus ensuite).</p>
<p>Par &quot;mettre sur une clef USB&quot;, on entend &quot;flasher une image disque&quot;, mais c'est un terme barbare. Ici il ne te sera expliqué que comment faire.
Le moyen le plus simple est d'utiliser <a href="https://etcher.io/">Etcher</a>. C'est un logiciel open source et compatible sur Windows, Mac et Linux. Sa grande qualité est d'être <strong>tres</strong> simple à utiliser.</p>
<p>Une fois installé et lancé, il n'y a littéralement que quatre clics à faire : </p>
<ul>
<li>&quot;Select Image&quot; t'invite a choisir l'ISO que tu as déjà téléchargé.</li>
<li>&quot;Select Drive&quot; te demande de choisir le disque (clef USB dans notre cas) à flasher. C'est a dire qu'il sera <strong>formatté</strong> ( ! toutes les données dessus seront perdues !) puis que l'ISO y sera correctement installé. Cette étape requiert de savoir ce que l'on fait : il faut être <strong>absolument</strong> certain que le nom et la capacité du disque choisi correspondent à ta clef USB, et <strong>surtout pas à ton disque dur</strong>. Normalement Etcher est bien fait, et refuse de continuer si choisit un disque à ne pas toucher, mais il vaut mieux être trop prudent.</li>
<li>&quot;Flash!&quot; lance l'opération et raconte ce qu'il fait à ta clef au fur et à mesure.</li>
</ul>
<p>Si tout c'est bien passé, ta &quot;Live-USB&quot; est prête à l'emploi. La suite dépend de ton ordinateur et de la distribution que tu veux installer. </p>
<h3 id="manjaro-linux"><a class="header" href="#manjaro-linux">Manjaro Linux</a></h3>
<p>Pour les utilisateurs un peu plus confirmés, je peux aussi conseiller <a href="https://manjaro.org/get-manjaro/">Manjaro</a>, qui se base sur Arch Linux. La configuration de ce système est totalement personnalisable et il existe de nombreuses variantes graphiques, en fonction de si tu préfères des systèmes avec un bureau ou la gestion de fenêtres comme <a href="https://forum.manjaro.org/t/manjaro-i3-17-1-11-17-1-12/51238">Manjaro i3</a>.</p>
<p>Là encore, tu peux télécharger l'ISO qui te convient puis le mettre sur une clef USB.</p>
<h2 id="installation-sur-ton-ordinateur-dun-dual-boot"><a class="header" href="#installation-sur-ton-ordinateur-dun-dual-boot">Installation sur ton ordinateur d'un dual boot</a></h2>
<p>À présent que tu es muni.e d'une clef bootable, tu peux la brancher sur ton ordinateur, appuyer sur la touche pour aller dans le BIOS (ça dépend du constructeur mais tu as de bonnes chances d'y parvenir en spammant <code>Échap</code>, <code>F2</code>, <code>F9</code> ou <code>F11</code>) puis modifier quelques paramètres :</p>
<ul>
<li>Désactive le <code>UEFI Secure Boot</code></li>
<li>Désactive le <code>Fast Start-Up</code></li>
<li>Change l'ordre de priorité pour booter afin de lancer ta clef USB en première</li>
</ul>
<p>Si tu as le moindre problème je te conseille d'aller voir un membre du club, mais si ton écran affiche des choses en relation avec Linux et non pas l'écran de démarrage de Windows c'est gagné !</p>
<p>Tu peux choisir de tester l'OS ou alors de l'installer directement. L'interface devrait être assez explicite ; il va juste te falloir réaliser une dernière manip sur la page des disques.</p>
<p>Pour être sûr.e que tout se passe bien, choisis <code>Something else</code> lorsqu'on te demande où installer le système Linux. Ensuite, dans l'espace libre, tu peux attribuer 2Go à une mémoire de type <code>swap</code> (ce qui permets de soulager la RAM si tu lances des applications qui consomment trop). Tu peux attribuer le reste de l'espace libre pour Linux avec <code>type: ext4</code> et <code>mount point: /</code> en formatant l'espace pour éviter tout problème ultérieur.</p>
<p>Finalise l'installation et redémarre ; si tu arrives sur une interface pour choisir entre Linux et Windows (c'est le <code>Grub 2</code>) tout marche comme il faut !!</p>
<h2 id="setup-de-linux"><a class="header" href="#setup-de-linux">Setup de Linux</a></h2>
<p>La première chose à faire est de mettre à jour ton système.</p>
<ul>
<li><strong>ArchLinux :</strong> <code>sudo pacman -Suy</code></li>
<li><strong>Debian :</strong> <code>sudo apt update &amp;&amp; sudo apt upgrade</code></li>
</ul>
<h3 id="installation-basique"><a class="header" href="#installation-basique">Installation basique</a></h3>
<p>Installons les paquets de base nécéssaire pour faire fonctionner les différents outils du club. Ouvre un terminal, et entres :</p>
<pre><code class="language-bash">sudo apt install git curl wget ntfs-3g python3 gcc gdb vim nano cmake
</code></pre>
<p>Les paquets installés sont les suivants :</p>
<ul>
<li>git	--&gt; un gestinnaire de version et de code</li>
<li>curl	--&gt; pour télécharger des objets en ligne de commandes</li>
<li>wget	--&gt; en gros, idem que curl</li>
<li>python3	--&gt; pour executer les scripts python3</li>
<li>gcc	--&gt; pour compiler du C/C++, toujours utile</li>
<li>gdb	--&gt; pour debugger du C/C++, toujours très utile</li>
<li>vim	--&gt; un éditeur de texte en ligne de commande, un peu compliqué mais complet (pour quitter: ESC &gt; :q! &gt; ENTER)</li>
<li>nano	--&gt; un éditeur de texte plus simple</li>
</ul>
<h2 id="installation-avancée"><a class="header" href="#installation-avancée">Installation avancée</a></h2>
<p><em>Note : Cette partie est falcultative et non recommandée si c'est votre première installation de linux.</em></p>
<p>Ensuite, tu peux installer différents paquets sympatiques :</p>
<ul>
<li><strong>Archlinux</strong></li>
</ul>
<pre><code class="language-bash">sudo pacman -S ntfs-3g wget curl zsh thunderbird firefox rofi numlockx python-pip

sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;

cd /tmp
git clone https://github.com/meskarune/i3lock-fancy.git
cd i3lock-fancy
sudo make install

sudo wget https://cht.sh/:cht.sh -O /usr/local/bin/cht.sh
sudo chmod o+x /usr/local/bin/cht.sh

sudo pip install cheat
</code></pre>
<ul>
<li><strong>Ubuntu</strong></li>
</ul>
<pre><code class="language-bash">sudo apt-get install ntfs-3g wget curl zsh thunderbird firefox python-pip

sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;

sudo wget https://cht.sh/:cht.sh -O /usr/local/bin/cht.sh
sudo chmod o+x /usr/local/bin/cht.sh
</code></pre>
<hr />
<p>Si tu as un disque / partition en commun entre Windows et Linux (pour partager tes documents et musiques par exemple), tu as la possibilité de <em>monter</em> ce disque à chaque lancement de Linux pour y avoir accès facilement :</p>
<ul>
<li><code>sudo blkid</code> te donne des informations sur tous les disques</li>
<li>copie le <code>UUID</code> de la partition en commun</li>
<li>rajoute la ligne <code>UUID=&lt;ton_UUID_copié&gt; /media/commun ntfs-3g auto,user,exec,rw 0 0</code> à la fin du fichier <code>/etc/fstab</code> (il faut ouvrir un éditeur de texte en <code>sudo</code>)</li>
<li>au prochain redémarrage, ton disque commun sera accessible dans <code>/media/commun/</code></li>
<li>tu pourras faire des liens symboliques pour accéder à tes dossiers facilement, par exemple pour tes documents :</li>
</ul>
<pre><code class="language-bash">cd ~
rm -rf Documents
ln -s /media/commun/Documents .
</code></pre>
<hr />
<p>Enfin, si tu veux avoir des exemples de fichiers de configuration pour <strong>vim</strong>, <strong>git</strong>, <strong>zsh</strong> ou encore <strong>i3</strong> sous Manjaro-i3, tu peux aller voir <a href="https://github.com/terae/dotfiles">ce dépôt GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<p><em>Cette page s'adresse à tous les membres du Club.</em></p>
<p>On utilise un <a href="https://fr.wikipedia.org/wiki/Logiciel_de_gestion_de_versions">gestionnaire de versions</a> pour manager l'ensemble du code : <a href="https://git-scm.com/">git</a>.</p>
<p>Ce choix a de très nombreux avantages :</p>
<ul>
<li>L'évolution de tout le code est sauvegardée donc on peut rappeler une version antérieure d'un fichier à tout moment</li>
<li>Si on perd des fichiers ou que l'on se trompe, on peut facilement revenir à un état stable</li>
<li><code>git</code> permets de collaborer sur un même code, c'est à dire que plusieurs développeurs peuvent participer au code et le logiciel s'occupe de rassembler l'ensemble des modifications</li>
<li>On peut profiter de tous ces avantages avec très peu de travail supplémentaire</li>
</ul>
<h2 id="installation-de-git"><a class="header" href="#installation-de-git">Installation de <code>git</code></a></h2>
<p>Afin de bénéficier de tous les avantages de <code>git</code>, il n'y a rien de plus simple : il suffit d'exécuter la commande suivante.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install git
</code></pre>
<p><em><strong>Astuce :</strong></em> pour vérifier que l'installation d'une application a bien marché, tu peux appeler la commande <code>which</code> qui te retourne le chemin vers l'exécutable, ou encore l'exécuter avec le flag <code>--version</code> :</p>
<pre><code class="language-bash">$ which git
/usr/bin/git

$ git version
git version 2.11.0
</code></pre>
<h2 id="apprendre-à-utiliser-cet-outil"><a class="header" href="#apprendre-à-utiliser-cet-outil">Apprendre à utiliser cet outil</a></h2>
<h3 id="apprendre-en-ligne"><a class="header" href="#apprendre-en-ligne">Apprendre en ligne</a></h3>
<p><code>git</code> est un logiciel extrêmement pratique une fois qu'on l'a pris en main, alors voici ton premier travail à la maison : <a href="https://learngitbranching.js.org/">apprendre visuellement git</a>. Le tutoriel est multilangue, et si tu préfères suivre un tuto en français en voici un d'<a href="https://openclassrooms.com/courses/gerez-vos-codes-source-avec-git">OpenClassrooms</a>.</p>
<p>Vu qu'il sait faire de très nombreuses choses, ce n'est bien sûr pas la peine d'apprendre toutes ses commandes par coeur. Voici des <em>Cheat Sheets</em> qui vont te faire gagner du temps :</p>
<ul>
<li><a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf">Cheat sheet de GitHub (en)</a></li>
<li><a href="https://services.github.com/on-demand/downloads/fr/github-git-cheat-sheet.pdf">Chear sheet de GitHub (fr)</a></li>
<li><a href="https://www.git-tower.com/blog/git-cheat-sheet/">Cheat sheet de Tower</a></li>
</ul>
<h3 id="ba-ba-des-commandes"><a class="header" href="#ba-ba-des-commandes">B.A.-BA des commandes</a></h3>
<p>Si tu as besoin d'aide pour utiliser <code>git</code>, les forums de <a href="http://stackoverflow.com/">StackOverflow</a> te permettent de répondre à tes questions les plus complexes.</p>
<p>Ensuite, voici une <a href="https://git-scm.com/docs">documentation d'API</a> des différentes fonctions.</p>
<p>En général cependant, tu vas devoir utiliser le même socle de commandes et le but de ce paragraphe est de te lister le <em><strong>template</strong></em> de commandes à utiliser ; je t'invite néanmoins à aller lire la documentation de chacune de ces commandes pour voir à quel point elles peuvent être puissantes.</p>
<ol>
<li>
<p>Avant de commencer à travailler, il faut récupérer le travail réaliser par les autres développeurs. Si tu as déjà des <code>commit</code>s en local, tu peux spécifier le flag <code>--rebase</code> pour avoir une architecture linéaire ; sinon <code>git</code> va <code>merge</code>r la branche locale et celle distante même pour des intégrations triviales.</p>
<ul>
<li><code>git pull [--rebase]</code></li>
</ul>
</li>
<li>
<p>À présent, à toi de faire des modifications pour contribuer au dépôt. Une fois que tu as fini et que tu veux créer un paquet qui contient ta nouveauté, il faut demander à <code>git</code> de rajouter toutes tes modifications intéressantes. Tu peux également connaître les modfications que tu as faites soit fichier par fichier, soit ligne par ligne. Bien sûr, tu peux restreindre la recherche à un document ou à des fichiers en particulier en les rajoutant à la fin.</p>
<ul>
<li><code>git status</code> te liste tous les fichiers qui ont été modifiés / supprimés / créés</li>
<li><code>git diff</code> te montre toutes les additions et délétions dans le code pour l'ensemble de ces fichiers</li>
</ul>
</li>
<li>
<p>Il est temps de choisir les modifications que tu veux sauvegarder dans l'arborescence de <code>git</code>. Il y a plusieurs moyens d'y arriver en utilisant <code>git add</code> et <code>git reset</code> :</p>
<ul>
<li><code>git add *</code> te permets d'ajouter TOUTES les modifications, il ne faut donc pas l'utiliser si tu travailles sur plusieurs projets en même temps</li>
<li><code>git add &lt;file 1&gt; [file 2] [...]</code> ajoute les modifications de chaque fichier / dossier dans leur ensemble. Si tu crées un nouveau fichier, il faut utiliser cette méthode pour l'ajouter et non pas la suivante.</li>
<li><code>git add -p</code> permets de mixer <code>add</code> et <code>diff</code> ; il s'agit d'une méthode particulièrement efficace si tu as besoin de sauvegarder seulement quelques lignes et non pas l'ensemble des modifications sur un fichier. Une interface s'ouvre et tu peux choisir d'accepter avec <code>y</code> ou de refuser les modifications avec <code>n</code> ; d'autres commandes sont possibles notamment <code>q</code> pour quitter.</li>
<li><code>git reset</code> te permets d'annuler l'insertion des modifications dans la sauvegarde de <code>git</code> (mais il ne reset pas les modifications du fichier, rassure-toi). Tu peux également lui donner l'argument <code>-p</code> pour accéder à l'interface intéractive.</li>
</ul>
</li>
<li>
<p>Tu peux vérifier que tu as ajouter les bonnes modifications en appelant de nouveau</p>
<ul>
<li><code>git status</code> pour voir les fichiers</li>
<li><code>git diff --staged</code> pour voir les modifications dans le code</li>
</ul>
</li>
<li>
<p>Il est enfin temps de créer le 'paquet' de modifications, appelé <code>commit</code>. Afin de pouvoir s'y retrouver plus facilement, les <code>commit</code>s ont chacun un numéro unique (appelé hash ; il a cette tête : <code>44bf09d0a2c36585aed1c34ba2e5d958a9379718</code> et est généré automatiquement) et également un message que tu dois choisir pour expliquer ce à quoi il sert. C'est très intéressant de créer un <code>commit</code> par fonctionnalité, et donc qui modifie éventuellement plusieurs fichiers, afin de pouvoir relire l'historique ensuite. Pense donc à en réaliser plusieurs au cours de ton travail, tu pourras facilement revenir à des versions précédentes ce qui est très bénéfique !</p>
<ul>
<li><code>git commit -m &lt;message&gt;</code></li>
<li><code>git commit --amend</code> te permets de juste rajouter des modifications au dernier commit pour ne faire qu'un seul paquet avec les anciennes et nouvelles modifs.</li>
</ul>
</li>
<li>
<p>Maintenant que tu as créé plusieurs <code>commit</code>s, tu peux vérifier que tout s'est bien passé en faisant appel à l'historique. Tu pourras y observer le numéro de chaque commit, leur auteur, leur date de création ainsi que leur message d'accompagnement.</p>
<ul>
<li><code>git log</code></li>
</ul>
</li>
<li>
<p>Enfin, les modifications que tu viens de faire ont pour but d'être partagées aux autres développeurs et donc envoyés sur le dépôt distant de <a href="https://github.com/orgs/ClubRobotInsat/">github.com</a>. Normalement, si tu as bien suivi les étapes de clonage présentées un peu plus bas, tout devrait être déjà configuré pour n'avoir qu'à taper ceci :</p>
<ul>
<li><code>git push -u origin &lt;branch&gt;</code> la première fois pour demander à envoyer les <code>commit</code>s sur le flux <code>origin</code>, c'est à dire github, correspondant à la branche actuelle (par exemple <code>master</code>)</li>
<li><code>git push</code> les fois suivantes ; tout va marcher ensuite à condition d'avoir une connexion internet :wink:</li>
</ul>
</li>
</ol>
<p>Je n'ai pas parlé d'un certain nombre de commandes car tu ne devrais pas les utiliser quotidiennement. Voici une liste de fonctione néanmoins intéressantes dont tu peux aller voir la documentation :</p>
<ul>
<li><code>git branch</code> - notion que je n'ai que très peu abordée, <code>git</code> travaille avec des branches pour faciliter le travail sur plusieurs projets en parallèle</li>
<li><code>git checkout</code> - permets de se ballader d'une branche à une autre branche ou à un commit en particulier</li>
<li><code>git reset</code> - idél pour enlever les modifs d'un <code>git add</code> et pour supprimer des <code>commit</code>s foireux présents localement</li>
<li><code>git revert</code> - applique les modifications complémentaires à un commit, idéal pour annuler un commit foireux déjà envoyé sur le serveur</li>
<li><code>git merge</code> - permets à deux branches de fusionner ; fonctionnalité sympa pour travailler indépendamment sur un projet puis l'intégrer dans la branche principale une fois qu'il est fonctionnel</li>
<li><code>git rebase</code> - permets de copier des commits pour avoir une arborescence plus linéaire</li>
<li><code>git rebase -i</code> - fenêtre intéractive pour réorganiser les commits comme tu veux</li>
<li><code>cherry-pick</code> - copie un ensemble de commits à l'endroit actuel, ce qui simplifie l'utilisation d'un <code>git rebase</code></li>
<li><code>git stash</code> - mémorise des modifications dans un endroit à part ; ça te permets de sauvegarder un travail qui ne compile pas par exemple. Options intéressantes : <code>drop</code>, <code>pop</code>, <code>list</code>, <code>show</code>, <code>save &lt;NAME&gt;</code>, <code>-p</code>.</li>
<li><code>git tag</code> - marque permannante sur un commit pour y accéder n'importe quand (à sa création, il faut appeler <code>git push --follow-tags</code> pour le partager avec tout le monde).</li>
<li><code>git fetch</code> - télécharge les infos sur le dépôt distant ; contrairement à <code>git pull</code>, aucun <code>merge</code> n'est réalisé entre le dépôt localement et celui à distance, donc cette commande est très peu utilisée</li>
</ul>
<h2 id="création-dun-compte-github"><a class="header" href="#création-dun-compte-github">Création d'un compte <a href="https://github.com">GitHub</a></a></h2>
<p>Afin de partager notre travail, on utilise les serveurs de GitHub. Il s'agit d'un service web qui offre une interface graphique à <code>git</code> tout en permettant de récupérer les projets du Club n'importe où.</p>
<p>Il faut donc que tu te crées un compte sur le site : <a href="https://github.com/">github.com</a>.</p>
<p>Une fois que c'est fait, demande à un membre du Club de t'ajouter dans l'organisation <a href="https://github.com/orgs/ClubRobotInsat/">ClubRobotINSAT</a>.</p>
<h2 id="configuration-de-git"><a class="header" href="#configuration-de-git">Configuration de <code>git</code></a></h2>
<p>Il faut configurer ton ordinateur pour qu'il te connaisse, voici comment :</p>
<ol>
<li>Ton nom associé aux <code>commit</code>
<ul>
<li><code>git config --global user.name &quot;[ton nom]&quot;</code></li>
</ul>
</li>
<li>Ton adresse mail associée aux <code>commit</code> (de préférence celle utilisée lors de la création de ton compte GitHub)
<ul>
<li><code>git config --global user.email &quot;[ton adresse mail]&quot;</code></li>
</ul>
</li>
<li>Colorisation des lignes (pas obligatoire mais pratique)
<ul>
<li><code>git config --global color.ui auto</code></li>
</ul>
</li>
</ol>
<h2 id="2-méthodes-pour-cloner-les-dépôts"><a class="header" href="#2-méthodes-pour-cloner-les-dépôts">2 méthodes pour <code>clone</code>r les dépôts</a></h2>
<h3 id="méthode-simple-avec-https"><a class="header" href="#méthode-simple-avec-https">Méthode simple avec HTTPS</a></h3>
<p>Le clonage en HTTPS est le plus simple et le plus couramment utilisé. Il ne demande que le lien vers le dépôt pour le cloner, et lorsqu'une authentification est requise (clone d'un dépôt privé, push, ...) il faut entrer son identifiant du serveur git (dans notre cas, <a href="https://github.com">github.com</a>) ainsi que son mot de passe.</p>
<p>Voici comment récupérer le code de la partie <code>info</code> :</p>
<pre><code class="language-bash">git clone https://&lt;ton_login_github&gt;@github.com/ClubRobotInsat/info.git
cd info
</code></pre>
<h3 id="méthode-alternative-avec-ssh"><a class="header" href="#méthode-alternative-avec-ssh">Méthode alternative avec SSH</a></h3>
<p><a href="https://github.com">github.com</a> propose une autre fonctionnalité accéder au serveur par <a href="https://fr.wikipedia.org/wiki/Secure_Shell">SSH</a>. La mise en place de cette méthode est un peu plus longue que le simple protocole HTTPS, mais ça te permettra de t'affranchir de devoir entrer ton mot de passe et ton identifiant à chaque intéraction avec le serveur.</p>
<p>Je te laisse suivre les <a href="https://help.github.com/articles/connecting-to-github-with-ssh/">instructions détaillées</a> pour ajouter la clef SSH sur github.</p>
<p>Enfin, voici comment récupérer un dépôt :</p>
<pre><code class="language-bash">git clone git@github.com:ClubRobotInsat/info.git
cd info
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide"><a class="header" href="#ide">IDE</a></h1>
<p><em>Cette page s'adresse à la fois aux infos et aux élecs soft.</em></p>
<p>Comme tu as pu le constater, l'arborescence du code est assez complexe et il y a beaucoup de fichiers. Pour coder facilement, il existe des outils qui nous facilitent la vie : les <a href="https://fr.wikipedia.org/wiki/Environnement_de_d%C3%A9veloppement">environnements de dévelopement</a>, ou encore des IDE.</p>
<p>Dans ce guide, nous installerons un IDE pour le langage <a href="https://isocpp.org/">C++</a> qui est le langage utilisé pour la partie informatique du robot. Notre choix se porte sur CLion qui est développé par JetBrains. Il s'agit d'un IDE à la fois flexible, simple d'utilisation, multiplateforme et qui a la particularité d'utiliser nativement <a href="https://cmake.org/">CMake</a>, le système de build utilisé par notre code.</p>
<p>Cet IDE est normalement payant, mais une version d'éducation (licence valide 1 an, renouvelable tant que l'on est étudiant) est disponible.</p>
<h2 id="téléchargement-de-lide"><a class="header" href="#téléchargement-de-lide">Téléchargement de l'IDE</a></h2>
<p>Pour commencer, il faut :</p>
<ol>
<li>Se rendre sur la page de <a href="https://www.jetbrains.com/clion/download/">CLion</a> et télécharger la dernière version, ou <a href="https://www.jetbrains.com/toolbox/app/?fromMenu">télécharger la <strong>Toolbox App</strong></a> si tu veux utiliser des IDEs pour d'autres langages</li>
<li>Pendant le téléchargement, aller sur la page de <a href="https://www.jetbrains.com/shop/eform/students">jetbrains.com</a> pour demander une licence éducation. L'adresse mail à fournir est celle de l'INSA (<em>&lt;nom&gt;@etud.insa-toulouse.fr</em>) pour que JetBrains accepte de délivrer la licence.</li>
<li>Va voir ta boîte mail, un message contenant un lien de confirmation est arrivé : confirme ton adresse mail</li>
<li>Tu reçois enfin un autre mail avec les infos de la licence, qu'il faudra saisir dans CLion</li>
</ol>
<h2 id="lancement"><a class="header" href="#lancement">Lancement</a></h2>
<p>Une fois le téléchargement terminé, il ne reste plus qu'à configurer ton ordinateur pour exécuter l'IDE :</p>
<ol>
<li>Il faut extraire l'archive téléchargée sur le site de CLion et copier le dossier <code>&lt;clion-version&gt;</code> dans <code>/opt/clion</code>:
<pre><code class="language-bash">cd ~/Downloads
tar -xvf &lt;nom de l'archive d'installation&gt;
sudo cp &lt;nom du dossier extrait&gt; /opt/clion -R
</code></pre>
</li>
<li>On renomme le script de lancement <code>clion.sh</code> en <code>clion</code> parce que c'est plus joli (selon mes goûts, j'aime aussi le orange si jamais).
<pre><code class="language-bash">sudo mv /opt/clion/bin/clion.sh /opt/clion/bin/clion
</code></pre>
</li>
<li>Il faut maintenant ajouter le script de lancement de Clion à ta <a href="https://fr.wikipedia.org/wiki/Variable_d%27environnement">variable d'environnement</a> <code>$PATH</code>:
<pre><code class="language-bash">echo &quot;export PATH=/opt/clion/bin:$PATH&quot; &gt;&gt; ~/.bashrc
</code></pre>
Le <code>PATH</code> est une variable d'environnement qui contient une suite de chemins séparés par des deux points <code>:</code>.
La ligne ci-dessus concatène lors de l'ouverture d'un terminal <strong>bash</strong> à la variable <code>PATH</code> le chemin de lancement de CLion.</li>
<li>Tu peux maintenant ouvrir un terminal et taper :
<pre><code class="language-bash">clion
</code></pre>
Ou, si jamais tu n'a pas suivi l'étape de renommage :
<pre><code class="language-bash">clion.sh
</code></pre>
</li>
</ol>
<p><em><strong>Pour les utilisateurs d'un Ubuntu standard :</strong></em> Lorsque CLion est en cours d'exécution, son icône est affiché dans la barre des tâches à gauche. Pour le lancer plus rapidement, il te suffit de faire un click droit sur l'icône -&gt; 'Lock to Launcher'</p>
<p>Si jamais l'IDE se lance, tu viens d'installer avec succès CLion ! Sinon je t'encourage à venir montrer le message d'erreur aux gens du club.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="informatique"><a class="header" href="#informatique">Informatique</a></h1>
<p><img src="info//images/com/raspy.svg" alt="Raspberry PI 3 - Club Robot INSA Toulouse" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mise-en-place"><a class="header" href="#mise-en-place">Mise en place</a></h1>
<p>Dans cette section, nous allons installer pas à pas tous les outils pour pouvoir développer du code dans le pôle informatique du Club Robot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide-1"><a class="header" href="#ide-1">IDE</a></h1>
<p>Normalement, tu as déjà suivi les instructions de la section <a href="info/mise_en_place//outils_communs/ide.html">Outils Communs - IDE</a>, tu as donc l'IDE CLion déjà fonctionnel.</p>
<p>Si ce n'est pas le cas, reviens un peu en arrière et installe CLion !</p>
<h2 id="configuration-spécifiques-au-club-robot"><a class="header" href="#configuration-spécifiques-au-club-robot">Configuration spécifiques au Club Robot</a></h2>
<p>Il ne reste plus qu'une étape et la configuration de ton IDE sera finalisée pour la partie <code>info</code>.</p>
<p>Dans le menu <code>File -&gt; Settings</code>, dérouler l'item <code>Build, Execution, Deployment</code> et sélectionner <code>CMake</code>. Il faut ensuite remplir certains champs :</p>
<ul>
<li>dans <code>CMake options</code>, mettre le texte <code>-DDEBUG=on -DBITS=64</code> : on spécifie à <code>CMake</code> des flags supplémentaires qui sont utilisés par le projet</li>
<li>dans <code>Generation path</code>, mettre le texte <code>build</code></li>
<li>dans <code>Build options</code>, mettre le texte <code>-j 4</code> : on compile avec 4 coeurs (ou 8 si ton processeur en a 8)</li>
</ul>
<p>Enfin, pour pouvoir tester les IA via la liaison série (<a href="https://fr.wikipedia.org/wiki/RS-232">RS232</a>) en utilisant CLion, et sans nécessiter les droits <code>root</code>, il faut ajouter ton utilisateur au groupe ayant accès à la liaison série <code>dialout</code> :</p>
<pre><code class="language-bash">sudo usermod -a -G dialout &lt;NOM_UTILISATEUR&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="répertoire-de-travail"><a class="header" href="#répertoire-de-travail">Répertoire de travail</a></h1>
<p>On utilise <code>git</code> pour gérer plus efficacement le code. Si le nom de ce logiciel ne te dis rien, je te conseille de revenir un peu en arrière pour aller lire <a href="info/mise_en_place//outils_communs/git.html">cette page</a>.</p>
<h2 id="clonage-du-dépôt"><a class="header" href="#clonage-du-dépôt">Clonage du dépôt</a></h2>
<p>Si ce n'est pas déjà fait, je te conseille de te créer un dossier spécifique à tout le Club Robot, par exemple comme ceci :</p>
<pre><code class="language-bash">mkdir -p ~/ClubRobot
cd ~/ClubRobot
</code></pre>
<p>Ensuite, on a besoin de deux dossiers en informatique, un premier qui contient tout le code info et un second qui permets de créer des tables de simulation facilement.</p>
<p>En t'inspirant de ce que tu as appris pour <a href="info/mise_en_place//outils_communs/git.html#a2-m%C3%A9thodes-pour-cloner-les-d%C3%A9p%C3%B4ts">cloner des dépôts</a>, je t'invite à récupérer les deux dossiers :</p>
<ul>
<li>
<pre><code class="language-bash">git clone https://github.com/ClubRobotInsat/pytable.git
git clone https://github.com/ClubRobotInsat/info.git
cd info
</code></pre>
</li>
<li>
<pre><code class="language-bash">git clone git@github.com:ClubRobotInsat/pytable.git
git clone git@github.com:ClubRobotInsat/info.git
cd info
</code></pre>
</li>
</ul>
<p>Félicitations, te voilà possesseur de tout le savoir informatique du Club !</p>
<h2 id="fonctionnement-des-branches"><a class="header" href="#fonctionnement-des-branches">Fonctionnement des branches</a></h2>
<p>Comme tu peux le voir <a href="https://github.com/ClubRobotInsat/info/branches">sur la page GitHub</a>, on utilise plusieurs <code>branch</code>es en même temps. Cette fonctionnalité de <code>git</code> nous permets de travailler en parallèle sur plusieurs projets.</p>
<p>La branche <code>master</code> est protégée : on n'y mets que des versions totalement fonctionnelles <em>(cette branche ne nous sert par beaucoup)</em>.</p>
<p>Tout le code que nous écrivons passe par la branche <code>develop</code> donc je t'invite dès maintenant à te rendre dessus :</p>
<pre><code class="language-bash">git checkout develop
git pull
</code></pre>
<p>Il s'agit de notre branche principale de développement. Afin d'avoir une architecture propre pour s'y retrouver, on utilise des branches pour chaque fonctionnalité en cours de développement. L'objectif est de partir de <code>develop</code> qui est propre, basculer sur une branche temporaire pour développer la fonctionnalité puis <code>merge</code> ce nouveau code lorsqu'il est fonctionnel dans <code>develop</code>.</p>
<p>Prenons l'exemple d'un développement sur le simulateur :</p>
<pre><code class="language-bash">git checkout develop     # On se mets sur la branche mère `develop`
git checkout -b dev-simu # Création d'une nouvelle branche spécialement pour le simulateur à partir de `develop`
# MAKE YOUR CODE
git add -p               # Ajout des fonctionnalités
git commit               # Autant de commits que tu veux jusqu'à ce que ça marche
</code></pre>
<p>Une fois que tu es satisfait de ton code, tu as deux possibilités :</p>
<ul>
<li><code>git checkout develop &amp;&amp; git merge dev-simu</code> pour intégrer directement le code dans la branche principale ; il faut que tu sois sur de toi :wink:</li>
<li>Depuis <a href="https://github.com/clubrobotinsat/info/pulls">la page <strong>Pull requests</strong></a>, crée une nouvelle requête pour <code>merge</code> ta nouvelle branche <code>dev-simu</code> dans <code>develop</code>. Ça permets d'avoir une <em>review</em> d'autres personnes sur ton travail, ce qui ne fait jamais de mal. Le retour des autres membres te permets de perfectionner ton code, te faire penser à certaines choses qui n'apparaissent pas dans les tests unitaires par exemple ou encode de valider ton travail pour l'intégrer dans le code. Bien évidemment, cette manière de faire est très fortement recommandée !</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation"><a class="header" href="#compilation">Compilation</a></h1>
<p>Dans cette section, nous allons t'installer tous les outils qui te permettront de compiler le projet informatique.</p>
<h2 id="logiciels-nécessaires"><a class="header" href="#logiciels-nécessaires">Logiciels nécessaires</a></h2>
<p>On utilise les outils suivants :</p>
<ul>
<li><code>git</code> : gestionnaire de versions pour le code, que tu as déjà dû installer</li>
<li><code>cmake</code> : grâce aux différents <code>CMakeLists.txt</code>, le projet se compile très facilement en invoquant <code>cmake</code> puis <code>make</code> (nous verrons plus tard comment utiliser cet outil)</li>
<li><code>clang-format</code> : cet utilitaire permets d'homogéniser tout le code pour qu'il respecte la même norme d'écriture</li>
<li><code>libbox2d-dev</code>, <code>libirrlicht1.8</code> : ces librairies permettent d'utiliser le simulateur du club</li>
</ul>
<p>Heureusement, un script s'occupe d'installer tous ces outils et d'autres encore pour assurer la compilation sans erreur du projet. Voici comment l'appeler (en considérant que vous êtes dans le dossier <code>info</code>):</p>
<pre><code class="language-bash">scripts/install.sh tools
</code></pre>
<h2 id="applications-recommandées"><a class="header" href="#applications-recommandées">Applications recommandées</a></h2>
<h3 id="formattage-du-code"><a class="header" href="#formattage-du-code">Formattage du code</a></h3>
<p>Un <em>hook</em> permets de lancer un script à chaque commit pour formater le code comme il faut :</p>
<pre><code class="language-bash">scripts/install.sh format
</code></pre>
<h3 id="gcc-recent-en-tant-que-compilateur"><a class="header" href="#gcc-recent-en-tant-que-compilateur"><em>gcc</em> recent en tant que compilateur</a></h3>
<p>Cette section ne s'applique que si tu as eu un problème lors de l'exécution du script d'installation, pour <code>gcc-7</code> et <code>g++-7</code>.</p>
<p>Pour pouvoir compiler l'ensemble du code, il te faut un compilateur supportant <code>C++ 17</code>, donc au minimum <code>g++-7</code>.</p>
<h4 id="version-7"><a class="header" href="#version-7">version 7</a></h4>
<p>Si tu es sur un ancien Ubuntu (avant 17.04) :</p>
<pre><code class="language-bash">sudo add-apt-repository ppa:ubuntu-toolchain-r/test
</code></pre>
<p>Sinon :</p>
<pre><code class="language-bash">sudo add-apt-repository ppa:jonathonf/gcc-7.1
</code></pre>
<p>Puis :</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install gcc-7 g++-7
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 70 --slave /usr/bin/g++ g++ /usr/bin/g++-7
</code></pre>
<p>Si tu es sur Ubuntu 18, tu peux même installer <code>g++-8</code> :</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install gcc-8 g++-8
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-8
</code></pre>
<h4 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-compilation</a></h4>
<p>Pour pouvoir compiler du code qui sera compris par la raspberry (et pas que par ton ordinateur), tu vas avoir besoin d'autres versions de gcc. Pour les installer, tape simplement :
<code>sudo apt install g++-8-arm-linux-gnueabihf gcc-8-arm-linux-gnueabihf</code></p>
<h2 id="autres-installations"><a class="header" href="#autres-installations">Autres installations</a></h2>
<h3 id="lib-wiimote"><a class="header" href="#lib-wiimote">Lib Wiimote</a></h3>
<p>Si tu veux pouvoir contrôler le robot à l'aide d'une WiiMote, il faut installer la librairie <code>WiiC</code> nécessaire aux démos :</p>
<pre><code class="language-bash">scripts/install.sh wii
</code></pre>
<h3 id="clang-en-tant-que-compilateur"><a class="header" href="#clang-en-tant-que-compilateur"><em>Clang</em> en tant que compilateur</a></h3>
<p>Si tu veux utiliser un autre compilateur par défaut (<a href="https://clang.llvm.org/"><code>clang</code></a>), voici les commandes à utiliser :</p>
<pre><code class="language-bash">sudo apt-get install clang-3.8
sudo update-alternatives --install /usr/bin/c++ c++ /usr/bin/clang++-3.8 100
</code></pre>
<p>Cependant, tous les membres actuels utilisent <code>gcc</code> par défaut.</p>
<h3 id="petrilab"><a class="header" href="#petrilab">Petrilab</a></h3>
<p>Ce logiciel permets d'éditer des <a href="https://fr.wikipedia.org/wiki/R%C3%A9seau_de_Petri">réseaux de Petri</a>. Il a été développé en interne par <a href="https://github.com/rems4e">rems4e</a> et il nous permets de créer graphiquement des stratégies.</p>
<p>Son installation actuelle est vouée à évoluer prochainement pour le plus avoir les fichiers binaires directement dans le dépôt git, et les systèmes d'exploitation pris en charge pour le moment sont les suivants :</p>
<ul>
<li>Ubuntu 14.04 <code>Trusty</code></li>
<li>Ubuntu 17.04 <code>Zesty</code></li>
<li>Ubuntu 18.04 <code>Bionic</code></li>
</ul>
<p>Pour avoir des informations sur ton OS, utilise la commande <code>lsb_release --all</code> ; s'il correspond à ceux disponibles, alors tu peux simplement appeler le script d'installation :</p>
<pre><code class="language-bash">scripts/install.sh petri
</code></pre>
<h2 id="problèmes-de-compilation-connus"><a class="header" href="#problèmes-de-compilation-connus">Problèmes de compilation connus</a></h2>
<ul>
<li>Problème de <em>clock skew</em> ? Il suffit de lancer <code>find -exec touch \{\} \;</code> dans le dossier <code>info</code>. Attention, cela peut être un petit peu long.</li>
<li>Problème lors d'un appel à <code>cmake</code> ? Commence par <em>clean</em> tous les fichiers générés : <code>Tools &gt; CMake &gt; Reset Cache and Reload Project</code>.</li>
</ul>
<h2 id="test-de-lenvironnement-de-travail"><a class="header" href="#test-de-lenvironnement-de-travail">Test de l'environnement de travail</a></h2>
<p>A présent que ton ordinateur est totalement configuré, il est temps de compiler le code !</p>
<p>L'interface de CLion peut paraître compliquée de prime abord, c'est pourquoi il ne faut pas hésiter à demander de l'aide à un membre du Club.</p>
<p>Une des fonctionnalités les plus utilisées est celle de la compilation intégrée. Pour cela, en haut à droite de la fenêtre, choisis la target <code>BuildAll</code>. Comme tu peux le voir, de nombreuses applications peuvent être compilées, et on veut actuellement s'assurer que tout compile chez toi. Ensuite, appuie sur le bouton à gauche de la liste déroulante pour compiler. Attention, ça va prendre un peu de temps.</p>
<p><img src="info/mise_en_place//images/ide/BuildAll.png" alt="CLion et sa fonctionnalité BuildAll" /></p>
<p>Si il n'y a pas de messages d'erreur, <em><strong>BRAVO</strong></em> tu viens d'installer avec succès tout l'environnement de travail !</p>
<p>Sinon, je te conseille de te rapprocher d'un membre du pôle informatique.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outils-informatiques"><a class="header" href="#outils-informatiques">Outils informatiques</a></h1>
<p>Si ce n'est pas déjà fait, je te conseille dans un premier temps d'installer <code>git</code> et <code>CLion</code> en allant  dans la section des <a href="info/outils//outils_communs/index.html">outils communs</a>.</p>
<p>Le code informatique a une certaine taille (700 fichiers pour 200.000 lignes de code) et l'ensemble des fichiers sont répartis dans une arborescence relativement dense.</p>
<p>De plus, n'oublie pas cette devise :</p>
<blockquote>
<p>Un bon informaticien est un informaticien fénéant.</p>
</blockquote>
<p>Ainsi, on proscrit au maximum les copiés/collés donc certaines parties de code sont empaquetés dans des <code>librairies</code> et sont réutilisées dans de très nombreux endroits du projet.</p>
<p>Enfin, il faut toujours se rappeler qu'un ordinateur est bête et qu'il n'exécute que ce qu'on lui dit de faire, donc pour compiler ton Intelligence Artificielle révolutionnaire qui va nous envoyer directement en finale, il ne suffit pas d'appeler le compilateur avec <code>g++ IA.cpp</code> mais il faut donner les liens vers les librairies qui s'occupent des cartes électroniques, celles vers les outils mathématiques, spécifier quels répertoires sont utilisés pour compiler, éventuellement créer les librairies dynamiques associées et bien d'autres choses encore.</p>
<p>Afin d'éviter de t'infliger de telles soufrances, on utilise un utilitaire qui permets de gérer efficacement un tel projet grâce à <code>cmake</code>. On va ensuite détailler les librairies développées en interne au club pour faciliter la programmation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake"><a class="header" href="#cmake">CMake</a></h1>
<p><code>cmake</code> est un utilitaire open-source et multi-plateformes qui permet indépendemment du compilateur de générer des fichiers utilisables pour la compilation. De plus, l'IDE <a href="https://www.jetbrains.com/clion/">CLion</a> utilise nativement <code>cmake</code>, ce qui veut dire qu'il va te faire gagner énormément de temps à chaque fois que tu travailleras avec un projet configuré avec <code>cmake</code>.</p>
<p>Son installation est très simple, il te suffit d'exécuter</p>
<pre><code class="language-bash">sudo apt-get install cmake
</code></pre>
<h2 id="explications-du-fonctionnement"><a class="header" href="#explications-du-fonctionnement">Explications du fonctionnement</a></h2>
<p><code>cmake</code> est à utiliser avec le programme <code>make</code> (tu n'as pas à l'installer en plus, il est déjà présent sur ton ordinateur).</p>
<p>À l'origine, les projets en <code>C</code> étaient compilés avec <code>make</code> grâce à des fichiers de configuration, des <code>Makefile</code>. Pour te donner une idée de ce à quoi ils ressemblent, voici un exemple (qui n'a rien à voir avec le Club Robot) :</p>
<pre><code class="language-make">CC        := gcc
LD        := gcc

vpath %.c $(SRC_DIR)

define make-goal
$1/%.o: %.c
	$(CC) -std=gnu99 -Wall -m32 -g -I $(INCLUDES) -c $$&lt; -o $$@
endef

.PHONY: all checkdirs clean

all: checkdirs build/client

build/client: $(OBJ_CLI)
	$(LD) -m32 $^ -o $@ -lm -lpthread -g

checkdirs: $(BUILD_DIR)

$(BUILD_DIR):
	@mkdir -p $@

clean:
	@rm -rf $(BUILD_DIR)

distclean:
	@rm -rf $(BUILD_DIR)
	@-rm -f *.tar.gz || true

$(foreach bdir,$(BUILD_DIR),$(eval $(call make-goal,$(bdir))))
</code></pre>
<p>Si tu es en train de te dire que c'est illisible, c'est normal et tu n'as pas à apprendre cette syntaxe rassure-toi.</p>
<p>En effet, l'objectif de <code>cmake</code> et de rajouter une surcouche à l'étape de compilation en permettant au programmeur d'écrire dans un anglais plus lisible (c'est à dire qu'il rajoute un couche d'abstraction).</p>
<p>Ainsi, tu vas travailler avec des fichiers de configuration nommés <code>CMakeLists.txt</code>. Voici un petit exemple du fichier qui gère tout le code du robot principal :</p>
<pre><code class="language-cmake">set(ROBOT_PRINC_SOURCE
        ../Commun/Strategie.cpp
        librobot/Robot.cpp
        librobot/MecaManager.cpp
        librobot/Strategie.cpp
        #librobot/Ascenseur.cpp
        petri/Deplacement.cpp
        petri/Servo.cpp
        petri/Moteur.cpp
        petri/Utils.cpp
        petri/PetriCommon.cpp
        librobot/StrategyGenerator/MagicStrategy.cpp)

add_library(robotPrincipal STATIC ${ROBOT_PRINC_SOURCE})
add_library(robotPrincipalInterfaceElec STATIC ${ROBOT_PRINC_SOURCE})

target_link_libraries(robotPrincipal Cartes Robot Strategie)
target_link_libraries(robotPrincipalInterfaceElec Robot_Interfacer_Elec Cartes Strategie)

add_executable(debug_calibration_depla debug/CalibrationDepla.cpp)
target_compile_options(debug_calibration_depla PUBLIC -Wno-deprecated)
target_link_libraries(debug_calibration_depla robotPrincipal)

include_directories(/usr/local/include/wiic/)

set(wiimote_sources IA/IAWiimote.cpp wiimote/Wiimote.cpp)
add_executable(IAWiimote ${wiimote_sources})
include_directories(/usr/local/include/wiic/)

add_executable(IAPrincipal IA/IAPrincipal.cpp)

if (RASPI)
	message(STATUS &quot;Compiling IAPrincipal for the raspi&quot;)
	link_directories(/usr/arm-linux-gnueabihf/lib)
	target_link_libraries(IAPrincipal robotPrincipal PetriRuntime dl)

else()
	target_link_libraries(IAWiimote robotPrincipal wiicpp)
	target_link_libraries(IAPrincipal robotPrincipal)
endif()


add_executable(IATestDeplacement IA/IATestDeplacement.cpp)
target_link_libraries(IATestDeplacement robotPrincipal)

add_executable(IATestMeca IA/IATestMeca.cpp)
target_link_libraries(IATestMeca robotPrincipal)
</code></pre>
<p>Ensuite, une fois ces fichiers bien configurés, il te suffit d'aller dans la racine du dossier et de taper les commandes suivantes :</p>
<pre><code class="language-bash">mkdir -p build
cd build
cmake ..
make all
</code></pre>
<p>Tout est automatisé ; dans un premier temps les <code>Makefile</code>s vont être générés puis la commande <code>make</code> va lire ces fichiers pour les compiler grâce à <code>g++</code>. À la fin du processus (la compilation peut prendre jusqu'à une dizaine de minutes en tout), tu auras les fichiers binaires dans le dossier <code>/info/build</code> prêts à être exécutés.</p>
<h2 id="cheatsheet"><a class="header" href="#cheatsheet">Cheatsheet</a></h2>
<p>Ce paragraphe n'a bien sûr pas pour but d'être exhaustif, si tu as besoin de trouver des commandes spécifiques je te conseille d'aller voir <a href="https://gitlab.kitware.com/cmake/community/wikis/home">vers le wiki</a>.</p>
<h3 id="cmakeliststxt-principal"><a class="header" href="#cmakeliststxt-principal"><code>CMakeLists.txt</code> principal</a></h3>
<p>Pour une meilleure lisibilité, les configurations sont réparties dans chaque dossier. Il y a un <code>CMakeLists.txt</code> principal qui fait des configurations globales, et qui appelle ensuite les <code>CMakeLists</code> des sous-dossiers pour compartimenter le simulateur du robot par exemple.</p>
<ul>
<li><code>cmaks_minimum_required(VERSION 3.0)</code> - certaines fonctionnalités de <code>cmake</code> sont apparues dans les versions les plus récentes donc il faut toujours spécifier ce flag</li>
<li><code>project(root)</code> - définission du nom global du projet</li>
<li><code>option(&lt;NAME&gt; &quot;&lt;comments&gt;&quot; [DEFAULT])</code> - permets de donner des options pendant le lancement de <code>cmake</code>. Par exemple, avec l'<code>option(BITS &quot;Build en 32 ou 64 bits&quot; 64)</code>, on peut forcer la compilation en 32 bits avec l'appel <code>cmake .. -DBITS=32</code></li>
<li><code>add_definitions(&lt;DEFINITION&gt;)</code> - spécifie des définitions pour la compilation</li>
<li><code>add_subdirectory(&lt;PATH&gt;)</code> - appelle le <code>CMakeLists</code> d'un dossier enfant, par exemple celui du simulateur</li>
<li><code>link_directories(/usr/local/lib/)</code> - permets d'utiliser des librairies déjà existantes (par exemple, celle de <a href="http://box2d.org/">box2d</a> pour la gestion du moteur physique)</li>
</ul>
<h3 id="commandes-les-plus-utilisées"><a class="header" href="#commandes-les-plus-utilisées">Commandes les plus utilisées</a></h3>
<ul>
<li><strong>conditions</strong> :
<pre><code>   if(COLOR)
      set(CMAKE_COLOR_MAKEFILE ON)
   else()
      set(CMAKE_COLOR_MAKEFILE OFF)
   endif()
</code></pre>
Tests d'égalité : <code>${BITS} EQUAL 32</code>, <code>${CMAKE_CXX_COMPILER_ID} STREQUAL &quot;^(Apple)?Clang$&quot;</code></li>
<li><strong>créer des variables</strong> : <strong><code>set(&lt;NAME&gt; &lt;VALUE)</code></strong> ; exemple : <code>set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++14&quot;)</code> ; <code>set(FILES_SOURCE src/file1.cpp src/file2.cpp)</code></li>
<li><strong>librairies</strong>
<ul>
<li>Créer une librairie : <code>add_library(&lt;NAME&gt; STATIC ${FILES_SOURCE})</code></li>
<li>Lier une cible vers une librairie : <code>target_link_libraries(&lt;TARGET&gt; &lt;Lib1&gt; [Lib2] [...])</code></li>
<li>Récupérer les fichiers d'une librairie externe : <code>find_package(&lt;NAME&gt;)</code> (<a href="https://cmake.org/cmake/help/v3.0/command/find_package.html">wiki</a>)</li>
</ul>
</li>
<li>créer un nouvel exécutable : <code>add_executable(&lt;NAME&gt; &lt;file1&gt; [file2] [...])</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="petrilab-1"><a class="header" href="#petrilab-1">PetriLab</a></h1>
<p>Cette application a été créée en interne au Club Robot par <a href="https://github.com/rems4e">Rémi SAUREL</a>.</p>
<p>Au lieu d'écrire les IAs (Intelligences Artificielles) directement en ligne de code, ce qui peut rapidement être indigeste et surtout très peu maintenable pendant la coupe, le logiciel permets d'utiliser une interface graphique pour gérer toute la stratégie.</p>
<p>Ses avantages sont multiples :</p>
<ul>
<li>sans aucune notion en informatique, le logiciel est accessible à Monsieur Toulemonde</li>
<li>il gère la parallélisation des tâches (avancer en ouvrant des pinces tout en allumant des moteurs et en affichant du texte à l'écran), ce qui demanderait beaucoup de travail en lignes de code</li>
<li>on peut contrôler le robot depuis un mode <code>debug</code>, et donc construire la stratégie en live</li>
</ul>
<p>Le logiciel offre de nombreuses fonctionnalités, et cette page a pour but de t'expliquer comment l'utiliser.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Ce logiciel n'est pas en open-source et son installation n'est accessible qu'aux membres du Club Robot actuellement. De plus, il faut que tu aies Ubuntu 14.04, 17.04 ou 18.04.</p>
<p>Pour ce faire, après avoir <a href="info/outils//info/mise_en_place/repertoire_de_travail.html#clonage-du-d%C3%A9p%C3%B4t">cloner le dépôt info</a>, je t'invite à écrire cette ligne de commande :</p>
<pre><code class="language-bash">cd &lt;dossier info&gt;
scripts/install.sh petri
</code></pre>
<p>Le script d'installation va te demander un mot de passe ; à ce moment, demande à un membre du Club pour finaliser ton installation.</p>
<h2 id="prise-en-main-du-logiciel"><a class="header" href="#prise-en-main-du-logiciel">Prise en main du logiciel</a></h2>
<p><em><strong>TODO</strong></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explications"><a class="header" href="#explications">Explications</a></h1>
<p>La lecture de ce dossier va te permettre d'avoir un avant goût de l'architecture du code informatique. Je vais essayer de te donner les clefs pour comprendre comment te ballader dans l'arborescence et j'en profiterais pour entrer dans des détails plus techniques.</p>
<p>Bien entendu, ce tutoriel ne peut pas être exhaustif donc je te conseille d'aller voir le code directement et de lancer quelques exécutables pour comprendre leur fonctionnement, en utilisant les clefs de lecture que je vais te donner ici.</p>
<p>Bonne lecture !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-de-la-racine-du-projet-info"><a class="header" href="#architecture-de-la-racine-du-projet-info">Architecture de la racine du projet info</a></h1>
<p>Si tu as déjà regardé des projets C++, tu as certainement dû te rendre compte d'une certaine similaritude entre les dossiers tout en haut de l'architecture.
Cette 'normalisation' permets de passer d'un projet à un autre sans être perdu, et bien sûr une architecture bien structurée permets de gagner beaucoup de temps.</p>
<p>Je te propose un listing des items qui valent un coup d'oeil. Pour rappel, tu peux regarder le code durant ta lecture sur <a href="https://github.com/ClubRobotInsat/info">github</a> et tu peux cliquer sur les liens de chaque fichier.</p>
<h2 id="fonctionnement-de-git"><a class="header" href="#fonctionnement-de-git">Fonctionnement de <code>git</code></a></h2>
<p>Afin de proposer tous ses services, <code>git</code> a besoin d'un certain nombre de fichiers de configuration. Voici ses principaux ainsi que leur rôle :</p>
<ul>
<li>
<p><strong><code>.git/</code></strong> - Ce dossier contient toutes les informations utiles à <code>git</code> pour gérer le répertoire de travail. Je te conseille grandement de voir ce dossier comme une boîte noire et de ne pas y bidouiller des fichiers au risque de tout casser !</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/blob/develop/.gitignore"><code>.gitignore</code></a></strong> - Cette fonctionnalité de <code>git</code> est très intéressante : elle permets de demander au logiciel d'ignorer les fichiers spécifiés. Par exemple, on demande à <code>git</code> de ne pas <code>commit</code> les exécutables à chaque fois car ça n'a aucun intérêt et ça prendrait bien trop de place.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/.gitmodules"><code>.gitmodules</code></a> - On travaille avec d'autres projets open source et <code>git</code> propose des sous-modules qui correspondent à des dossiers dont l'origine vient d'un autre projet. On peut donc utiliser des librairies développées par d'autres personnes sans devoir passer du temps nous-mêmes à les créer. Attention cependant, si tu veux rajouter un sous-module au projet, il vaut mieux utiliser la commande <code>git submodule add &lt;lien&gt; [chemin local]</code> pour être sûr de bien tout configurer, puis il faut faire appel à <code>git submodule update --init --recursive --remote</code> pour mettre à jour tous les submodules (mais cette commande est automatisée à chaque appel à <code>cmake</code>).</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/.gitattributes"><code>.gitattributes</code></a> - On demande explicitement à <code>git</code> de considérer certains fichiers d'une certaine manière, par exemple tous les <code>.petri</code> comme des fichiers binaires (dans notre cas, ça évite de polluer l'affichage des commits sur github).</p>
</li>
</ul>
<h2 id="fichiers"><a class="header" href="#fichiers">Fichiers</a></h2>
<ul>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/blob/develop/LICENSE"><code>LICENSE</code></a></strong> - Ce fichier permets de spécifier la license utilisée pour la mise en open source du code ; on utilise la <a href="https://opensource.org/licenses/MIT">license MIT</a> et je t'invite à te renseigner sur les <a href="https://opensource.org/licenses">licenses d'open source</a> si le domaine de l'open source t'intéresse.</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/blob/develop/README.md"><code>README.md</code></a></strong> - Ce fichier est présent dans tous les répertoires hébergés sur <a href="https://github.com">github.com</a>. Il permets de savoir ce qu'il y a dans le dépôt, donner des explications sur le code, faire de la documentation ou encore donner des références vers d'autres projets ; la rédaction de ce fichier est très libre.</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/blob/develop/CMakeLists.txt"><code>CMakeLists.txt</code></a></strong> - Il s'agit du fichier de configuration de <a href="https://cmake.org/">cmake</a> global à tout le projet. Si ce n'est déjà fait, je t'invite à aller lire <a href="info/explications/info/outils/cmake.html">la documentation sur CMake</a> pour avoir une idée de ce que fait le logiciel.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/.clang-format"><code>.clang-format</code></a> - Tu ne vas pas forcément trouver ce fichier dans tous les projets, mais il est très pratique et permets d'appliquer des règles d'indentation à chaque <code>commit</code> pour s'assurer une homogénisation du code entre les développeurs.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/doxyconfig"><code>doxyconfig</code></a> - <a href="https://www.stack.nl/%7Edimitri/doxygen/">Doxygen</a> est un utilitaire qui permets de créer de la documentation à partir du code en utilisant ce fichier de configuration. Malheureusement, la documentation actuelle ne permets pas d'utiliser cet outil et un gros travail est à réaliser pour avoir une documentation fiable.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/TODO.txt"><code>TODO.txt</code></a> - Comme son nom l'indique, ce fichier permets de recenser les projets sur lesquels travailler pour l'année en cours.</p>
</li>
</ul>
<h2 id="dossiers"><a class="header" href="#dossiers">Dossiers</a></h2>
<ul>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/"><code>src/</code></a></strong> - Ce dossier regroupe tout le code source du projet informatique.</p>
</li>
<li>
<p><strong><code>build/</code></strong>, <code>build_arm/</code> - Ces dossiers sont le résultat de la (cross-)compilation du code et ils contiennent les exécutables. Bien entendu, ils ne sont présents que localement et <code>git</code> les ignore lors du processus de création des <code>commit</code>s.</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/tree/develop/third_parties/"><code>third_parties/</code></a></strong> - Sous-modules (librairies) utilisés par le projet sous la forme de clones. Tout est automatisé dès lors que tu exécutes <code>cmake ..</code> depuis un dossier <code>build</code>.</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/tree/develop/doc/"><code>doc/</code></a></strong> - Dossier qui reprends les documentation jusqu'à présent du projet. Ce dossier a pour vocation de disparaître pour laisser la place à la documentation que tu lis actuellement.</p>
</li>
<li>
<p><strong><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/"><code>scripts/</code></a></strong> - Ce dossier est très intéressant dans le sens où il propose de nombreux scripts qui vont te faciliter la vie. Si tu veux des exemples concrets de l'utilisation des commandes <a href="https://www.gnu.org/software/bash/">bash</a> va vite lire ces scripts !</p>
<ul>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/build_arm.sh"><code>build_arm.sh</code></a> : Cross-compilation de <code>[all|principal|wii|test]</code> pour une archi ARM (la cible à compiler est à donner en paramètre).</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/install.sh"><code>install.sh</code></a> : Utilitaire pour t'aider à configurer ton ordinateur. Il est capable d'installer <code>[all|tools|petri|format|wii|raspi]</code> (paramètre à donner en argument) ; tu as déjà utilisé ce script pour la mise en place du dépôt normalement.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/pre-commit"><code>pre-commit</code></a> : script copié et automatiquement appelé à chaque commit dès lors que tu lances <code>scripts/install.sh format</code>, pour bien indenter ton code</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/send_file_to_rpi.sh"><code>send_file_to_rpi.sh</code></a> : se connecte au raspi et y envoie le fichier souhaité</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/send_ia_principale.sh"><code>send_ia_principale.sh</code></a> : cross-compile la target principale et envoi l'exécutable grâce au script précédent (script magique qui te mets bien 5 minutes avant un match !)</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/ssh_into_rpi.sh"><code>ssh_into_rpi.sh</code></a> : se connecte au raspi en SSH ; il faut préalablement configurer la connexion et brancher un câble RJ45 pour que ça marche</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/scripts/simu_launcher.sh"><code>simu_launcher.sh</code></a> : Utilitaire pour exécuter automatiquement le simulateur</p>
</li>
</ul>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/precompiled-libraries/"><code>precompiled-libraries/</code></a> - On utilise des librairies, notamment pour l'utilisation de la wii-mote. Pour plus de simplicité, on a cross-compilé ces librairies une fois pour toutes et on les stock ici afin de compiler plus facilement pour l'architecture ARM.</p>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/develop/cmake_modules"><code>cmake_modules/</code></a> - Répertorie des fonctions <code>cmake</code> pour aller chercher facilement des librairies sur ton ordinateur (les scripts restent très peu lisibles mais ils sont fonctionnels).</p>
</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>J'espère que cette énumération te permets d'y voir un peu plus clair et que ça ne te donne pas envie d'oublier à jamais l'architecture info !</p>
<p>Les parties suivantes vont entrer dans les détails de ce qu'il y a dans le dossier <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/"><code>src/</code></a>, n'hésite pas à demander à un informaticien du club plus d'explications sur tout ce qu'il y a en 'annexe' du code source.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue-globale-du-projet"><a class="header" href="#vue-globale-du-projet">Vue globale du projet</a></h1>
<p>En étant à la racine du dossier, je t'invite à exécuter ces deux commandes :</p>
<pre><code class="language-bash">$ find src -type f | wc -l
678

$ find src -type f | xargs wc -l
186823 total
</code></pre>
<p>Il y a actuellement 678 fichiers source pour presque 200.000 lignes de code ; je te l'accorde c'est beaucoup.</p>
<p>Bien sûr, tous ces fichiers sont structurés et ce petit schéma peut te donner une idée des merveilles que tu peux trouver dans le dossier <code>src/</code> :</p>
<p><img src="info/explications/../../images/info/arborescence.png" alt="Arborescence du projet de manière graphique" /></p>
<p>Bien entendu, ce fichier est à mettre à jour en fonction des nouvelles fonctionnalités apportées, et si tu veux y participer il faut utiliser le logiciel <a href="https://wiki.gnome.org/Apps/Dia/">dia</a>.</p>
<pre><code>sudo apt-get install dia
</code></pre>
<p>Comme tu peux t'en apercevoir, il y a trois parties principales :</p>
<ul>
<li><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/commun/"><code>commun</code></a> - Tu peux y retrouver plein d'outils qui facilitent la programmation (manipulation d'unités physiques, constantes, manipulation de la communication, ...). Ce dossier est hyper important, mais je te conseille dans un premier temps d'utiliser les outils pour travailler sur le reste avant de te plonger dans ces librairies (certaines notions sont un peu compliquées et tout ce code n'est pas forcément directement lié à la robotique).</li>
<li><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/"><code>simulateur/</code></a> - Ce dossier regroupe l'ensemble des fichiers nécessaires pour mettre au point un simulateur graphique qui nous permet de tester la stratégie du robot avant de l'avoir en vrai, mécaniquement parlant. Si tu veux en savoir plus sur l'architecture du simulateur, elle est détaillée <a href="info/explications/simu.html">ici</a>.</li>
<li><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/"><code>robot/</code></a> - Il y a toute la stratégie, les interfaces de manipulation des actionneurs, ... C'est dans ce dossier que la majorité du code est écrit, et c'est bien sûr la partie la plus ancrée avec les autres pôles.</li>
</ul>
<h2 id="présentation-des-abstraction-informatiques-autour-du-robot"><a class="header" href="#présentation-des-abstraction-informatiques-autour-du-robot">Présentation des abstraction informatiques autour du robot</a></h2>
<p>En informatique, il y a de nombreuses couches d'abstraction qui séparent les cartes électroniques de l'IA du match. Je te propose un petit aperçu de ces couches, des explications supplémentaires et spécifiques à chaque couche te seront apportées en suivant.</p>
<p><em><strong>CE TABLEAU DOIT ÊTRE MIS À JOUR</strong></em></p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;border-color:#999;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
.tg .tg-uys7{border-color:inherit;text-align:center}
.tg .tg-us36{border-color:inherit;vertical-align:top}
.tg .tg-xrpy{font-weight:bold;font-size:18px;border-color:inherit;text-align:center}
</style>
<table class="tg">
  <tr>
    <th class="tg-xrpy" colspan="5">Couches d'abstraction</th>
    <th class="tg-xrpy">Explications brèves</th>
    <th class="tg-xrpy" colspan="2">Localisation</th>
  </tr>
  <tr>
    <td class="tg-uys7" colspan="5">Petrilab</td>
    <td class="tg-uys7"><span style="font-weight:bold">Interface graphique</span> pour créer les stratégies</td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Principal/petri/">src/robot/Principal/petri/</a></td>
  </tr>
  <tr>
    <td class="tg-uys7">IAPrincipale</td>
    <td class="tg-uys7">IAWiiMote</td>
    <td class="tg-uys7">IATests</td>
    <td class="tg-uys7">IATestLidar</td>
    <td class="tg-uys7">...</td>
    <td class="tg-uys7"><span style="font-weight:bold">Exécution</span> de la <span style="font-weight:bold">stratégie</span> / tests haut niveau</td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Principal/IA/">src/robot/Principal/IA/</a></td>
  </tr>
  <tr>
    <td class="tg-uys7" colspan="2">Stratégie</td>
    <td class="tg-uys7" colspan="3">MecaManager</td>
    <td class="tg-uys7"><span style="font-weight:bold">Couleur</span>, <span style="font-weight:bold">repère</span>, temps, tirette ; fonctions <span style="font-weight:bold">haut niveau</span></td>
    <td class="tg-uys7"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Principal/librobot/Strategie.h">Strategie.h</a></td>
    <td class="tg-us36"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Principal/librobot/MecaManager.h">MecaManager.h</a></td>
  </tr>
  <tr>
    <td class="tg-uys7" colspan="5">RobotPrincipal <span style="font-style:italic">(public RobotCommun)</span></td>
    <td class="tg-uys7"><span style="font-weight:bold">Assignation</span> des cartes pour <span style="font-weight:bold">2018</span><br></td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Principal/librobot/Robot.h">src/robot/Principal/librobot/Robot.h</a></td>
  </tr>
  <tr>
    <td class="tg-uys7" colspan="5">RobotCommun <span style="font-style:italic">(virtual)</span></td>
    <td class="tg-uys7"><span style="font-weight:bold">Com'</span>, <span style="font-weight:bold">adversaire</span>, <span style="font-weight:bold">déplacements</span>, cartes</td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Commun/Robot.h">src/robot/Commun/Robot.h</a></td>
  </tr>
  <tr>
    <td class="tg-uys7">Déplacement</td>
    <td class="tg-uys7">Servos</td>
    <td class="tg-uys7">Moteurs<br></td>
    <td class="tg-uys7">Évitement<br></td>
    <td class="tg-uys7">...</td>
    <td class="tg-uys7"><span style="font-weight:bold">Interfaces</span> bloquantes</td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Commun/">src/robot/Commun/</a></td>
  </tr>
  <tr>
    <td class="tg-uys7" colspan="5">Cartes électroniques</td>
    <td class="tg-uys7">Communication par <span style="font-weight:bold">trames</span></td>
    <td class="tg-uys7" colspan="2"><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Cartes/">src/robot/Cartes/</a></td>
  </tr>
</table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communication-avec-le-hardware"><a class="header" href="#communication-avec-le-hardware">Communication avec le hardware</a></h1>
<p>En robotique, il est crucial de pouvoir communiquer entre l'ordinateur décisionnaire et avec l'ensemble des capteurs / moteurs qui animent le robot.</p>
<h2 id="histoire-de-la-communication-dans-le-club"><a class="header" href="#histoire-de-la-communication-dans-le-club">Histoire de la communication dans le Club</a></h2>
<p>Historiquement, le robot du Club était composé d'une multitude de cartes décentralisées et chacune avait une fonction spéficique (s'occuper de tous les servos moteurs par exemple). Ces cartes étaient reliées par un <a href="https://fr.wikipedia.org/wiki/Bus_de_donn%C3%A9es_CAN">bus CAN</a> avec l'ordinateur et de nombreuses trames transitaient de manière asynchrone.</p>
<p>Cependant, le savoir de l'utilisation des technologies utilisées (des microcontrôleurs à PIC) s'est perdue et entre 2017 et 2019, on a décidé de changer l'architecture pour</p>
<ul>
<li>maîtriser l'ensemble de la chaîne entre le hard et le soft</li>
<li>réaliser une documentation et un code propre pour faciliter le maintien et la passation du savoir</li>
<li>avoir une solution rapide pour remplacer de l'électronique en cas de dysfonctionnement</li>
<li>augmenter les capacités des cartes électroniques</li>
</ul>
<p>Ainsi, on a à présent une architecture décentralisée sur plusieurs cartes industrielles <a href="https://eu.mouser.com/new/stmicroelectronics/stm-nucleo-development-boards/">STM32 Nucleo</a>. La communication avec le soft se fait par ethernet, ce qui augmente la facilité de maintenance, la fiabilité et la puissance de communication.</p>
<hr />
<p>Il est maintenant temps de rentrer dans les détails techniques de cette communication décentralisée.</p>
<h2 id="trames-de-communication"><a class="header" href="#trames-de-communication">Trames de communication</a></h2>
<p>Le but est d'utiliser les bénéfices d'une communication entre deux 'cartes mères', et donc de partager le maximum d'informations entre l'informatique et l'électronique. Ainsi, les trames ne correspondent plus à un ordre sporadique addressé au hardware, mais elles regroupent l'ensemble de l'état du robot.</p>
<p>L'ordinateur envoie l'état du robot tel qu'il souhaite l'être, et la carte électronique travaille pour atteindre l'état voulu. Cet état général est envoyé par l'info puis renvoyé par l'élec et ce en permanence, avec une fréquence de <strong>FIXER LA FREQUENCE</strong>.</p>
<p>Le format de l'état se veut modulaire en JSON, afin de pouvoir être utilisé quel que soit le robot. Concrètement, la carte électronique est considérée comme un ensemble de modules indépendants (déplacement, évitement, moteurs, servos, capteurs...) qui possèdent chacun un ID, avec un <strong>maximum de 16</strong> modules connectés.</p>
<p>La tableau suivant regroupe les IDs des modules 'génériquement', mais il n'est bien sûr pas figé.</p>
<table><thead><tr><th align="center">ID</th><th align="center">Module</th></tr></thead><tbody>
<tr><td align="center">0x01</td><td align="center">Déplacement</td></tr>
<tr><td align="center">0x02</td><td align="center">Servos</td></tr>
<tr><td align="center">0x03</td><td align="center">IO</td></tr>
<tr><td align="center">0x04</td><td align="center">Évitement</td></tr>
<tr><td align="center">0x05</td><td align="center">Moteurs</td></tr>
<tr><td align="center">0x06</td><td align="center">Capteurs</td></tr>
</tbody></table>
<hr />
<h2 id="format-général-dune-trame"><a class="header" href="#format-général-dune-trame">Format général d'une trame</a></h2>
<p>Lorsque la partie informatique communique avec la carte appropriée à propos d'un module, les informations partagées sont encapsulées suivant plusieurs blocs :</p>
<ul>
<li>Chaque module sait parser <em>(ie lire et écrire)</em> un flux d'octets qui correspond à un format texte JSON, qui est très simple à lire. La spécification de la structure de données échangées dépend de chaque module et peut se trouver <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules">dans ce dossier</a>. Elle est également spécifiée plus loin dans ce document.</li>
<li>Pour savoir à quel module est addressé la trame, on rajoute son <strong><code>ID</code></strong> devant la trame sur un <code>u8</code>.</li>
<li>Enfin, la trame est envoyée sur le support physique :
<ul>
<li>dans le cas d'une liaison UDP, la taille de la trame se retrouve grâce aux informations du protocole de transport, donc il suffit d'envoyer un message contenant les données <code>{ID, trame}</code>. Les addresses IP utilisées sont les suivantes : <code>192.168.&lt;ID robot&gt;.&lt;ID module&gt;</code>, avec <code>&lt;ID robot&gt;</code> valant respectivement <code>0</code> et <code>1</code> pour les robots primaire et secondaire.</li>
<li>pour toutes les autres communications série, on encapsule <code>{ID, trame}</code> dans un header qui contient :
<ul>
<li>4 octets qui permettent de distinguer le début d'une trame intéressante ; c'est nécessaire car on est dans une communication asynchrone. Dans le cas du club, elles commencent par le pattern <code>0xAC DC AB BA</code> pour spécifier leur début</li>
<li>1 octet pour contenir la taille du message intéressant, c'est à dire la taille de <code>{ID, trame}</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="création-dune-liaison-de-communication"><a class="header" href="#création-dune-liaison-de-communication">Création d'une liaison de communication</a></h2>
<p>La classe <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Communication/Communicator.h"><code>Communicator</code></a> s'occupe se gérer la communication élec-info. Il suffit de faire appel à la méthode <code>connect</code> avec les bons arguments et la bonne liaison série est instanciée puis est capable de lire et écrire des trames.</p>
<p>Cet objet est capable de parler sur n'importe quel médium de communication, en faisait appel à un <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Communication/Protocol.h"><code>Protocol</code></a>. La première méthode appelable est <code>send_frame</code>, qui envoie une trame ; la seconde doit être lancée dans un thread spécifique et permets de recevoir des données pour les traiter avec un handler à fournir : <code>recv_frame(const atomic_bool&amp; b, function&lt;void(GlobalFrame)&gt;)</code>. Le premier argument permets d'interrompre la fonction, qui est bloquée dans un <code>while(b)</code>.</p>
<p>Voici les protocoles  possibles avec leurs arguments :</p>
<ul>
<li><strong>Liaisons séries</strong>
<ul>
<li><code>protocol_null</code> : <code> </code>, toutes les trames sont perdues</li>
<li><code>protocol_tcpip</code> : <code>string address, uint16_t port</code> connexion TCP client vers le serveur <code>address:port</code></li>
<li><code>protocol_local</code> : <code> </code>, les trames sont envoyées en TCP vers un le serveur <code>localhost:4321</code></li>
<li><code>protocol_pipes</code> : <code>string rx, string tx</code>, lecture et écriture sur des pipes nommées ; par défaut : <code>rx: &quot;/tmp/read.pipe&quot;</code>, <code>tx: &quot;/tmp/write.pipe&quot;</code></li>
<li><code>protocol_udp</code> : <code>string address, uint16_t local_port, uint16_t remote_port</code>, liaison UDP depuis le port local vers le serveur UDP <code>address:remote_port</code>. Ce protocole peut être utilisé dans les deux sens de communication, contrairement à l'implémentation actuelle de <code>protocol_tcpip</code>.</li>
</ul>
</li>
<li><strong>Communications sur plusieurs liaisons séries</strong>
<ul>
<li><code>protocol_ethernet</code> : <code>initializer_list&lt;UDPConnection&gt;</code>, permets de centraliser <code>N</code> connections UDP en un unique appel à un thread de réception bloquant. Ce protocole gère aussi l'association <code>id_module &lt;-&gt; UDP communication thread</code>.</li>
</ul>
</li>
</ul>
<p><img src="info/explications//images/info/communication.png" alt="UML de la communication" title="Diagramme UML de la communication" /></p>
<hr />
<h2 id="modules-spécialisés"><a class="header" href="#modules-spécialisés">Modules spécialisés</a></h2>
<p>Chaque module a un rôle particulier (gérer les servos, se déplacer, détecter l'adversaire, capter des infos dans ce monde de sauvage, ...). Pour faciliter la maintenabilité du code, des parties sont mises en commun entre l'info et l'élec.</p>
<p>Les deux parties utilisent un langage de programmation différent donc les deux parties doivent utiliser le même protocole pour communiquer. La solution retenue est d'envoyer des messages en format JSON encapsulés dans de l'UDP via une liaison ethernet.</p>
<p>Les formats de JSON sont appropriés pour le debug car les messages sont lisibles avec <a href="info/explications/www.wireshark.org">wireshark</a>. De plus, ils sont bien plus maintenables car le code est bien plus simple (on utilise des librairies pour parser le JSON).</p>
<p>LQ seule prérogative pour la partie en <code>Rust</code> est de déclarer des structures de données qui correspondent aux formats transités en JSON.</p>
<h3 id="format-du-module-servos"><a class="header" href="#format-du-module-servos">Format du module <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/Servos.h"><code>Servos</code></a></a></h3>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/Servos.h">Cette classe</a> permets de gérer un ensemble de <a href="https://www.robotshop.com/media/files/pdf/manual-drs-0101.pdf">servos-moteurs</a> en connaissant l'ensemble des informations qui leur sont propres et dont l'état est partagé avec les élecs.</p>
<p>Pour avoir une idée technique de son API, je te conseille d'aller voir directement le code source.
L'interface permets de rajouter des servos (ID &gt; 0) puis de contrôler chaque partie avec des fonctions thread-safe.</p>
<p>La sûreté par rapport au partage des données se fait grâce à une <a href="http://www.cplusplus.com/reference/mutex/">variable mutex</a> partagée et qui est bloquée à chaque accès sur des variables : si la trame des servos est en cours de génération, l'écriture du nouvel angle doit attendre pour que le mutex soit libéré.</p>
<p>Actuellement, cette classe gère 8 servos (la valeur est constante dans le code) et la trame associée est définie ainsi :</p>
<pre><code>&lt;id&gt;
{
  &quot;id&quot;: &lt;u8&gt;,
  &quot;known_position&quot;: &lt;u16&gt;,
  &quot;control&quot;: &quot;[Position|Speed]&quot;,
  &quot;data&quot;: &lt;u16&gt;,
  &quot;rotation&quot;: &quot;[Clockwise|CounterClockwise]&quot;,
  &quot;blocked&quot;: &lt;bool&gt;,
  &quot;mode&quot;: &quot;[Unblocking|HoldOnBlock]&quot;,
  &quot;color&quot;: &quot;[Block|Red|Green|Yellow|Blue|Magenta|Cyan|White]&quot;
}
</code></pre>
<p>Les états de chaque servomoteur est envoyé individuellement par le module pour limiter l'impact d'une perte de paquet ainsi que pour faciliter la lecture des trames.</p>
<h3 id="format-du-module-motors"><a class="header" href="#format-du-module-motors">Format du module <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/Motors.h"><code>Motors</code></a></a></h3>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/Motors.h">Cette classe</a> fournit une interface pour travailler avec 8 moteurs asservis, 8 moteurs non-asservis et 8 brushless, dont les fonctions associées sont spécifiques. Voici la trame qui spéficie les informations de tout ce beau monde :</p>
<pre><code>&lt;id&gt;
{
  ## TODO
}
</code></pre>
<h3 id="format-du-module-io"><a class="header" href="#format-du-module-io">Format du module <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/IO.h"><code>IO</code></a></a></h3>
<p><a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/IO.h">Cette classe</a> est un vestige d'une ancienne façade avec plein de boutons <em>(pour choisir la couleur, le type de connexion...)</em>. Elle ne sert actuellement qu'à détecter si la tirette est enclenchée ou non et ne relaye donc qu'un Booléen par l'intermédiaire de cette structure de trame :</p>
<pre><code>&lt;id&gt;
{
  &quot;tirette&quot;: &lt;bool&gt;
}
</code></pre>
<h3 id="format-du-module-navigation"><a class="header" href="#format-du-module-navigation">Format du module <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/Navigation.h"><code>Navigation</code></a></a></h3>
<p><em><strong>TODO</strong></em></p>
<hr />
<h2 id="interface-de-communication"><a class="header" href="#interface-de-communication">Interface de communication</a></h2>
<p>Comme tu l'as vu dans les parties précédentes, on possède à présent plein de modules qui gèrent des aspects différents du robot, et le <code>ModuleManager</code> offre un interfaçage facile pour connaître l'état du robot.</p>
<p>On peut générer l'état global du robot dans une trame, et mettre à jour le robot depuis une trame globale ; il ne reste plus qu'à gérer la communication entre l'info et l'élec !</p>
<p>Pour cela, tu peux aller voir <a href="https://github.com/ClubRobotInsat/info/tree/master/src/robot/Commun/Communication/ElecCommunicator.h">du côté du communicateur</a>. Son but est d'avoir en paramètre une classe qui lit et écrit des <code>GlobalFrame</code>s, ainsi qu'un médium de communication et il gère automagiquement la communication pour se connecter, exécuter le protocole de transmission de trames et arrêter à sa destruction la communication.</p>
<p>Afin d'être aussi général que possible, le communicateur peut prendre en paramètre n'importe quel objet qui donne accès aux fonctions de parsing :</p>
<ul>
<li><code>void read_frame(const GlobalFrame&amp;);</code></li>
<li><code>std::vector&lt;GlobalFrame&gt; write_frame() const;</code></li>
</ul>
<p>Si l'objet fourni ne possède pas ces deux définitions, la méthode <code>communicate_with_elecs</code> <em>(sencée être exécutée dans un thread pour recevoir et envoyer les trames)</em> devient inaccessible ; si la méta-programmation ne te fait pas peur tu peux aller voir <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Communication/ParsingClassChecker.hpp">comment vérifier l'existance des fonctions de parsing</a>.</p>
<hr />
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Voici un récapitulatif des couches d'abstraction que l'on vient d'aborder dans ce document :</p>
<ul>
<li>
<p>Wrapping de structures brutes en JSON pour connaître l'état de chaque module : <em><a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Modules/">lien</a></em></p>
<ul>
<li>du code <code>C++</code> et <code>Rust</code> (respectivement pour les infos et les élecs) englobe ces C-structs</li>
<li>nombreux avantages : rajout de sécurité, tests et interface fonctionnelle</li>
</ul>
</li>
<li>
<p>le <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/robot/Modules/ModuleManager.h"><code>ModuleManager</code></a> regroupe tous ces modules</p>
<ul>
<li>manipulation facilitée</li>
<li>tout l'état du robot est centralisé</li>
<li>parsing des trames globales</li>
</ul>
</li>
<li>
<p><a href="https://github.com/ClubRobotInsat/info/tree/master/src/robot/Communication/Communicator.h">communication avec les élecs</a> depuis les fonctions de parsing du <code>ModuleManager</code></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="détection-de-ladversaire--lidar"><a class="header" href="#détection-de-ladversaire--lidar">Détection de l'adversaire : LIDAR</a></h1>
<p>Jusqu'à présent, la détection de l'adversaire venait d'un projet <em>home-made</em> du club : un laser monté sur tourelle envoyait un rayon laser autour de la base. Une pièce réfléchissante était posée sur les robots adverses et le système était capable de connaître une valeur booléenne sur la présence d'un adversaire. Mécaniquement, le rayon passait soit au-dessus soit en-dessous de l'adversaire s'il n'était pas dans un rayon de 30 à 50 centimètres de notre robot. Les électroniques étaient enfin capables de nous donner l'angle auquel le robot a été détecté.</p>
<h2 id="explications-1"><a class="header" href="#explications-1">Explications</a></h2>
<p>Cette solution s'est inclinée face à l'utilisation de <a href="info/explications/">LIDAR</a>s depuis 2019. Il s'agit d'un capteur beaucoup plus précis que notre ancienne tourelle, qui map en 2D son environnement avec des lasers. En sortie, on a une liste de distances qui représentent N points détectés à une certaine distance de notre robot.</p>
<p>Le code développé en interne au club permets d'utiliser deux LIDARs différents : <strong>[Hokuyo](https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/Doc/Doc\ Hokuyo.pdf)</strong> et <strong><a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/Doc/doc_SICK.pdf">SICK TiM55x</a></strong>, le plus précis.</p>
<p>Dans un premier temps, un <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/Driver">code driver</a> est capable de communiquer avec chacun de ces LIDARs. Pour avoir une interface d'acquisition, il suffit d'utiliser ce code :</p>
<pre><code class="language-cpp">#include &quot;Lidar/Driver/lidar.h&quot;
std::unique_ptr&lt;Lidar&gt; my_lidar = Lidar::open_lidar(Lidar::Any);
</code></pre>
<h3 id="sick-tim55x"><a class="header" href="#sick-tim55x">SICK TiM55x</a></h3>
<p>Pour utiliser ce capteur, il faut exécuter le code en tant que <code>root</code>. De plus, il faut actuellement brancher l'électronique sur une alimentation à <code>16V / 0.2 A</code> pour brancher le câble circulaire à 5 broches sur le LIDAR. Il faut utiliser un autre câble USB que celui soudé entre le LIDAR et l'ordinateur.</p>
<h2 id="capacités-actuelles"><a class="header" href="#capacités-actuelles">Capacités actuelles</a></h2>
<p>Le code est capable de <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/filtre.h">filtrer</a> les trames d'acquisition. Ces points sont <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/lidarsToGrid.h">entreposés dans un plan 2D</a> en fonction des <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/commun/MathToolbox/Repere.h">coordonnées</a> du lidar ce qui permets de connaître la position absolue de chaque point dans un repère quelconque, quelque soit la position initiale du robot.</p>
<p>Grâce à la grande précision des LIDARs, la cartographie de toute la table est possible. Vu que le LIDAR est placé tout en haut de notre robot, les seuls points observés par le LIDAR représentent des points sur la table <em>(les arbitres n'influent pas sur les acquisitions)</em> en-dehors des objets à manipuler. Ainsi, seuls les robots adverses sont vus par le LIDAR, et donc les objets détectés par le LIDAR <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/FindRobots.h">sont considérés comme des robots adverses</a>.</p>
<h2 id="intégration-dans-le-code"><a class="header" href="#intégration-dans-le-code">Intégration dans le code</a></h2>
<p>Ce capteur est externe au travail dans électroniciens donc la classe <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Robot.h">Robot</a> contient directement une instance d'un <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/Lidar/lidar.h">LIDAR</a> en plus du <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Modules/ModuleManager.h">ModuleManager</a>. Il donne à disposition l'accès à <code>optional&lt;FrameLidar&gt; get_lidar_frame() const</code>, qui est ensuite utilisée <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot/Strategy/AbstractStrategy.h">dans la stratégie</a> pour détecter les adversaires en fonction de la position du robot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="création-dun-robot"><a class="header" href="#création-dun-robot">Création d'un robot</a></h1>
<p>Dans la <a href="info/explications/communication.html">partie précédente</a>, tu as vu comment sont gérées la communication et la représentation électronique des différents modules.</p>
<p>À présent, il est temps de voir comment le code informatique gère l'abstraction d'un robot !</p>
<h2 id="le-regroupement-des-constantes"><a class="header" href="#le-regroupement-des-constantes">Le regroupement des constantes</a></h2>
<p>Le choix a été fait de définir toutes les constantes dans un même <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/robot.ini">fichier d'initialisation</a>.</p>
<p>Ça permet notamment d'avoir un moyen de changer une constante (la durée d'un match, la composition modulaire des robots...) sans avoir à recompiler tout le projet, et donc de gagner du temps.</p>
<p>On utilise le <a href="https://en.wikipedia.org/wiki/INI_file">format INI</a>, comoposé de sections, de clefs et de valeurs ; le fichier est lisible et facilement maintenable.</p>
<h2 id="accès-aux-constantes-dans-le-code"><a class="header" href="#accès-aux-constantes-dans-le-code">Accès aux constantes dans le code</a></h2>
<p>Toutes les constantes sont initialisées en C++ dans <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/commun/Constants.h">ce fichier</a>. Une instance des constantes est définie globalement et il suffit de ce code pour récupérer des informations :</p>
<pre><code class="language-cpp">#include &lt;Constants.h&gt;

int main() {
  Duration match = GLOBAL_CONSTANTS().get_match_duration();
}
</code></pre>
<p>Bien entendu, ces constantes servent à définir globalement un match (temps de jeu, taille de la table...) mais elles permettent également de définir les robots présents sur la table, comme nous allons le voir.</p>
<h2 id="lobjet-robot"><a class="header" href="#lobjet-robot">L'objet <code>Robot</code></a></h2>
<p>Conceptuellement, un robot a besoin de répondre à différents critères :</p>
<ol>
<li>il possède une architecture électronique et donc mécanique</li>
<li>sa partie informatique <em>(décisionnelle)</em> est capable de communiquer avec sa partie électronique <em>(applicative)</em></li>
<li>il peut prendre des décisions pour évoluer dans son environnement</li>
</ol>
<p>Ça tombe bien, parce qu'on a à notre disposition le <code>ModuleManager</code> qui résoud le problème <strong>1</strong>, et l'<code>ElecCommunicator</code> qui correspond au <strong>2</strong>. Enfin, la partie <strong>3</strong> est une fonction réalisée à un niveau d'abstraction supérieur, et on va l'aborder dans la section <em><strong>Stratégie</strong></em>.</p>
<p>Un <code>Robot</code> a donc deux rôle principaux : il gère le <code>ModuleManager</code> et s'occupe de la communication en lançant dans un <a href="https://en.cppreference.com/w/cpp/thread/thread">thread</a> la communication.</p>
<p>Afin de simplifier son utilisation à la fois dans le contexte de la Coupe et afin de débuguer les modules électroniques.</p>
<ul>
<li>On peut construire l'électronique 'à la main' en créant un <code>ModuleManager</code> puis en le donnant au constructeur du <code>Robot</code> :</li>
</ul>
<pre><code class="language-cpp">// Création du module manager qui va héberger les modules
auto m = std::make_shared&lt;PhysicalRobot::ModuleManager&gt;();

// Ajout d'un module &quot;Servos&quot; avec deux servomoteurs
auto&amp; servos = m-&gt;add_module&lt;PhysicalRobot::Servos&gt;(2);
servos.add_servo(5, 120_deg);
servos.add_servo(6, 50_deg, PhysicalRobot::Servos::BlockingMode::HOLD_ON_BLOCKING);

// Création d'un robot à partir du ModuleManager précédemment instancié
// Le deuxième argument est une liste de paramètres permettant d'initialiser la connexion au robot
// Ici on aura une connexion de type &quot;PIPES&quot;
PhysicalRobot::Robot robot(m, {&quot;prog&quot;, &quot;PIPES&quot;});
</code></pre>
<ul>
<li>Utilisation du fichier <code>src/robot.ini</code> dans lequel on peut définir en-dehors du programme les variables d'initialisation pour n'importe quel robot (<code>primary</code>, <code>secondary</code>, <code>adversary</code>, <code>best_robot_of_the_world</code>...). Un robot initialisé à partir d'un <code>ModuleManager</code> se nomme <code>guest</code>, donc le nom est réservé :smile:</li>
</ul>
<pre><code class="language-ini">[robot.primary]
position_x=250        ; mm
position_y=1500       ; mm
size_x=300            ; mm
size_y=300            ; mm
size_z=420            ; mm
angle=-90             ; deg

[robot.primary.modules]
moving=1
servos=2
motors=3
avoidance=4
io=5
</code></pre>
<hr />
<p>Il est donc très facile de créer une instance qui possède à la fois l'architecture électronique et qui s'occupe de la communication.</p>
<p>Je te laisse te reporter aux différents tests pour avoir des exemples de comment l'utiliser (pour tester les servos par exemple) ; les robots complets utilisés pendant les matches sont utilisés dans la <code>Strategy</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-du-simulateur"><a class="header" href="#architecture-du-simulateur">Architecture du simulateur</a></h1>
<p>Le simulateur est fait pour être modulaire, c'est à dire que l'on peut passer d'une solution graphique à une autre et on peut rajouter des modules pour le robot facilement.</p>
<p>Il y a 5 composantes principales :</p>
<ul>
<li>La  <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/physique/"><code>physique/</code></a> permet de simuler le comportement de tous les objets physiquement
en prenant en compte les collisions, les déplacements etc. Pour ce faire, on utilise la librairie <a href="http://box2d.org/">Box2D</a>, un moteur physique.</li>
<li>Le  <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/graphique/"><code>graphique/</code></a> permet d'afficher tous les objets de la table dans un environnement
3D avec la possibilité de s'y déplacer, de zoomer ... Ici encore, on utilise une librairie, <a href="http://irrlicht.sourceforge.net/">Irrlicht</a>, en tant que moteur graphique.</li>
<li>La <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/gui/"><code>gui/</code></a> gère l'interface utilisateur, affiche des informations utiles (telles que l'état
du robot par exemple) et permet de piloter le simulateur.</li>
<li>La <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/communication/"><code>communication/</code></a> permets de simuler le comportement des cartes électroniques.
On peut donc utiliser la même stratégie en réel et sur le simulateur qui demande au robot d'<code>avancer</code> de 10 cm par exemple, et l'application va simuler les actions.</li>
<li>Le <a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/core/"><code>core/</code></a> permets enfin de tout coordonner pour avoir un simulateur fonctionnel.</li>
</ul>
<h2 id="coeur"><a class="header" href="#coeur">Coeur</a></h2>
<p>Le simulateur est entièrement controllé par la classe <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/core/Simulateur.h"><code>Simulateur</code></a>.
Cette classe est instanciée directement dans le <code>main</code> et contrôle les différents modules. Elle contient des méthodes pour initialiser le simulateur, 
reset la table, ajouter des robots à la simulation, et terminer proprement une session.</p>
<p>La classe <code>Simulateur</code> contient une instance de <code>World</code>.</p>
<h2 id="communication"><a class="header" href="#communication">Communication</a></h2>
<p>La communication du simulateur fonctionne en mirroir de celle de l'IA. Le code a donc plus ou moins la même structure : plusieurs modules, rassemblés dans un <code>ModuleManager</code>,
et un communicator pour gérer l'envoi des trames.</p>
<p>Le simulateur implémente ses propres modules spécifiques, qui jouent le rôle des cartes dans le robot réel. Ces modules fonctionnent exactement sur le même principe que les
modules côté IA : ils reçoivent des trames, les lisent, effectuent des actions et envoient de nouvelles trames en réponse.</p>
<p>Le simulateur jouant le rôle des cartes du robot, il envoit une trame seulement en réponse à une trame de la partie informatique. Ce comportement est implémenté dans la méthode
<code>communicationThread()</code> du <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/communication/SimuCommunicator.cpp"><code>SimuCommunicator</code></a>.</p>
<h2 id="partie-physique"><a class="header" href="#partie-physique">Partie physique</a></h2>
<p>L'API de la partie physique est constituées de deux interfaces :
<a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/physique/IPhysicalContext.h"><code>IPhysicalContext</code></a>, qui permet de créer des objets dans le moteur physique
et <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/physique/IPhysicalInstance.h"><code>IPhysicalInstance</code></a>, qui permet de gérer un objet physique en
particulier.</p>
<p>Le coeur du simulateur ne manipule que ces interfaces, et n'a pas besoin de savoir comment c'est implémenté derrière. L'utilisation d'interfaces de cette manière permet le
<strong>découplage</strong> des différentes parties du simulateur. Pour plus d'information sur le couplage des composants logiciels d'une application, voici un lien vers
<a href="https://fr.wikipedia.org/wiki/Couplage_(informatique)">la page Wikipedia</a></p>
<h3 id="implémentation"><a class="header" href="#implémentation">Implémentation</a></h3>
<p>L'implementation du moteur physique du simulateur est réalisée à l'aide du moteur physique <a href="https://box2d.org/">Box2D</a>. Elle se situe dans le dossier
<a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/physique/box2D/"><code>physique/box2D/</code></a>.</p>
<p>Il y a quelques années, le simulateur utilisait un moteur physique en 3D. Même si les simulations étaient plus réalistes, il était difficile de configurer l'environnement
pour que le robot se comporte comme en vrai. C'est pourquoi nous sommes passés à un moteur en 2D.</p>
<h2 id="partie-graphique"><a class="header" href="#partie-graphique">Partie graphique</a></h2>
<p>De même que la partie physique, la partie graphique du simulateur est manipulée via deux interfaces, 
<a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/graphique/IGraphicalContext.h"><code>IGraphicalContext</code></a> pour créer les objets 3D de l'affichage
et <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/graphique/IGraphicalInstance.h"><code>IGraphicalInstance</code></a> pour modifier les propriétés d'un
objet en particulier.</p>
<h3 id="implémentation-1"><a class="header" href="#implémentation-1">Implémentation</a></h3>
<p>Nous utilisons <a href="http://irrlicht.sourceforge.net/">Irrlicht</a> pour l'implémentation de l'affichage graphique de la simulation. Celle-ci se trouve dans le dossier
<a href="https://github.com/ClubRobotInsat/info/tree/develop/src/simulateur/graphique/irrlicht/"><code>graphique/irrlicht/</code></a>.</p>
<h2 id="interface-utilisateur-gui"><a class="header" href="#interface-utilisateur-gui">Interface utilisateur (GUI)</a></h2>
<p>Pour pouvoir interagir avec le simulateur, il faut des boutons, des champs de texte, etc. Ces fonctionnalités sont assez différentes de l'affichage 3D du simulateur.
De plus, Irrlicht ne nous permet pas de rajouter facilement des éléments d'UI (User Interface) à l'affichage 3D. La GUI est donc un module séparé de l'affichage 3D.
Le coeur du simulateur interagit avec ce module à travers l'interface <a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/gui/IGuiContext.h"><code>IGuiContext</code></a>.</p>
<p>Le module doit aussi transmettre les ordres de l'utilisateur au simulateur. Pour se faire, il reçoit lors de son initialisation un objet de type 
<a href="https://github.com/ClubRobotInsat/info/blob/develop/src/simulateur/gui/IGuiClient.h"><code>IGuiClient</code></a>, qui possède des méthodes permettant d'éxecuter des actions
sur le simulateur.</p>
<h3 id="implémentation-2"><a class="header" href="#implémentation-2">Implémentation</a></h3>
<p>La librarie utilisée pour la GUI se nomme <a href="https://www.gtkmm.org/en/">Gtkmm</a>. C'est un port C++ de la librairie C <em>Gtk</em> utilisée dans de nombreuses programmes comportant
une interface graphique. Vous pourrez trouver une doc très détaillée de Gtkmm
<a href="https://developer.gnome.org/gtkmm-tutorial/unstable/gtkmm-tutorial.html">ici</a>.</p>
<p>La GUI se compose actuellement d'une fenêtre comportant plusieurs panneaux. Les panneaux sont créés avec <a href="https://glade.gnome.org/">Glade</a>. Ils sont sauvegardés dans
le dossier <code>gui/gtk/glade/</code> sous forme de fichiers <code>.glade</code>. A la création de la fenêtre, le simulateur charge ces différents panneaux et les ajoute à la fenêtre
principale. Comme ça le placement des composants est déjà fait, il ne reste plus qu'à écrire le code qui exécute l'action demandée par l'utilisateur.</p>
<p>Les différentes classes qui gèrent les panneaux ont toutes un nom de la forme <code>Panel[Nom du panneau].h/.cpp</code>. Le <code>PanelConnect</code> est un bon exemple si vous voulez implémenter
votre propre panneau !</p>
<h2 id="complément-sur-le-couplage-"><a class="header" href="#complément-sur-le-couplage-">Complément sur le couplage :)</a></h2>
<pre><code>Section à rédiger
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Électronique-logicielle"><a class="header" href="#Électronique-logicielle">Électronique Logicielle</a></h1>
<p>L’électronique logicielle (ou <em>elec soft</em> pour les intimes) consiste à concevoir le fonctionnement logiciel d'un microcontrôleur et de ses périphériques.</p>
<p>Le but des cartes électroniques est de fournir à la partie informatique du robot un moyen simple d'envoyer des commandes aux différents actionneurs et de lire les différents capteurs. Pour certains types de composants c'est assez simple (les composants binaires comme les LEDs ou les vannes) et pour d'autres cela implique plus de travail (servomoteurs numériques, moteurs à courant continu).</p>
<p>La carte électronique va donc avoir un rôle d’intermédiaire entre l'ordinateur embarqué et le monde physique du robot. Normalement, si tout va bien durant l'année, un circuit imprimé a été réalisé afin que le microcontrôleur puisse parler avec les actionneurs/capteurs.</p>
<p>Il suffit donc de programmer le microcontrôleur pour qu'il envoie les bons signaux quand on lui demande !</p>
<h1 id="plus-de-documentation"><a class="header" href="#plus-de-documentation">Plus de documentation</a></h1>
<p>Tu veux encore plus de documentation ? Ta soif de savoir ne s'étanche pas ? Tu cherches le détail du fonctionnement du module UART du microcontrôleur stm32f103 ? Tu n'arrive pas à savoir si l’adresse <code>0x4000400C</code> est un Timer ou un I2C ? Tu cherches le layout du W5500 ? Tu veut comprendre les arcanes de l'elec ? Toutes ces informations se trouvent dans l'archive compilée par mes soins, <a href="elec_soft/../images/elec_soft/DOC.tar.gz">ici</a></p>
<p>Inclu notamment :</p>
<ul>
<li>ref du stm32f103</li>
<li>ref du stm32f446</li>
<li>ref du tcs3200</li>
<li>ref des drs0101</li>
<li>ref des ponts h</li>
<li>ref du w5500</li>
</ul>
<p>(liste non contractuelle)</p>
<p><a href="elec_soft/../images/elec_soft/DOC.tar.gz">Archive</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organisation--architecture"><a class="header" href="#organisation--architecture">Organisation &amp; Architecture</a></h1>
<p>Le code est séparée en deux : les fonctionnalités partagées entre les cartes sont dans <a href="https://github.com/ClubRobotInsat/librobot">librobot</a> et chaque carte est implémentée dans le repo git <code>firmware-&lt;fonctionnalité&gt;</code>.</p>
<p>Il y a actuellement (après la coupe de 2019), 4 cartes:</p>
<ul>
<li><a href="https://github.com/ClubRobotInsat/firmware-navigation"><code>firmware-navigation</code></a></li>
<li><a href="https://github.com/ClubRobotInsat/firmware-servos"><code>firmware-servos</code></a></li>
<li><a href="https://github.com/ClubRobotInsat/firmware-io/"><code>firmware-io</code></a></li>
<li><a href="https://github.com/ClubRobotInsat/firmware-io-secondary"><code>firmware-io-secondary</code></a></li>
</ul>
<h2 id="librobot"><a class="header" href="#librobot">Librobot</a></h2>
<p>Cette librairie a été introduite afin de réutiliser du code entre les cartes.
Un effet sympathique de cette librairie c'est qu'il possible d'y écrire des <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">tests unitaires</a>.</p>
<p>La documentation de la librairie est regénérée par <a href="https://fr.wikipedia.org/wiki/Travis_CI">Travis</a> (script <a href="https://github.com/ClubRobotInsat/librobot/blob/master/.travis.yml">ici</a>) à chaque commit et se trouve <a href="https://clubrobotinsat.github.io/librobot/librobot/">ici</a>.</p>
<h2 id="cartes"><a class="header" href="#cartes">Cartes</a></h2>
<p>Chaque carte est structurée de la même façon. Voici le contenu de <code>firmware-navigation</code> pour le commit <code>c86b1a0cd1d5da5030a1fac55fae41ac4cf591d7</code> :</p>
<pre><code>├── black_pill.cfg
├── Cargo.lock
├── Cargo.toml
├── debug.sh
├── interfaces
│  ├── stlink-v2-1.cfg
│  └── stm32f1x.cfg
├── memory.x
├── README.md
├── src
│  ├── main.rs
│  ├── robot.rs
│  └── variables.rs
└── target
   ├── debug
   │  ├── build
   │  ├── deps
   │  ├── examples
   │  ├── incremental
   │  └── native
   ├── release
   │  ├── build
   │  ├── deps
   │  ├── examples
   │  ├── incremental
   │  └── native
   └── thumbv7m-none-eabi
      ├── debug
      └── release

</code></pre>
<p>Les fichiers <code>Cargo.toml</code> et <code>Cargo.lock</code> listent les dépendances du projet. Il faut noter que <code>Cargo.lock</code> est suivi par git, comme ça tout le monde compile les mêmes versions des librairies (c'est très important pour tout le monde ai le même code !).</p>
<p>Le fichier <code>black_pill.cg</code> et ceux présents dans <code>interfaces</code> sont les fichiers de configuration de OpenOCD afin de flasher la carte.</p>
<p>Le fichier <code>debug.sh</code> invoque <code>gdb</code> aves les bons arguments pour se connecter à OpenOCD et flasher la carte.</p>
<p>Le fichiers <code>memory.x</code> décrit l'organisation de la mémoire du microcontrolleur.</p>
<p>Le fichier <code>README.md</code> sers de documentation minimale pour la carte.</p>
<p>Dans le dossier <code>src</code> on trouve :
* <code>main.rs</code> : contiens la logique de la fonction main
* <code>robot.rs</code> : contiens l'initialisation du microcontrolleur et de ses périphériques</p>
<p>Enfin, le dernier dossier qui nous intérresse est le dossier <code>target/thumbv7m-none-eabi</code> qui contiens le résultat de la compilation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mise-en-place-1"><a class="header" href="#mise-en-place-1">Mise en place</a></h1>
<p>Dans cette section, nous allons installer pas à pas tous les outils pour pouvoir développer du code pour le robot.</p>
<p>Avant d'attaquer cette partie tu as installé avec succès :</p>
<ul>
<li><a href="elec_soft/mise_en_place/git.html">git</a></li>
<li><a href="elec_soft/mise_en_place/ide.html">CLion</a></li>
</ul>
<p>Nous allons donc commencer par installer un compilateur Rust, ainsi que des outils pour pouvoir flasher, déboguer et tester le code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation-1"><a class="header" href="#compilation-1">Compilation</a></h1>
<p>Dans cette section, tu vas faire le grand pas et mettre en place tous les outils pour bidouiller sur les cartes du club robot !</p>
<p>Attention, les instructions sont valables uniquement pour Linux, et sont à adaptées pour ceux qui ont des distributions Linux différentes de Ubuntu.</p>
<h1 id="outils-génériques"><a class="header" href="#outils-génériques">Outils génériques</a></h1>
<p>Tout d'abord il te faut installer les outils suivants :</p>
<ul>
<li><code>gdb-arm-none-eabi</code> : <code>gdb</code> est un débuggeur, tu installes ici la version pour l'architecture <code>arm</code> sans os (<code>none</code>). Tu trouveras plus d'informations sur gdb par <a href="https://fr.wikipedia.org/wiki/GNU_Debugger">ici</a>. Pour les notions d'architecture, tu peux toujours lire la page sur l'<a href="https://fr.wikipedia.org/wiki/Architecture_de_processeur">architecture matérielle</a> sur wikipédia.</li>
<li><code>gcc-arm-none-eabi</code> : <code>gcc</code> est un compilateur pour le langage C. Tu installes la version pour compiler vers l'architecture <code>arm</code> ici.</li>
<li><code>openocd</code> : cet outil permet de communiquer avec le microcontrôleur : c'est grâce à lui que l'on peut envoyer des exécutables dessus et les déboguer.</li>
</ul>
<p>Sur Ubuntu, cela se fait en exécutant les commandes suivantes dans un terminal :</p>
<pre><code class="language-bash">sudo apt update
sudo apt install git gdb-multiarch gdb-arm-none-eabi gcc-arm-none-eabi openocd
</code></pre>
<p>La première commande mets à jour les paquets disponibles, la deuxième les installe.</p>
<h2 id="customisation-de-gdb"><a class="header" href="#customisation-de-gdb">Customisation de gdb</a></h2>
<p>Bien que très puissant, gdb propose une interface d'un autre siècle. Je te propose de rendre cette interface plus agréable !</p>
<ol>
<li>On récupère un fichier tout fait qui rend l'interface de gdb supportable :
<pre><code class="language-bash">wget -P ~ git.io/.gdbinit
</code></pre>
</li>
<li>On autorise le chargement de ce fichier par gdb :
<pre><code class="language-bash">echo &quot;set auto-load safe-path /&quot; &gt;&gt; ~/.gdbinit
</code></pre>
</li>
</ol>
<h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>Pour installer Rust, tu peux te référer aux instructions sur <a href="https://rustup.rs">rustup.rs</a>. Les paramètres par défaut sont très bien.
Si tu as bien installé Rust, quand tu ouvres un nouveau terminal et que tu tapes :</p>
<pre><code class="language-bash">rustc --version
</code></pre>
<p>Il devrait s'afficher un texte qui ressemble à ça (tu auras certainement une version plus récente, là il s'agit de la version du 20 Mai 2019) :</p>
<pre><code class="language-bash">rustc 1.35.0 (3c235d560 2019-05-20)
</code></pre>
<h1 id="utilitaires"><a class="header" href="#utilitaires">Utilitaires</a></h1>
<p>Pour bidouiller plus efficacement, tu peux aussi installer quelques outils plutôt pratiques.</p>
<h2 id="obligatoire--rustfmt"><a class="header" href="#obligatoire--rustfmt">Obligatoire : rustfmt</a></h2>
<p>Dans un projet informatique, plusieurs personnes ont des conventions d'alignement du texte différent, différentes manières d'aller à la ligne dans les déclarations, etc. Si jamais tu t'ennuies, tu peux demander à un barbu si il préfère les tabulations ou les espaces pour indenter le code, flame ware garantie !
Dans le but d'uniformiser le code produit par tout le monde, on utilise un outil <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> qui va venir formater le code. Plus besoin de se prendre la tête avec l'indentation ou les retours à la ligne dans les gros appels de fonctions : on lance <code>rustfmt</code> et le code est formaté.</p>
<p>Cet outil est <strong>obligatoire</strong>, autrement ton installation ne fonctionnera pas. Pour l'installer il suffit de taper dans un terminal :</p>
<pre><code class="language-bash">rustup component add rustfmt-preview
</code></pre>
<h2 id="optionnel--cargo-edit"><a class="header" href="#optionnel--cargo-edit">Optionnel : cargo-edit</a></h2>
<p>L'outil <code>cargo-edit</code> permet d'ajouter facilement des librairies depuis la ligne de commande dans un projet. Pour plus d'informations tu peux aller lire la description de l'outil par <a href="https://crates.io/crates/cargo-edit">ici</a>.</p>
<pre><code class="language-bash">cargo install cargo-edit
</code></pre>
<h2 id="optionnel-cargo-clone"><a class="header" href="#optionnel-cargo-clone">Optionnel cargo-clone</a></h2>
<p>L'outil <code>cargo-clone</code> permet de récupérer le code source de n'importe quelle librairie disponible sur <a href="https://crates.io">crates.io</a> en une ligne de commande.</p>
<pre><code class="language-bash">cargo install cargo-clone
</code></pre>
<h1 id="erreurs-courantes"><a class="header" href="#erreurs-courantes">Erreurs courantes</a></h1>
<p>Quelques erreurs arrivent régulièrement et sont dû à une mauvaise configuration du compilateur. En particulier l'erreur : <code>error: linking with `cc` failed: exit code: 1</code> peut être résolue ainsi :
On installe gdb-multilib : <code>sudo apt install gcc-multilib</code>.
Si l'erreur n'est pas résolue, on vérifie que l'on a choisi le bon compilateur : <code>sudo update-alternatives --config gcc</code> et choisir gcc-8.</p>
<pre><code class="language-bash">expected struct heapless::string::String, found a different struct heapless::string::String
</code></pre>
<p>La version de librobot utilisée n'est pas la bonne, il faut choisir la branch &quot;master&quot; (et non &quot;dev-new-pid&quot;) :</p>
<pre><code class="language-bash">nano Cargo.toml
librobot = {git=&quot;https://github.com/ClubRobotInsat/librobot&quot;, default-features=false}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="répertoire-de-travail-1"><a class="header" href="#répertoire-de-travail-1">Répertoire de travail</a></h1>
<p>Maintenant ouvrons le projet du club robot avec CLion et vérifions que tout fonctionne.</p>
<p>Pour commencer, si tu n'as jamais entendu parler de <code>git</code> ou que tu ne te sens pas très à l'aide avec, tu peux revenir un peu en arrière et lire <a href="elec_soft/mise_en_place/outils_communs/git.html">ceci</a>.</p>
<p>On va compiler le code de la carte servomoteurs.</p>
<h1 id="récupérer-le-code-de-la-librairie"><a class="header" href="#récupérer-le-code-de-la-librairie">Récupérer le code de la librairie</a></h1>
<p>Pour récupérer le code, je te suggère de commencer par te créer un dossier qui contiendra tous les répertoires du club robot (si ce n'est pas déjà fait).
Une fois placé dans ce dossier, tu peux exécuter la commande :</p>
<pre><code class="language-bash">git clone https://github.com/ClubRobotInsat/librobot
</code></pre>
<p>Cette commande va venir demander à <code>git</code> d'aller récupérer la dernière version du code disponible sur <a href="https://github.com/ClubRobotInsat/librobot">github</a> pour la librairie du club robot.</p>
<p>Un nouveau dossier <code>librobot</code> a du apparaître.</p>
<h1 id="récupérer-le-code-de-la-carte-électronique"><a class="header" href="#récupérer-le-code-de-la-carte-électronique">Récupérer le code de la carte électronique</a></h1>
<p>De même, il faut cloner un répertoire sur github pour avoir le code de la carte électronique :</p>
<pre><code class="language-bash">git clone https://github.com/ClubRobotINSAT/firmware-servos
</code></pre>
<p>Il y a quelques étapes de configuration à faire avant de compiler :</p>
<ol>
<li>
<p>Il faut rajouter la cible <code>thumbv7m-none-eabi</code> avec rustup</p>
<pre><code class="language-bash">cd firmware-servos
rustup target add thumbv7m-none-eabi
</code></pre>
</li>
<li>
<p>Il faut vérifier que le projet compile bien :</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
</li>
</ol>
<p>Explication :</p>
<ul>
<li>
<p><code>thumbv7m</code> : jeu d'instruction ARMv7, il s'agit du jeu d'instruction du Cortex M4</p>
</li>
<li>
<p><code>none</code> : pas de système d'exploitation sur la carte électronique</p>
</li>
<li>
<p><code>eabi</code> : on aurait pu avoir l'option <code>hf</code> qui signifie &quot;hard float&quot;, c'est à dire que le compilateur va émettre des instructions spéciales pour les calculs sur les nombres flottants au lieu de les calculer avec des entiers. En effet, certains microcontrôleurs embarquent un Floating Point Unit (FPU) qui permet de faire des calculs flottants rapidement. Cependant sur la black-pill il y a un <code>stm32f103</code> qui n'a pas de FPU on ne met donc pas cette option.</p>
</li>
</ul>
<p>Si la compilation a marché alors tout a été installé correctement !</p>
<h1 id="arborescence-du-code-et-fichiers-remarquables"><a class="header" href="#arborescence-du-code-et-fichiers-remarquables">Arborescence du code et fichiers remarquables</a></h1>
<p>Pour comprendre les différents fichiers présents dans le dossier du projet, tu peux revenir en arrière et lire <a href="elec_soft/mise_en_place/../organisation/index.html">Organisation du code</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide-2"><a class="header" href="#ide-2">IDE</a></h1>
<p>Normalement tu as suivi les instructions de la section <a href="elec_soft/mise_en_place//outils_communs/ide.html">Outils Communs - IDE</a>, tu as donc une installation de CLion fonctionnelle.</p>
<p>Si ce n'est pas le cas, reviens un petit peu en arrière et installe CLion !</p>
<h2 id="installation-du-plugin-pour-rust"><a class="header" href="#installation-du-plugin-pour-rust">Installation du plugin pour Rust</a></h2>
<p>En électronique logicielle, nous utilisons le langage <strong>Rust</strong>. Tu en entendras parler un peu plus loin dans la documentation. En attendant il faut installer un plugin pour supporter le langage dans CLion.</p>
<p>Il faut commencer par ouvrir les options de CLion <code>File&gt;Settings</code> ou encore <code>ctrl+alt+s</code>.</p>
<p>Dans le menu <code>Plugins</code> tu cliques sur <code>Install Jetbrains Plugins</code> et tu cherches <code>Rust</code> dans la fenêtre qui s'est ouverte. Pour lancer l'installation, il suffit de cliquer sur <code>Install</code>.</p>
<p>Normalement il devrait être possible de compiler, sinon tu peut aller voir dans <code>Settings &gt; Languages &amp; Frameworks &gt; Rust</code> si tout a été bien détecté et cliqué sur <code>download stdlib with rustup</code> si cela t'es proposé.</p>
<p><img src="elec_soft/mise_en_place//images/ide/plugin_install.png" alt="Installation du plugin pour Rust" title="Plugin pour Rust" /></p>
<h2 id="vérification-de-linstallation"><a class="header" href="#vérification-de-linstallation">Vérification de l'installation</a></h2>
<p>Si il n'y a pas de messages d'erreur, <em><strong>BRAVO</strong></em> tu viens d'installer avec succès le plugin Rust pour CLion !</p>
<h1 id="compilation-dun-projet"><a class="header" href="#compilation-dun-projet">Compilation d'un projet</a></h1>
<p>Maintenant c'est la dernière étape, le grand moment : nous allons compiler un projet.</p>
<p>C'est le moment de lancer CLion ! Une fois lancé, dans <code>File &gt; Open</code> choisi le dossier de <code>black-pill</code>.</p>
<p>Si tout se passe bien, tu devrais pouvoir compiler, tester et formater le code. Pour cela, il faut choisir la configuration adéquate, en haut à droite de ton interface et appuyer sur le bouton <code>run</code>.</p>
<p>Si la compilation fonctionne, tu peux passer à la suite c'est tout bon tu as tout installé avec succès !</p>
<h2 id="compilation-à-la-mano"><a class="header" href="#compilation-à-la-mano">Compilation à la mano</a></h2>
<p>Tu peux aussi compiler à la main (pratique parfois).</p>
<p>Pour cela, une fois à la racine du projet, exécute :</p>
<pre><code>cargo build --release --features = &quot;primary&quot; 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pour-flasher-une-carte"><a class="header" href="#pour-flasher-une-carte">Pour flasher une carte</a></h1>
<p>Commences par câbles un ST-LINK sur la carte. Sur l'image c'est une blue-pill, mais l'ordre des pins et le câblage est le même !</p>
<p><img src="elec_soft/mise_en_place/../../images/elec_soft/F103C8T6_w_ST-Link.jpg" alt="test" />
Une fois câblé, lances OpenOCD à la racine du projet :</p>
<pre><code>sudo openocd -f black_pill.cfg
</code></pre>
<p>Si le ST-LINK a été bien câblé, alors OpenOCD devrait rester ouvert en tache de fond.</p>
<p>Une fois openocd en tâche de fond, il suffit de lancer dans un terminal le script <code>debug.sh</code> qui se trouve dans le dossier du projet pour flasher la carte.</p>
<h2 id="precautions-pour-le-deboggage"><a class="header" href="#precautions-pour-le-deboggage">Precautions pour le deboggage</a></h2>
<ul>
<li>Ne pas poser de cartes non vernies directement sur l'armature métallique du robot, cela peut créer des court-circuits dans la carte et l'endommager !</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apprendre-rust"><a class="header" href="#apprendre-rust">Apprendre Rust</a></h1>
<p>Pour apprendre Rust, en parallèle avec la formation le mieux reste de lire <a href="https://doc.rust-lang.org/book/second-edition/">The Rust Book</a> (deuxième édition). Il s'agit du meilleur moyen d'apprendre le langage, mais ce n'est pas le seul.</p>
<p>Voici une liste de ressources non exhaustive qui te servira peut être un jour :</p>
<ul>
<li><a href="https://rust-embedded.github.io/book/">The Embedded Rust Book</a> : Un bouquin expliquant comment fonctionne l'embarqué et la programmation sur microcontrôleur en Rust. <strong>Très bonne lecture</strong> :)</li>
<li><a href="http://rustbyexample.com/">Rust by example</a> : Une collection d'exemples permettant de comprendre les concepts du langage, très bonne lecture en complément de <em>The Rust Book</em>.</li>
<li><a href="https://doc.rust-lang.org/book/">The Rust Book v1</a> : A lire si le chapitre que tu cherches n'est pas dans la v2. Le livre n'est pas obsolète, mais il est moins bien que la v2.</li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">The Cookboook</a> : Un livre de <em>recettes</em> pour des opérations classiques.</li>
<li><a href="https://doc.rust-lang.org/std/">La documentation de la librairie standard</a> : La référence de toutes les fonctions/structures/traits/méthodes de la librairie standard.</li>
</ul>
<p>Il existe aussi une série de posts de blogs, c'est toujours pratique pour apprendre surtout quand c'est en Français :</p>
<ul>
<li><a href="http://blog.guillaume-gomez.fr/Rust">Tutoriel Rust</a> - Guillaume Gomez</li>
<li><a href="https://levans.fr/borrowing-and-lifetimes-in-rust-fr.html">Les emprunts et les durées de vies en Rust</a> - Victor Berger</li>
<li><a href="https://github.com/Songbird0/Rust_FAQ">Retrouvez un grand nombre de Questions/Réponses dans cette FAQ dédiée à rust !</a> - Anthony Defranceschi/Songbird0</li>
<li><a href="https://github.com/Songbird0/FR_RBE">Traduction française du livre Rust by example</a> - Anthony Defranceschi/Songbird0</li>
</ul>
<p>Enfin il y a une <a href="https://github.com/ctjhoa/rust-learning">page github</a> qui recense encore plus de ressources que tu peux toujours consulter.</p>
<p>Pour la programmation embarquée il y a aussi de la documentation, la plupart est recensée sur <a href="https://github.com/rust-embedded/awesome-embedded-rust">awesome-embedded</a>.</p>
<p>Il y enfin quelques posts de blogs bien pratiques, ainsi que de la documentation de certaines librairies :</p>
<ul>
<li><a href="https://japaric.github.io/discovery/">Une série de post d'introduction sur un stm32discovery</a> - Japaric</li>
<li><a href="http://blog.japaric.io/quickstart/">Un post qui date des débuts de Rust sur microcontrolleur</a> - Japaric</li>
<li><a href="http://blog.japaric.io/fearless-concurrency/">Introduction au framework RTFM</a> - Japaric</li>
<li><a href="http://blog.japaric.io/rtfm-v2/">Evolution du framework RTFM</a> - Japaric</li>
<li><a href="https://docs.rs/cortex-m-quickstart/0.3.1/cortex_m_quickstart/">La description de la librairie <code>cortex-m-quickstart</code></a></li>
<li><a href="https://docs.rs/embedded-hal/0.2.1/embedded_hal/">La description de la librairie <code>embedded-hal</code></a></li>
</ul>
<h1 id="aide"><a class="header" href="#aide">Aide</a></h1>
<p>Tu as besoin d'aide ?
Le meilleur moyen de résoudre ton problème est d'aller sur le chan <strong>#rust-beginners</strong> sur le <a href="elec_soft/irc.mozilla.org">serveur IRC</a> de Mozilla.
Si tu n'as pas de client IRC, tu peux aussi passer par une <a href="https://client00.chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust-beginners">interface web</a>.</p>
<p>Pour des questions plus complexes, tu peux aussi poster sur <a href="https://www.reddit.com/">reddit</a> ou demander aux gens du club ! :wink:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communication-des-modules-avec-linformatique"><a class="header" href="#communication-des-modules-avec-linformatique">Communication des modules avec l'informatique</a></h1>
<p>L'informatique et l'électronique doivent se mettre d'accord sur les trames envoyées pour communiquer.</p>
<p>Un réseau RJ45 est déployé dans le robot et chaque carte possède sa propre IP en <code>192.168.1.ID_CARTE</code> si il s'agit du robot primaire ou en <code>192.168.2.ID_CARTE</code> si il s'agit du robot secondaire.</p>
<p>Le PC embarqué possède une adresse au même format (192.168.X.254). Typiquement, la carte déplacement du second robot possède l'adresse 192.168.2.1.</p>
<p>L'informatique s’attend à recevoir les informations de la carte <code>ID_CARTE</code> sur le port 5000 + ID_CARTE. Cette même carte écoute sur le port 50 + ID_CARTE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="electronique-matérielle"><a class="header" href="#electronique-matérielle">Electronique matérielle</a></h1>
<p>Cette section est réservée à l'électronique matérielle au club robot. Ici tu apprendras le nécessaire pour atteindre le but ultime de tout électronicien au club : produire des cartes électroniques qui</p>
<ul>
<li>Ne prennent pas feu</li>
<li>Actionnent des moteurs </li>
<li>Exploitent des mesures de capteurs</li>
</ul>
<p>Les trois ressources principales en plus de cette doc sont : </p>
<ol>
<li><a href="https://openclassrooms.com/fr/courses/724810-lelectronique-de-zero">Openclassrooms</a> : Tu y trouveras un cours d'électronique générale, plutôt clair. C'est un très bon point de départ avant de se plonger dans le robot.</li>
<li>Le <a href="http://www.falstad.com/circuit/">simulateur de circuit Falstad</a> : Rapide à prendre en main pour simuler et mieux comprendre des circuits usuel. Je te recommande <strong>tres</strong> fortement d'y faire un tour rapide maintenant pour voir ce que tu peux faire avec. Son alternative professionelle est LTSpice.</li>
<li>La <a href="https://archipel-univtoulouse.hosted.exlibrisgroup.com/primo-explore/fulldisplay?docid=33TOUL_ALMA21413566170004116&amp;context=L&amp;vid=33INSA_VU1&amp;lang=fr_FR&amp;search_scope=default_scope&amp;adaptor=Local%20Search%20Engine&amp;isFrbr=true&amp;tab=default_tab&amp;query=any,contains,Syst%C3%A8mes%20%C3%A9lectroniques%20analogiques%20Amplification%20%20Filtrage%20et%20optronique&amp;sortby=date&amp;facet=frbrgroupid,include,102068340&amp;mode=Basic&amp;offset=0">Bible</a>, rédigée par nos professeurs d'électronique favoris. C'est une très bonne référence quand tu as envie d'en savoir plus sur un détail qui n'est pas assez ou mal expliqué en cours ou sur openclassrooms. Un exemplaire est disponible en lecture au Club, et il est facile à trouver dans nos BUs (cf. lien ci-dessus).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mise-en-place-2"><a class="header" href="#mise-en-place-2">Mise en place</a></h1>
<p>Installons les logiciels pour router des cartes éléctroniques ! Au club robot nous utilisons <a href="https://en.wikipedia.org/wiki/KiCad">KiCad</a>. Certains d'entre vous connaissent peut être Eagle mais la version Linux de ce dernier n'est pas au point du tout. De plus c'est un logiciel payant (on peut certes avoir des licenses étudiantes) alors que KiCad est un logiciel libre.</p>
<h1 id="installation-de-kicad"><a class="header" href="#installation-de-kicad">Installation de Kicad</a></h1>
<p>Tu peux installer KiCad sur les trois principaux OS : Ubuntu, Windows et OSX. Il faut faire attention à bien installer la version 5 !</p>
<p>Pour les autres distributions Linux demande directement aux gens du club !</p>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<h3 id="ubuntu"><a class="header" href="#ubuntu">Ubuntu</a></h3>
<p>Il suffit de rentrer les trois commandes suivantes pour obtenir la dernière version de Kicad (Kicad 5) :</p>
<p>** A Verifier **</p>
<pre><code class="language-bash">sudo add-apt-repository --yes ppa:js-reynaud/kicad-5
sudo apt update
sudo apt install kicad
</code></pre>
<p>Ces commandes sont nécessaires car on utilise la version 5 de Kicad qui est encore en beta.</p>
<p>Tu peux vérifier que l'installation a bien fonctionné en lançant Kicad. Normalement KiCad est livré avec des librairies de composants. Si elles ne sont pas installées chez toi, rapproche-toi d'un membre du club !</p>
<h3 id="osx"><a class="header" href="#osx">OSX</a></h3>
<p>Il existe deux méthodes pour installer Kicad sur un Mac. La classique en allant sur http://kicad-pcb.org/download/osx/, puis en telechargeant la dernière version stable, ou avec Homebrew.</p>
<p>Homebrew et fonctionne à peu près comme aptitude sur Linux. C'est un très bon outil qui permet d'installer facilement beaucoup d'applications disponibles sur Linux mais pas nativement sur mac (comme wget par exemple). Je profite juste de l'installation de Kicad pour présenter cet outil très utile.
N'hésite pas à faire un tour sur leur site pour en savoir plus, je ne parlerai ici que du nécéssaire pour installer Kicad. </p>
<p>https://brew.sh/index_fr</p>
<p>Pour installer homebrew, il suffit d'executer cette ligne dans un terminal :</p>
<pre><code class="language-bash">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>Cette ligne télécharge et éxécute l'installeur pour Brew. Laisse-toi guider, il décrit ce qu'il fait au fur et a mesure de l'installation.</p>
<p>Une fois l'install terminée, il faut installer une extension de Brew appellée 'cask'. Elle permet d'installer proprement des applicaitons en passant par le téléchargement et la vérification du .app. </p>
<pre><code class="language-bash">brew install cask
</code></pre>
<p>Tout est prêt ! Il ne reste plus qu'à installer la dernière version de Kicad. Attention le téléchargement est lourd (3GB environ).</p>
<pre><code class="language-bash">brew cask install kicad
</code></pre>
<p>Kicad est désormais correctement installé sur ton ordinateur et peut s'utiliser comme n'importe quelle autre application.
Il est recommandé d'installer ses apps avec Homebrew autant que possible. Pour savoir si une app est disponible sur leurs dépôts, utilise </p>
<pre><code class="language-bash">brew search [nom à rechercher]
</code></pre>
<p>Si brew trouve des résultats, un simple  <code>brew install [nom trouvé]</code> se chargera de l'installation.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Il suffit de récupérer et lancer l'installeur le plus récent parmis tout ceux proposés sur <a href="http://downloads.kicad-pcb.org/windows/nightly/">cette</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organisation"><a class="header" href="#organisation">Organisation</a></h1>
<h2 id="organisation-des-dossiers"><a class="header" href="#organisation-des-dossiers">Organisation des dossiers</a></h2>
<p>Voici une arborescence typique d'un dossier de travail en cours d'année :</p>
<pre><code>hardware
├── boards
│   ├── pump_2019_f103
│   └── servo_2019_f103
├── digikey-kicad-library
│   ├── digikey-footprints.pretty
│   ├── digikey-symbols
│   └── src
└── libkicad-robot
    ├── @Robot_symbols 
    ├── @Robot.3D
    ├── @Robot.pretty
    ├── datasheets
    ├── projets communs
    └── libeagle-robot

</code></pre>
<p>On y retrouve 3 dossiers :</p>
<ul>
<li>les cartes en cours de travail (le dossier <code>boards</code>)</li>
<li>la librairie du club (le dossier <code>kicad</code>)</li>
<li>la librairie de digikey (le dossier <code>digikey-kicad-library</code>)</li>
</ul>
<h3 id="dossier-boards"><a class="header" href="#dossier-boards">Dossier <code>boards</code></a></h3>
<p>Dans ce dossier, il y a pour chaque carte un dossier avec comme nom <code>&lt;fonction&gt;_&lt;année de la coupe&gt;_&lt;µc&gt;</code> écrit en <a href="https://fr.wikipedia.org/wiki/Snake_case">snake_case</a>. Dans le dossier de la carte on retrouve :</p>
<ul>
<li>le projet kicad, un fichier <code>.pro</code></li>
<li>le schematic de la carte, un fichier <code>.sch</code></li>
<li>le routage de la carte, un fichier <code>.pcb</code>
NB : la liste des cartes est accessible dans les references de ce chapitre.</li>
</ul>
<h3 id="dossier-libkicad-robot"><a class="header" href="#dossier-libkicad-robot">Dossier <code>libkicad-robot</code></a></h3>
<p>On retrouve 6 dossiers importants dans celui-ci :</p>
<ul>
<li>Trois dossiers <code>@Robot</code> : les librairies de composants propres au Club </li>
<li><code>datasheets</code> : les datasheets des composants du club et autres documents importants </li>
<li><code>projets communs</code> :  des cartes et des blocs élémentaires qui servent de base aux projets </li>
<li><code>libeagle-robot</code> : les anciennes librairies du Club</li>
</ul>
<h2 id="organisation-des-projets-git"><a class="header" href="#organisation-des-projets-git">Organisation des projets git</a></h2>
<p>Chaque carte a un projet git unique afin de découpler totalement les cartes du la librairie de symbole.</p>
<p>On peut ainsi utiliser l'onglet <strong>release</strong> pour uploader les typons, le plan d'implantation et le <em>bill of materials</em> afin de pouvoir retrouver toutes ces informations un jour.</p>
<p>L'onglet <strong>issue</strong> du repo sers à suivre les problèmes et les choses à faire sur la carte.</p>
<p>L'onglet <strong>projet</strong> permet de suivre l'avancement de la carte.</p>
<p>Par exemple pour la carte <a href="https://github.com/ClubRobotInsat/deplacement_2019_f103">deplacement_2019_f103</a> dans l'onglet <a href="https://github.com/ClubRobotInsat/deplacement_2019_f103/issues">issues</a> on retrouve les tâches à faire (si elles n'ont pas été toutes faîtes).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-de-la-librairie-et-des-projets-du-club-robot"><a class="header" href="#installation-de-la-librairie-et-des-projets-du-club-robot">Installation de la librairie et des projets du Club Robot</a></h1>
<p>Pour obtenir les composants du club afin de pouvoir ouvrir correctement les cartes que nous avons réalisée par le passé, il suffit de te préparer un dossier conforme à l'arborescence décrite dans la page précédente. Pour cela, il faut ouvrir un terminal, te placer là ou tu souhaites tout installer, et entrer ces commandes : </p>
<pre><code class="language-bash"># On construit l'arborescence
mkdir -pv hardware/boards
cd hardware
# On y clone les librairies du Club et de DigiKey
git clone https://github.com/ClubRobotInsat/libkicad-robot.git
git clone https://github.com/digikey/digikey-kicad-library.git
</code></pre>
<p>Ne ferme pas le terminal, on n'en a pas fini :)</p>
<p>Si tu n'as pas <code>git</code> sur ton ordinateur je te renvoie à la section <a href="elec_mat/mise_en_place/git.html">correspondante</a>.</p>
<p>Il faut maintenant ouvrir un terminal et configurer <code>git</code> pour qu'il s'interface bien avec Kicad. Pour cela tu dois lancer le script <code>setup_git.sh</code> :</p>
<pre><code class="language-bash"># On se place dans le dossier où tu as clone le repo du club
cd kicad
# On lance le script
./setup_git.sh
</code></pre>
<p>Il faut ensuite rajouter ces librairies avec l'interface de Kicad.</p>
<h2 id="ajout-des-la-librairies-de-symboles-et-de-footprints"><a class="header" href="#ajout-des-la-librairies-de-symboles-et-de-footprints">Ajout des la librairies de symboles et de footprints</a></h2>
<ol start="0">
<li>Ouvre Kicad, puis ouvre <code>Preferences -&gt; Configure Paths...</code>. On va indiquer où Kicad doit chercher nos librairies. Normalement, tu obtiens une fenêtre qui liste tous les <em>Paths</em> (chemins de fichiers, comme sur linux) gérés par Kicad. On va y ajouter le nôtre : clique sur <code>Add</code>, puis entre :</li>
</ol>
<table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td>KIROBOT</td><td><code>Ton dossier **hardware**</code>/libkicad-robot</td></tr>
</tbody></table>
<ol>
<li>
<p>Ouvre ensuite l'éditeur de symbole, pour cela clique sur le petit composant (deuxième carré en partant de la gauche)</p>
<p><img src="elec_mat/mise_en_place/assets/kicad/open_symbol_editor.png" alt="Cliques sur le bouton rouge pour ouvrir l'éditeur de symbole" /></p>
</li>
<li>
<p>Ensuite, il faut rajouter la librairie contenant les <em>symboles</em> du club : <code>Preferences &gt; Manage Symbol Libraries</code>.
Dans le menu qui va s'ouvrir, clique sur <code>Browse Libraries</code> et navigue jusqu'au dossier <code>hardware/libkicad-robot/@Robot_symbols</code> et séléctionne <code>@Robot.lib</code>
Normalement tu as le résultat suivant à la fin de cette opération.
<img src="elec_mat/mise_en_place/assets/kicad/symbol_added.png" alt="La librairie de symboles après ajout des symboles du club robot" />
Si tu observes la même chose alors tu as réussi ton installation ! Tu peux maintenant ouvrir les <em>schematic</em> du club robot sans problème !</p>
</li>
<li>
<p>Tu peux fermer l'éditeur de symbole et passer sur l'éditeur de <em>footprint</em>, c'est le quatrième bouton en partant de la gauche.
<img src="elec_mat/mise_en_place/assets/kicad/open_footprint_editor.png" alt="Cliques sur le bouton rouge pour ouvrir l'éditeur de footprint" /></p>
</li>
<li>
<p>Ouvre le gestionnaire de librairie <code>Preferences &gt; Manage footprint libraries</code> et cliques sur <code>Browse Libraries</code> dans la fenêtre qui s'ouvre.</p>
</li>
<li>
<p>Navigue jusqu'à arriver au répertoire <code>hardware/libkicad-robot/@Robot.pretty</code> et clique sur Ok.</p>
</li>
<li>
<p>Normalement tu devrais obtenir le résultat suivant :
<img src="elec_mat/mise_en_place/assets/kicad/footprint_added.png" alt="La librairie de footprints aprés ajout de celle du club" /></p>
</li>
<li>
<p>Répète les opérations 1 à 6 pour ajouter à KiCAD n'importe quelle source externe de composants. Nous utilisons aussi ponctuellement les librairies offertes par DigiKey (distributeur de composants élec en ligne). Importe leurs libs dans <code>hardware/digikey-kicad-library</code> (<em>ctrl-a</em> te sera utile pour les symbols).</p>
</li>
<li>
<p>Si tout s'est bien passé <strong>BRAVO</strong> tu peux maintenant ouvrir et modifier toutes les cartes du club robot et créer les tiennes !</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-dutilisation-de-kicad"><a class="header" href="#guide-dutilisation-de-kicad">Guide d'utilisation de Kicad</a></h1>
<h2 id="intro"><a class="header" href="#intro">Intro</a></h2>
<p>On parlera ici de l'utilisation de KiCAD spécifique au club. Pour l'utilisation générale, consulte la doc inclue dans KiCAD, dans le menu aide/help. Elle est claire, et très bien complétée sur internet par une série de vidéos produites par <a href="https://www.youtube.com/watch?v=vaCVh2SAZY4&amp;index=9&amp;list=PLEBQazB0HUyR24ckSZ5u05TZHV9khgA1O&amp;t=0s">DigiKey</a>. </p>
<p>La réalisation d'une carte suit le <img src="elec_mat/../images/kicad/kicad_flowchart.png" alt="workflow" /> indiqué dans la doc de kicad. </p>
<h2 id="ouverture-dune-carte"><a class="header" href="#ouverture-dune-carte">Ouverture d'une carte</a></h2>
<p>Quand tu souhaites visualiser ou modifier une carte, ouvre (double clic) son fichier projet (.pro) ou ouvre directement son schematic avec kicad. Il se peut que des symboles soient 'cassés' : ils sont remplacés par les points d'interrogation. Dans ce cas, édite les : clic droit -&gt; properties -&gt; edit properties et choisis 'change' sous le champ 'Library Symbol'. Remplace alors le symbole par sa version à jour. Si tu ne le trouve nulle part, vérifie si tu as bien importé les librairies du club, et celles offertes par DigiKey.</p>
<h2 id="création-dune-carte"><a class="header" href="#création-dune-carte">Création d'une carte</a></h2>
<p>Pour créer une carte, il faut suivre <em>méticuleusement</em> le protocole suivant pour être certain de ne pas imprimer de carte inutilisable, ou juste trop difficile à imprimer.</p>
<p><strong>1) Pose toi la question de quel template utiliser.</strong></p>
<p>Pour le moment le club n'en a qu'un seul pour une carte classique avec une blackpill et un USR-US1 (le connecteur ethernet) dessus. Copie donc le template <code>libkicad-robot/templates/carte_generique_2019_stm32f103</code> dans ton dossier <code>boards</code>. et renomme le dossier et les fichiers en suivant cette convention : </p>
<pre><code>boards
├── {fonction}_{année}_{microcontrôleur}
│   ├── {fonction}_{année}_{microcontrôleur}.pro
│   ├── {fonction}_{année}_{microcontrôleur}.sch
│   └── {fonction}_{année}_{microcontrôleur}.kicad_pcb
</code></pre>
<p>Dans la mesure du possible, tous les noms <em>sont_en_minuscules_séparés_par_des_underscores</em> (convention snake_case).</p>
<p><strong>2) Préparaion du schematic</strong></p>
<p>Dans un premier temps, il faut remplir l'encadré en bas à droite avec l'insertion de texte, c'est à dire remplir les champs en gras (nom, prénom, date, titre de la carte). La date sera actualisée à chaque grosse mise à jour.
Chaque fichier et chaque carte doit être tracable en cas de besoin. Ceux qui reprendront ta carte quand tu auras quitté le club doivent avoir quelqu'un à qui poser les questions !</p>
<p><strong>3) Préparation du routage</strong></p>
<p>Ouvre maintenant le pcb de ta nouvelle carte et <strong>VERIFIE LES DESIGN RULES</strong>. Il va falloir bien suivre, la suite est très importante et te fera gagner <em>beaucoup</em> de temps. \n Un peu de contexte : plus une piste est large, plus elle peut conduire du courant sans chauffer. Une piste qui chauffe, ca veut dire des soudures qui fondent ou des composants qui grillent. Mais plus une piste est large, plus le routage sera difficile. Le nouveau jeu est donc de dimensionner chaque piste en fonction de son utilisation : pistes fines pour du signal, pistes larges pour la puissance.</p>
<p>Pour cela, la solution idéale serait justement de pouvoir indiquer à KiCAD quelles connexions seront utilisées pour de la logique, et quelles connexions feront passer des gros courants. Ca tombe bien ! <em>Setup -&gt; Design rules...</em> à été inventé pour ca. C'est un processus en deux étapes. </p>
<ul>
<li>
<p>D'abord on remplit le tableau 'Net classes'. On indique à KiCAD la liste des différents types de connexion.
La plupart du temps nous n'aurons que des pistes logiques. Tant qu'il n'y a pas de puissance, change la classe <code>default</code>en y entrant 0.381 dans <code>Clearance</code> et 0.381 dans <code>Track Width</code>. </p>
</li>
<li>
<p>Ouvre ensuite l'onglet <code>Global Design Rules</code> et remplis le tableau (en bas à droite) : </p>
</li>
</ul>
<table><thead><tr><th></th><th>Width</th></tr></thead><tbody>
<tr><td>Track 1</td><td>0.254</td></tr>
<tr><td>Track 2</td><td>0.381</td></tr>
<tr><td>Track 3</td><td>0.762</td></tr>
</tbody></table>
<p>Ce sont les trois épaisseurs <em>standard</em> qu'utilise le club. Quand tu choisiras ton épaisseur de piste (en haut à gauche de l'interface de pcbnew), tu devras utiliser la 3 quand c'est possible, puis la 2 si nécéssaire, puis la 1 <strong>sur une distance très courte</strong> dans le pire des cas.</p>
<p>Pour finir, il faut remplir compléter le texte à l'envers (nom, prénom, date, titre de la carte). Il sert à rendre ta carte encore mieux tracable, et à aider à l'imprimer à l'endroit.</p>
<p>En principe, tout est prêt pour que tu commences à ajuster le schematic puis à dessiner le PCB toi-même. Le chapitre suivant donne des indications et explique le fonctionnement de certains outils usuels.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conseils--astuces-pour-réussir-sa-carte"><a class="header" href="#conseils--astuces-pour-réussir-sa-carte">Conseils &amp; Astuces pour réussir sa carte</a></h1>
<h2 id="organisation-et-clarté-su-schematic"><a class="header" href="#organisation-et-clarté-su-schematic">Organisation et clarté su schematic</a></h2>
<p>La règle d'or lors du dessin d'un schematic est la <strong>lisibilité</strong> ! Comme il ne représente rien en réalité, il faut qu'il soir le plus lisible possible, et le plus facile à modifier !
Deux outils sont indispensables à maitriser (pas de vraie difficulté) : </p>
<h3 id="place-graphic-lines-or-polygons"><a class="header" href="#place-graphic-lines-or-polygons">&quot;Place graphic lines or polygons&quot;</a></h3>
<p>Il te permet d'encadrer chaque partie de ton circuit. On cherche en général à l'organiser (donc diviser) en fonctions élémentaires. Par exemple, tous les connecteurs de puissance seront à un endroit, toutes les led dans un autre, le microcontroleur sera au centre etc... Chaqun de ces bloc-fonction doit être encadré et nommé avec l'outil &quot;Place text&quot;.</p>
<h3 id="place-net-label"><a class="header" href="#place-net-label">&quot;Place net label&quot;</a></h3>
<p>Il est l'heure de te présenter ton nouvel outil favori. Petit retour théorique : le potentiel électrique (tension par rapport à la masse, ou 'altitude electrique') est le même le long d'un fil. C'est toujours valable si deux fils sont connectés ! Ils forment alors un <strong>noeud</strong> (de fils), ou <strong>net</strong> en anglais. On comprend alors que le potentiel electrique est le même partout sur un noeud donné ! L'équivalent <strong>noeud &lt;=&gt; potentiel</strong> nous permet de nommer une connexion entre plusieurs parties du circuit : c'est le <strong>net label</strong>. L'opportunité est fantasique : tu n'as plus besoin de connecter des composants avec des fils (ce sera brouillon rapidement), mais tu peux placer un <strong>net label</strong> (appelé label par abus de language) sur chaque pin à connecter, et ce peu importe leur nombre ! Cet outil nous permet de rendre invisible les fils entre les différents blocs : le schematic devient beaucoup plus clair ! </p>
<h2 id="ordre-des-priorités-pendant-le-routage"><a class="header" href="#ordre-des-priorités-pendant-le-routage">Ordre des priorités pendant le routage</a></h2>
<p>Pour commencer, il faut savoir ce que tu es en train de faire. Si tu est en train de créer une carte pas très compliquée, ce sera une <em>'simple face'</em>, sinon nous travaillerons en <em>'double face'</em>. La différence est qu'en double face tu pourras placer beaucoup plus de pistes qu'en simple face. Les faces sur lesquelles nous travailleront sont judicieusement nommées Top et Bottom, donc recto et verso. </p>
<p>Deux rappels avant de commencer à dessiner : </p>
<ul>
<li>Deux pistes sur une même face ne peuvent pas se croiser</li>
<li>Les composants traversants ne sont jamais du même côté que les pistes auxquelles ils sont connectés, sinon ils seront impossibles à souder !</li>
</ul>
<p>Par défaut, place les <strong>composants traversants</strong> au <strong>TOP</strong> et les <strong>pistes et cms</strong> au <strong>BOTTOM</strong>. </p>
<h2 id="placement-des-composants"><a class="header" href="#placement-des-composants">Placement des composants</a></h2>
<p>Avant de connecter les composants, il faut les placer (<em>duh</em>). Il n'y a pas de règle générale pour t'aider. Ca se fait très empiriquement. On commence au moins par placer les connecteurs et les led sur les bords de la carte. Dans la mesure du possible, il vaut mieux n'utiliser que deux arrêtes opposées : les entrées à gauche du microcontroleur et les sorties à droite. Tout sera plus simple pendant le câblage. Fais comme tu l'entends, mais pense au futur utilisateur de ta carte : n'hésite pas à abuser du rendu 3D de ta carte pour de demander <em>comment tu peux rendre cette carte facile à utiliser</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faire-tirer-sa-carte"><a class="header" href="#faire-tirer-sa-carte">Faire tirer sa carte</a></h1>
<p>Nous avons trois méthodes disponibles pour faire imprimer des cartes.</p>
<p>Quand tu as ton masque en pdf, tu peux passer par le/la responsable élec pour le <strong>transmettre directement au GEI</strong>. Ils nous improment gratuitement nos cartes simple et double face en 24 à 48h.</p>
<p>Si le temps presse, tu peux aussi <strong>aller directement au FabLab</strong> pour l'imprimer. Toute la procédure y est très bien expliquée là-bas dans un petit livret. N'hésite <strong>jamais</strong> a demander de l'aide à un membre du Club ou du FabLab : tirer une carte amène à manipuler des produits corrosifs.</p>
<p>Solution de dernier recours, nous avons quelquefois besoin de la <strong>commander sur internet</strong> (<a href="https://jlcpcb.com/">jlpcb</a> par exemple). Les cartes imprimées sont très propres et peuvent être multicouches (plus de deux plans). Le prix est cependant plus élevé qu'au FabLab, et les cartes mettent généralement longtemps à venir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annexe--références"><a class="header" href="#annexe--références">Annexe : Références</a></h1>
<p>Ici tu trouveras des listes diverses à consulter régulièrement lorsque tu travailles sur du hardware. 
Pour le moment, cette annexe contient une liste des composants fréquement utilisés ainsi que l'ensemble des cartes électroniques réalisées ou achetées par le Club.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilisation-du-module-ethernet"><a class="header" href="#utilisation-du-module-ethernet">Utilisation du module ethernet</a></h1>
<p>La communication entre la raspberry pi et les cartes se fait par ethernet (udp) depuis 2018. 
Maintenant, la partie matérielle de cette communication est basée sur le connecteur <a href="https://www.usriot.com/download/ES1/USR-ES1-EN%20V1.3.pdf">USR-ES1</a> : </p>
<p><img src="elec_mat/references/../../images/components/USR-ES1_pinout.png" alt="Module Ethernet" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annexe--liste-des-cartes-du-club"><a class="header" href="#annexe--liste-des-cartes-du-club">Annexe : liste des cartes du Club</a></h1>
<p>Voici la liste des cartes que nous avons au Club, utilisées ou non.</p>
<table><thead><tr><th>Nom</th><th>Fonction</th><th>Statut</th><th>Stock</th><th>Lien</th></tr></thead><tbody>
<tr><td>Pompes</td><td>Contrôler les pompes à vide</td><td>En développement</td><td>0</td><td><a href="https://github.com/ClubRobotInsat/pump_2019_f103.git">github</a></td></tr>
<tr><td>Servomoteurs</td><td>Communiquer avec et alimenter les herkulex</td><td>En développement</td><td>0</td><td><a href="https://github.com/ClubRobotInsat/servo_2019_f103">github</a></td></tr>
<tr><td>Alim</td><td>Alimenter le robot de manière sécurisée</td><td>Active</td><td>2</td><td><a href="https://svn.etud.insa-toulouse.fr/roboinsat/elec/CarteAlimentation/">svn</a></td></tr>
<tr><td>Alim Raspi</td><td>Alimenter la Raspi de manière sécurisée et indépendante du robot</td><td>Active</td><td>1</td><td></td></tr>
<tr><td>Shield</td><td>Attacher proprement la nucléo au robot, permettre de ne pas utiliser ses jumpers directement</td><td>En refonte</td><td>1</td><td></td></tr>
<tr><td>Pont H</td><td>Alimenter et contrôler les moteurs DC</td><td>Active</td><td>6</td><td></td></tr>
<tr><td>Evitement</td><td>Asservir le moteur de la tourelle</td><td>Obsolète</td><td>1</td><td></td></tr>
<tr><td>Déplacement</td><td>Controler les moteurs de déplacement</td><td>En refonte</td><td>1</td><td><a href="https://github.com/ClubRobotInsat/deplacement_2019_f103">github</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annexe--liste-des-composants-utilisés"><a class="header" href="#annexe--liste-des-composants-utilisés">Annexe : liste des composants utilisés</a></h1>
<p>Voici une liste <strong>non exhaustive</strong> des composants qu'utilise le club. 
N'hésitez pas à la mettre à jour ! </p>
<h2 id="connectique"><a class="header" href="#connectique">Connectique</a></h2>
<h3 id="pinsocket-et-pinheaders"><a class="header" href="#pinsocket-et-pinheaders">Pinsocket et pinheaders</a></h3>
<table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Pinsocket</td><td><a href="http://suddendocs.samtec.com/catalog_english/ssw_th.pdf">Liste</a></td><td>Fixer de manière réversible la nucléo à la carte shield</td></tr>
<tr><td>Pinsocket sécable</td><td>BL1.36Z</td><td>Pinsocket de n'importe quelle longueur.</td></tr>
</tbody></table>
<h3 id="connexion-carte-à-fil"><a class="header" href="#connexion-carte-à-fil">Connexion carte à fil</a></h3>
<h4 id="he14"><a class="header" href="#he14">HE14</a></h4>
<table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Connecteur Phoenix 2</td><td><a href="https://fr.farnell.com/phoenix-contact/1725656/bornier-sur-ci-2v-2-54mm/dp/3041359">1725656</a></td><td>Très fiables, 2 terminaux</td></tr>
<tr><td>Connecteur Phoenix 3</td><td><a href="https://fr.farnell.com/phoenix-contact/1725656/bornier-sur-ci-2v-2-54mm/dp/3041359">1725669</a></td><td>Très fiables, 3 terminaux</td></tr>
<tr><td>Connecteur Phoenix 5</td><td><a href="https://fr.farnell.com/phoenix-contact/1725656/bornier-sur-ci-2v-2-54mm/dp/3041359">2776439</a></td><td>Très fiables, 5 terminaux</td></tr>
<tr><td>HE14-f3</td><td>189-9441 (<a href="https://fr.rs-online.com">RS</a>)</td><td></td></tr>
<tr><td>HE14-f2</td><td>189-9435 (<a href="https://fr.rs-online.com">RS</a>)</td><td></td></tr>
<tr><td>HE14-m5</td><td>230-5082 (<a href="https://fr.rs-online.com">RS</a>)</td><td></td></tr>
<tr><td>HE14-m3</td><td>230-5060 (<a href="https://fr.rs-online.com">RS</a>)</td><td></td></tr>
<tr><td>HE14-m2</td><td>230-5054 (<a href="https://fr.rs-online.com">RS</a>)</td><td></td></tr>
</tbody></table>
<h3 id="autres"><a class="header" href="#autres">Autres</a></h3>
<table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Terminal Batterie vert</td><td></td><td></td></tr>
<tr><td>Connecteur MXS</td><td></td><td></td></tr>
</tbody></table>
<h2 id="puissance"><a class="header" href="#puissance">Puissance</a></h2>
<table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Bouton ARU</td><td></td><td>Contrôler l'alim du robot</td></tr>
<tr><td>Régulateur logique</td><td>PTH08080W</td><td>Passer de Vbat à 5v</td></tr>
<tr><td>Buck réglable</td><td>LM2576</td><td>Diminuer Vbat, utilisé pour avoir les 7.4V des herkulex</td></tr>
<tr><td>Gros interrupteur</td><td>MR02</td><td></td></tr>
<tr><td>Petit interrupteur</td><td></td><td></td></tr>
<tr><td>Fusible automobile</td><td></td><td></td></tr>
<tr><td>Fusible tube</td><td></td><td></td></tr>
</tbody></table>
<h2 id="microcontrôleurs"><a class="header" href="#microcontrôleurs">Microcontrôleurs</a></h2>
<h2 id="communication-1"><a class="header" href="#communication-1">Communication</a></h2>
<table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Transcriever CAN</td><td>MCP2551</td><td></td></tr>
<tr><td>Recepteur IR</td><td>HR12020104</td><td></td></tr>
<tr><td>Magnétomètre</td><td>HMC 5883L</td><td></td></tr>
<tr><td>Accéléromètre 3 axes</td><td>MPU-6050</td><td></td></tr>
<tr><td>Module XBee</td><td>4214A-XBee</td><td></td></tr>
</tbody></table>
<h2 id="capteurs"><a class="header" href="#capteurs">Capteurs</a></h2>
<table><thead><tr><th>Nom commun</th><th>Référence</th><th>Notes</th></tr></thead><tbody>
<tr><td>Webcam</td><td>COMedia 3088</td><td></td></tr>
<tr><td>Detecteur IR</td><td>SHARP</td><td></td></tr>
<tr><td>Gros bouton poussoir</td><td></td><td></td></tr>
<tr><td>Petit bouton poussoir</td><td></td><td></td></tr>
</tbody></table>
<h1 id="cms"><a class="header" href="#cms">CMS</a></h1>
<h2 id="résistances"><a class="header" href="#résistances">Résistances</a></h2>
<table><thead><tr><th>Nom</th><th>Valeur</th><th align="center">Package 0805</th><th align="center">Package 1206</th></tr></thead><tbody>
<tr><td>Résistance</td><td>0 R</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>47 R</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>50 R</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>100 R</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>150 R</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>169 R</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>220 R</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>240 R</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>300 R</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>330 R</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>348 R</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>470 R</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>499 R</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>620 R</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>1 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>1,2 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>1,5 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>2,2 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>2,26 kR</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>2,8 kR</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>3,3 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>4,3 kR</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>4,7 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>6,8 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>8,2 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>10 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>11,5 kR</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>12 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>15 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>20 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>22 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>33 kR</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>39 kR</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>43 kR</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>47 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>68 kR</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>75 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>100 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>180 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>200 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>250 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>470 kR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>Résistance</td><td>1 MR</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>Résistance</td><td>2,2 MR</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
</tbody></table>
<h2 id="condensateurs"><a class="header" href="#condensateurs">Condensateurs</a></h2>
<table><thead><tr><th>Valeur</th><th align="center">Package 0805</th><th align="center">Package 1206</th></tr></thead><tbody>
<tr><td>22 pf</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>560 pf</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>1 nf</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>1,2 nf</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>2,2 nf</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>4,7 nf</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>10 nf</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>12 nf</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>12 nf</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>90 nf</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"></td></tr>
<tr><td>100 nf</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>220 nf</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>470 nf</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>920 nf</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>1 µf</td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
<tr><td>10 µf</td><td align="center"></td><td align="center"><img src="elec_mat/references/../../images/icons/green_tick.png" alt="X" /></td></tr>
</tbody></table>
<h2 id="autres-1"><a class="header" href="#autres-1">Autres</a></h2>
<table><thead><tr><th>Nom</th><th align="center">Package</th><th align="center">Quantité</th><th align="left">Autres</th></tr></thead><tbody>
<tr><td>Led Jaune</td><td align="center">1206</td><td align="center">4</td><td align="left">2V</td></tr>
<tr><td>Led Vertes</td><td align="center">1206</td><td align="center">3</td><td align="left">2V</td></tr>
<tr><td>Led Rouges</td><td align="center">1206</td><td align="center">50+</td><td align="left">2V</td></tr>
<tr><td>Diode Rectif Schottk</td><td align="center">2512</td><td align="center">10+</td><td align="left">30v, 1A, ref SS13B</td></tr>
<tr><td>Diode Mesure courant</td><td align="center">1206</td><td align="center">3</td><td align="left">0.01R , ref LVK12RO10FER</td></tr>
<tr><td>Optocoupleur</td><td align="center">8SOIC</td><td align="center">5</td><td align="left">ref HCPL-06360-000E</td></tr>
<tr><td>Optocoupleur</td><td align="center"></td><td align="center"></td><td align="left">ref H11D1</td></tr>
<tr><td>Résistance 0.1R</td><td align="center">2512</td><td align="center">20</td><td align="left">2W, 5%</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cablage-du-robot"><a class="header" href="#cablage-du-robot">Cablage du Robot</a></h1>
<p>Pour le cablage de la carte déplacement, il y a le schéma suivant :</p>
<p><img src="elec_mat/../images/cablage_robot.png" alt="" title="Cablage du robot" /></p>
<p>Les conventions couleurs sont celles décrites sur le côté des roues codeuses, n'hésitez pas à vous y réferer !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documents-de-référence"><a class="header" href="#documents-de-référence">Documents de référence</a></h1>
<p>Cette section contiens la documentation pour chaque carte electronique.</p>
<p>Cette documentation est composée de :</p>
<ul>
<li>liste des composants spéciaux et leur datasheet</li>
<li>format du protocole de communication</li>
</ul>
<p><a href="reference/reference/commun.html">Commun</a> contiens tout ce qui est commun à toute les cartes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communs"><a class="header" href="#communs">Communs</a></h1>
<h1 id="sommaire"><a class="header" href="#sommaire">Sommaire</a></h1>
<ol>
<li><a href="reference/commun.html#communication">Communication</a></li>
<li><a href="reference/commun.html#microcontroleur">Microcontrôleur</a></li>
<li><a href="reference/commun.html#black-pill">Black-Pill</a></li>
<li><a href="reference/commun.html#quartz">Quartz</a></li>
</ol>
<h2 id="communication-2"><a class="header" href="#communication-2">Communication</a></h2>
<p>Pour la communication on utilise sur nos cartes un composants tout fait : le w5500.</p>
<p><a href="reference/../datasheets/w5500/w5500.pdf">Datasheet du w5500</a>.</p>
<p>Ce composant est monté sur une minicarte toute faîte que l'on achète chez <a href="https://www.makerfabs.com/Mini-Ethernet-Board-W5500.html">makerfabs</a>. (si le lien meurs, cherchez &quot;mini ethernet board w5500&quot;).</p>
<p><img src="reference/../images/components/w5500.jpg" alt="Image de la mini carte" /></p>
<p><a href="reference/../datasheets/w5500/w5500_board_sizes.pdf">Dimension de la carte</a></p>
<p><a href="reference/../datasheets/w5500/w5500_board_schem.pdf">Schematic de la carte</a></p>
<p><img src="reference/../datasheets/w5500/w5500_board_pcb.png" alt="PCB de la carte" /></p>
<p>Coté logiciel, il existe une librairie sur <a href="https://crates.io/crates/w5500">crates.io</a>.</p>
<hr />
<h2 id="microcontroleur"><a class="header" href="#microcontroleur">Microcontroleur</a></h2>
<p>On utilise en ce moment le <a href="https://www.st.com/en/microcontrollers/stm32f103.html?querycriteria=productId=LN1565">stm32f103</a>.</p>
<p>Il viens en plusieurs déclinaisons (ce sont les lettres qui viennent derrière le nom du microcontrôleur). Les principales différences entre ces déclinaisons sont :</p>
<ul>
<li>Taille de la RAM</li>
<li>Taille de la flash</li>
<li>Nombre de timers</li>
</ul>
<p><a href="reference/../datasheets/stm32f103/f103_ref_manual.pdf">Manuel de référence de la famille des cortex M1</a></p>
<p><a href="reference/../datasheets/stm32f103/cortex_m1_ref_manual.pdf">Datasheet de la puce</a></p>
<hr />
<h2 id="black-pill"><a class="header" href="#black-pill">Black-Pill</a></h2>
<p>Pour le prototypage on utilise un <a href="reference/commun.html#microcontroleur">stm32f103</a> monté sur un PCB déjà routé.
La carte s'appelle <a href="https://robotdyn.com/stm32-arm-arduino-mini-system-dev-board-blue-pill-with-arduino-bootloader.html">black-pill</a>.</p>
<p><a href="reference/../datasheets/black-pill/black-pill-pinout.pdf">Pinout de la carte</a></p>
<p><a href="reference/../datasheets/black-pill/black-pill-schematic.pdf">Schematic de la carte</a></p>
<p><a href="https://wiki.stm32duino.com/index.php?title=Black_Pill">Plus d'informations sur la carte</a></p>
<hr />
<h2 id="quartz"><a class="header" href="#quartz">Quartz</a></h2>
<p>Le microcontroleur a besoin d'un signal d'horloge fixé pour pouvoir fonctionner correctement. Ce signal est généré par un <a href="https://fr.wikipedia.org/wiki/Quartz_(%C3%A9lectronique)">quartz</a> qu'il faut choisir selon plusieurs critères.</p>
<p>Le quartz a également besoin de composants externes pour fonctionner correctement : il faut ajouter 2 condensateurs de même valeur et éventuellement une résistance, selon le schéma suivant :</p>
<p><img src="reference/../images/components/Schema_quartz.png" alt="Schema_quartz" /></p>
<p>Le condensateur <a href="https://www.codecogs.com/eqnedit.php?latex=C_S" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_S" title="C_S" /></a> correspond à la capacité parasite due aux fils. On peut l'approximer à 5 pF dans les calculs.</p>
<p><strong>1. La marge de gain</strong></p>
<p>Pour faire naitre les oscillations dans le cristal, il faut s'assurer que la transconductance interne du microcontroleur (<a href="https://www.codecogs.com/eqnedit.php?latex=g_m" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_m" title="g_m" /></a>) est au moins 5 fois supérieure à celle du quartz choisi.
La marge de gain se calcule grâce a la formule suivante :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=Gain_{margin}=\frac{g_m}{g_{mcrit}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?Gain_{margin}=\frac{g_m}{g_{mcrit}}" title="Gain_{margin}=\frac{g_m}{g_{mcrit}}" /></a></p>
<p>Avec <a href="https://www.codecogs.com/eqnedit.php?latex=g_{mcrit}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_{mcrit}" title="g_{mcrit}" /></a> donné par la formule :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=g_{mcrit}&space;=&space;4*ESR*(2\pi&space;F)^2*(C_0&space;&plus;&space;C_L)^2" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_{mcrit}&space;=&space;4*ESR*(2\pi&space;F)^2*(C_0&space;&plus;&space;C_L)^2" title="g_{mcrit} = 4*ESR*(2\pi F)^2*(C_0 + C_L)^2" /></a></p>
<p>Où :</p>
<ul>
<li><a href="https://www.codecogs.com/eqnedit.php?latex=\textrm{ESR}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\textrm{ESR}" title="\textrm{ESR}" /></a> = <em>Equivalent Series Resistor</em> : la résistance série équivalente du quartz (donnée par le fabriquant, elle dépend de la fréquence de fonctionnement).</li>
<li><a href="https://www.codecogs.com/eqnedit.php?latex=\textrm{F}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\textrm{F}" title="\textrm{F}" /></a> = Fréquence de fonctionnement du quartz (donnée par le fabriquant).</li>
<li><a href="https://www.codecogs.com/eqnedit.php?latex=C_0" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_0" title="C_0" /></a> = <em>Shunt capacitance</em> : c'est la valeur de la capacité résultante des électrodes du quartz (donnée par le fabriquant).</li>
<li><a href="https://www.codecogs.com/eqnedit.php?latex=C_L" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_L" title="C_L" /></a> = <em>Load capacitance</em> (donnée par le fabriquant)</li>
</ul>
<p>La valeur de <a href="https://www.codecogs.com/eqnedit.php?latex=g_m" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_m" title="g_m" /></a> se trouve dans la datasheet du microcontrôleur.</p>
<p>Si la marge de gain calculée est bien supérieure à 5, on peut passer à l'étape suivante. Sinon, il faut choisir un autre quartz avec un <a href="https://www.codecogs.com/eqnedit.php?latex=g_m" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_m" title="g_m" /></a> plus petit.</p>
<p><strong>2. Choix des condensateurs externes <a href="https://www.codecogs.com/eqnedit.php?latex=C_{L1}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L1}" title="C_{L1}" /></a> et <a href="https://www.codecogs.com/eqnedit.php?latex=C_{L2}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L2}" title="C_{L2}" /></a></strong></p>
<p>On choisit les condensateurs de manière à respecter la relation :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=C_L-C_S&space;=&space;\frac{C_{L1}*C_{L2}}{C_{L1}&plus;C_{L2}]}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_L-C_S&space;=&space;\frac{C_{L1}*C_{L2}}{C_{L1}&plus;C_{L2}]}" title="C_L-C_S = \frac{C_{L1}*C_{L2}}{C_{L1}+C_{L2}]}" /></a></p>
<p>Si on prend <a href="https://www.codecogs.com/eqnedit.php?latex=C_{L1}=C_{L2}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L1}=C_{L2}" title="C_{L1}=C_{L2}" /></a>, on peut choisir <a href="https://www.codecogs.com/eqnedit.php?latex=C_{L1}=C_{L2}=2(C_L-C_S)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L1}=C_{L2}=2(C_L-C_S)" title="C_{L1}=C_{L2}=2(C_L-C_S)" /></a>.</p>
<p><strong>3. Choix d'une résistance externe <a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}" title="R_{Ext}" /></a></strong></p>
<p>Le quartz ne peut dissiper qu'une certaine puissance maximale donnée par le fabriquant : c'est le <em>Drive Level</em> du cristal. Si jamais la puissance dissipée par le quartz dépasse cette valeur, celui-ci peut être endommagé et griller.</p>
<p>Pour éviter cela, on peut choisir d'ajouter une résistance externe qui va dissiper la puissance en trop. pour savoir si on a besoin de cette résistance, il y a 2 manières de procéder :</p>
<ul>
<li>
<p><strong>Méthode 1 :</strong> Mesurer le courant <a href="https://www.codecogs.com/eqnedit.php?latex=I_Q" target="_blank"><img src="https://latex.codecogs.com/gif.latex?I_Q" title="I_Q" /></a> qui traverse le quartz pendant son fonctionnement à l'aide d'une sonde et d'un oscilloscope. On obtient ensuite le courant maximal admissible (en valeur pic-à-pic) par la formule :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=I_{Qmax_{pp}}&space;=&space;2\sqrt{\frac{2D_L}{ESR}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?I_{Qmax_{pp}}&space;=&space;2\sqrt{\frac{2D_L}{ESR}}" title="I_{Qmax_{pp}} = 2\sqrt{\frac{2D_L}{ESR}}" /></a></p>
<p>Si le courant mesuré est plus important, il faut ajouter <a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}" title="R_{Ext}" /></a>. Sinon, on a trouvé un quartz qui convient bravo !</p>
</li>
<li>
<p><strong>Méthode 2 :</strong> Mesurer la tension aux bornes de <a href="https://www.codecogs.com/eqnedit.php?latex=C_{L1}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L1}" title="C_{L1}" /></a> et en déduire le courant qui travers le quartz. Attention pour cette méthode il faut utiliser une sonde qui a une capacité en entrée inférieure à 1 pF. Le <em>Drive Level</em> est alors donné par la formule :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=D_L&space;=&space;\frac{ESR*(\pi*F*C_{tot})^2)*V_{pp}^2}{2}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?D_L&space;=&space;\frac{ESR*(\pi*F*C_{tot})^2)*V_{pp}^2}{2}" title="D_L = \frac{ESR*(\pi*F*C_{tot})^2)*V_{pp}^2}{2}" /></a></p>
<p>Où <a href="https://www.codecogs.com/eqnedit.php?latex=C_{tot}&space;=&space;C_{L1}&plus;\frac{{C_S}}{2}&plus;C_{sonde}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{tot}&space;=&space;C_{L1}&plus;\frac{{C_S}}{2}&plus;C_{sonde}" title="C_{tot} = C_{L1}+\frac{{C_S}}{2}+C_{sonde}" /></a> et <a href="https://www.codecogs.com/eqnedit.php?latex=V_{pp}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?V_{pp}" title="V_{pp}" /></a> est la valeur de tension pic-à-pic mesurée à l'oscilloscope.</p>
<p>Si le <em>Drive Level</em> calculé est supérieure à celui donné par le fabriquant, il faut ajouter <a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}" title="R_{Ext}" /></a>. Sinon, on a trouvé un quartz qui convient bravo !</p>
</li>
</ul>
<p>Calcul de <a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}" title="R_{Ext}" /></a> :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}&space;=&space;\frac{1}{2\pi&space;FC_{L2}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}&space;=&space;\frac{1}{2\pi&space;FC_{L2}}" title="R_{Ext} = \frac{1}{2\pi FC_{L2}}" /></a></p>
<p><strong>ATTENTION :</strong> si on a ajouté <a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}" title="R_{Ext}" /></a> il faut recalculer les valeurs de marges de gain en la prenant en compte :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=g_{mcrit}&space;=&space;4*(ESR&plus;R_{Ext})*(2\pi&space;F)^2*(C_0&plus;C_L)^2" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_{mcrit}&space;=&space;4*(ESR&plus;R_{Ext})*(2\pi&space;F)^2*(C_0&plus;C_L)^2" title="g_{mcrit} = 4*(ESR+R_{Ext})*(2\pi F)^2*(C_0+C_L)^2" /></a></p>
<p>Vérifier que la marge de gain est toujours supérieure à 5. Si ce n'est pas le cas, il faut choisir un autre quartz. Sinon, on a trouvé un quartz qui convient bravo !</p>
<p><strong>Exemple de calcul :</strong> Si on veut associer un quartz à 8 MHZ au microcontrôleur <a href="reference//datasheets/stm32f103/STM32F103x8.pdf">STM32F103C8T6</a>. On trouve un quartz qui a la fréquence de travaille demandée sur un site de confiance : <a href="https://fr.farnell.com/fox-electronics/foxsdlf-080-20/crystal-8-0mhz-20pf-smd/dp/2063972">celui-ci</a> par exemple (<a href="reference/datasheets/quartz/Quartz_8Mhz.pdf">datasheet</a>).</p>
<p>D'après les 2 datasheets, les valeurs dont on a besoin pour les calculs sont les suivantes :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=g_m&space;=&space;25\,mA/V\\&space;\indent&space;F&space;=&space;8\,&space;MHz\\&space;\indent&space;C_0&space;=&space;7\,&space;pF\\&space;\indent&space;ESR&space;=&space;80&space;\,\Omega&space;\\&space;\indent&space;C_L&space;=&space;20&space;pF\\" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_m&space;=&space;25\,mA/V\\&space;\indent&space;F&space;=&space;8\,&space;MHz\\&space;\indent&space;C_0&space;=&space;7\,&space;pF\\&space;\indent&space;ESR&space;=&space;80&space;\,\Omega&space;\\&space;\indent&space;C_L&space;=&space;20&space;pF\\" title="g_m = 25\,mA/V\\ \indent F = 8\, MHz\\ \indent C_0 = 7\, pF\\ \indent ESR = 80 \,\Omega \\ \indent C_L = 20 pF\\" /></a></p>
<p>On peut donc calculer notre marge de gain :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=g_{mcrit}&space;=&space;5.894.10^{-4}&space;\,A/V" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g_{mcrit}&space;=&space;5.894.10^{-4}&space;\,A/V" title="g_{mcrit} = 5.894.10^{-4} \,A/V" /></a> donc <a href="https://www.codecogs.com/eqnedit.php?latex=Gain_{margin}&space;=&space;\frac{25}{0.5894}&space;=&space;42.4&space;>>&space;5" target="_blank"><img src="https://latex.codecogs.com/gif.latex?Gain_{margin}&space;=&space;\frac{25}{0.5894}&space;=&space;42.4&space;>>&space;5" title="Gain_{margin} = \frac{25}{0.5894} = 42.4 >> 5" /></a></p>
<p>Cette valeur de marge de gain étant largement suffisante, on peut calculer les valeurs de nos condensateurs :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=C_{L1}=C_{L2}=2(20-5)=30\,&space;pF" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_{L1}=C_{L2}=2(20-5)=30\,&space;pF" title="C_{L1}=C_{L2}=2(20-5)=30\, pF" /></a></p>
<p>Si jamais on devait ajouter une résistance externe, il faudrait que sa valeur soit de :</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=R_{Ext}&space;=&space;\frac{1}{2\pi&space;*8.10^6*30.10^{-12}}=663&space;\,\Omega" target="_blank"><img src="https://latex.codecogs.com/gif.latex?R_{Ext}&space;=&space;\frac{1}{2\pi&space;*8.10^6*30.10^{-12}}=663&space;\,\Omega" title="R_{Ext} = \frac{1}{2\pi *8.10^6*30.10^{-12}}=663 \,\Omega" /></a></p>
<p>On aurait alors une marge de gain de 5 : il faudrait donc choisir un autre quartz ayant un ESR plus faible ou bien un <a href="https://www.codecogs.com/eqnedit.php?latex=C_L" target="_blank"><img src="https://latex.codecogs.com/gif.latex?C_L" title="C_L" /></a> plus petit.</p>
<p>Pour plus de précision, voir le <a href="reference//datasheets/quartz/Oscillator_choice_guide">guide du choix d'un quartz fourni par ST</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-déplacement"><a class="header" href="#carte-déplacement">Carte déplacement</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-servomoteur"><a class="header" href="#carte-servomoteur">Carte servomoteur</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-évitement"><a class="header" href="#carte-évitement">Carte évitement</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-capteur-couleur"><a class="header" href="#carte-capteur-couleur">Carte capteur couleur</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-pompe-à-vide"><a class="header" href="#carte-pompe-à-vide">Carte pompe à vide</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communication-test"><a class="header" href="#communication-test">Communication (test)</a></h1>
<p>Dans cette partie, on va parler un peu de la &quot;<strong>communication</strong>&quot; du Club (on s'adresse aux membres intéressés par cet aspect mais aussi et surtout au <em>président</em> et à son <em>secrétaire</em> !)</p>
<h3 id="communication-interne"><a class="header" href="#communication-interne">Communication interne</a></h3>
<p>De fait, les gens au Club ont besoin de communiquer <em>entre eux</em> (pratique pour faire un projet à plusieurs) : on utilisera <a href="https://gitter.im/club-robot-insat/">Gitter</a> pour ça ! Il existe aussi un groupe <a href="https://www.facebook.com/groups/809109805874317/?ref=bookmarks">Facebook</a> qui date, avec pas mal d'anciens dessus : n'hésitez pas à demander à vous y ajouter, et si vous avez des infos à partager avec des très vieux, allez-y !
On utilise enfin le <a href="https://drive.google.com/drive/">drive</a> associé à l'adresse gmail du Club, pour stocker les documents relatifs au secrétariat, à la trésorie, des photos, etc.</p>
<h3 id="communication-externe"><a class="header" href="#communication-externe">Communication externe</a></h3>
<p>Ensuite, la communication du Club avec <em>l'extérieur</em> est également primordiale. On entend par là :</p>
<ul>
<li>communication (publications) sur notre <strong>page <a href="https://www.facebook.com/ClubRobotINSAT/">Facebook</a></strong></li>
<li>réponse aux messages &amp; questions reçus <em>via</em> <strong>messenger</strong></li>
<li>réponse aux messages &amp; questions reçus par <strong>e-mails</strong></li>
<li>communication (e-mails) avec nos <strong>sponsors</strong> : les informer régulièrement des avancées du projet, etc.</li>
<li>communication (e-mails) avec l'<strong>INSA</strong> (GEI, service communication, GM, etc.) : idem</li>
<li>communication (publications) sur notre <strong>site <a href="https://etud.insa-toulouse.fr/%7Eclub_robot/">web</a></strong> (car oui il existe un site web ! (qui date lui aussi, qu'on essaie de garder à jours mais que de jeunes gens motivés pourraient très bien refaire un jour !))</li>
</ul>
<p><em>Tout au long de l'année</em>, pas mal de choses sont à promouvoir autour du Club (événements, vie quotidienne, etc) et on en parle <a href="com//com/ext">ici</a>, avec une petite check-liste pour ne jamais être perdu !</p>
<h3 id="pleins-dimages-"><a class="header" href="#pleins-dimages-">Pleins d'images !</a></h3>
<p>Pour tous ces aspects de communication, de nombreuses <a href="com/">ressources</a> (images, documents, etc) existent, et on vous les présente <a href="com/">ici</a> ! Vous y trouverez des <strong>logos</strong>, de jolies <strong>infographies</strong>, plein de choses (voir bientôt des tutos peut-être^^) qui vous permettront de présenter le Club sous son meilleur jour ! (même s'il y fait beau tous les jours :) )</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interne-entre-nous"><a class="header" href="#interne-entre-nous">Interne (entre nous)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitter"><a class="header" href="#gitter">Gitter</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messengerfacebook"><a class="header" href="#messengerfacebook">Messenger/Facebook</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="externe"><a class="header" href="#externe">Externe</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="site"><a class="header" href="#site">Site</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="page-facebook"><a class="header" href="#page-facebook">Page Facebook</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ressources--images"><a class="header" href="#ressources--images">Ressources &amp; images</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
